import { IArena } from "valdi_protobuf/src/types";
import { Message as ProtobufMessage } from "valdi_protobuf/src/Message";

/**
 * Generated by generate_protos.py
 * DO NOT EDIT!
 */

export namespace test {
  export const enum Enum {
    VALUE_0 = 0,
    VALUE_1 = 1,
    /** Unrecognized value */
    $UNRECOGNIZED_VALUE = 0xffffffffff
  }

  /**
   * Test
   * multiline
   * comment
   */
  export class OtherMessage extends ProtobufMessage<IOtherMessage> {
    private constructor();

    public get value(): string;
    public set value(value: string);

    /**
     * Creates a new OtherMessage from properties
     * Returns a clone if a OtherMessage instance is provided
     */
    public static create(arena: IArena, properties?: OtherMessage | IOtherMessage): OtherMessage;
    /** Decode a buffer into a OtherMessage */
    public static decode(arena: IArena, buffer: Uint8Array): OtherMessage;
    /** Asynchronously decode a buffer into a OtherMessage */
    public static decodeAsync(arena: IArena, buffer: Uint8Array): Promise<OtherMessage>;
    /**
     * Encodes the provided OtherMessage into a buffer.
     * Calls encode() if an instance is provided, otherwise creates a new message with the given properties then calls encode() on it
     */
    public static encode(value: OtherMessage | IOtherMessage): Uint8Array;
    /**
     * Asynchronously encodes the provided OtherMessage into a buffer.
     * Calls encodeAsync() if an instance is provided, otherwise creates a new message with the given properties then calls encode() on it
     */
    public static encodeAsync(value: OtherMessage | IOtherMessage): Promise<Uint8Array>;
    /**
     * Asynchronously decode a JSON string into a OtherMessage.
     * This is discouraged and should be used as a debug option only.
     */
    public static decodeDebugJSONAsync(arena: IArena, json: string): Promise<OtherMessage>;
  }

  /** Interface for creating OtherMessage instances */
  export interface IOtherMessage {
    value?: string;
  }

  /**
   * Test comment
   * another line
   */
  export class Message extends ProtobufMessage<IMessage> {
    private constructor();

    public get int32(): number;
    public set int32(value: number);

    public get int64(): Long;
    public set int64(value: Long);

    public get uint32(): number;
    public set uint32(value: number);

    public get uint64(): Long;
    public set uint64(value: Long);

    public get sint32(): number;
    public set sint32(value: number);

    public get sint64(): Long;
    public set sint64(value: Long);

    public get fixed32(): number;
    public set fixed32(value: number);

    public get fixed64(): Long;
    public set fixed64(value: Long);

    public get sfixed32(): number;
    public set sfixed32(value: number);

    public get sfixed64(): Long;
    public set sfixed64(value: Long);

    public get float(): number;
    public set float(value: number);

    public get double(): number;
    public set double(value: number);

    public get bool(): boolean;
    public set bool(value: boolean);

    public get string(): string;
    public set string(value: string);

    public get bytes(): Uint8Array;
    public set bytes(value: Uint8Array);

    public get enum(): test.Enum;
    public set enum(value: test.Enum);

    public get selfMessage(): test.Message | undefined;
    public set selfMessage(value: test.Message | undefined);

    public get otherMessage(): test.OtherMessage | undefined;
    public set otherMessage(value: test.OtherMessage | undefined);

    /**
     * Creates a new Message from properties
     * Returns a clone if a Message instance is provided
     */
    public static create(arena: IArena, properties?: Message | IMessage): Message;
    /** Decode a buffer into a Message */
    public static decode(arena: IArena, buffer: Uint8Array): Message;
    /** Asynchronously decode a buffer into a Message */
    public static decodeAsync(arena: IArena, buffer: Uint8Array): Promise<Message>;
    /**
     * Encodes the provided Message into a buffer.
     * Calls encode() if an instance is provided, otherwise creates a new message with the given properties then calls encode() on it
     */
    public static encode(value: Message | IMessage): Uint8Array;
    /**
     * Asynchronously encodes the provided Message into a buffer.
     * Calls encodeAsync() if an instance is provided, otherwise creates a new message with the given properties then calls encode() on it
     */
    public static encodeAsync(value: Message | IMessage): Promise<Uint8Array>;
    /**
     * Asynchronously decode a JSON string into a Message.
     * This is discouraged and should be used as a debug option only.
     */
    public static decodeDebugJSONAsync(arena: IArena, json: string): Promise<Message>;
  }

  /** Interface for creating Message instances */
  export interface IMessage {
    int32?: number;
    int64?: Long;
    uint32?: number;
    uint64?: Long;
    sint32?: number;
    sint64?: Long;
    fixed32?: number;
    fixed64?: Long;
    sfixed32?: number;
    sfixed64?: Long;
    float?: number;
    double?: number;
    bool?: boolean;
    string?: string;
    bytes?: Uint8Array;
    enum?: test.Enum;
    selfMessage?: test.IMessage;
    otherMessage?: test.IOtherMessage;
  }

  export class RepeatedMessage extends ProtobufMessage<IRepeatedMessage> {
    private constructor();

    public get int32(): readonly number[];
    public set int32(value: readonly number[]);

    public get int64(): readonly Long[];
    public set int64(value: readonly Long[]);

    public get uint32(): readonly number[];
    public set uint32(value: readonly number[]);

    public get uint64(): readonly Long[];
    public set uint64(value: readonly Long[]);

    public get sint32(): readonly number[];
    public set sint32(value: readonly number[]);

    public get sint64(): readonly Long[];
    public set sint64(value: readonly Long[]);

    public get fixed32(): readonly number[];
    public set fixed32(value: readonly number[]);

    public get fixed64(): readonly Long[];
    public set fixed64(value: readonly Long[]);

    public get sfixed32(): readonly number[];
    public set sfixed32(value: readonly number[]);

    public get sfixed64(): readonly Long[];
    public set sfixed64(value: readonly Long[]);

    public get float(): readonly number[];
    public set float(value: readonly number[]);

    public get double(): readonly number[];
    public set double(value: readonly number[]);

    public get bool(): readonly boolean[];
    public set bool(value: readonly boolean[]);

    public get string(): readonly string[];
    public set string(value: readonly string[]);

    public get bytes(): readonly Uint8Array[];
    public set bytes(value: readonly Uint8Array[]);

    public get enum(): readonly test.Enum[];
    public set enum(value: readonly test.Enum[]);

    public get selfMessage(): readonly test.RepeatedMessage[];
    public set selfMessage(value: readonly test.RepeatedMessage[]);

    public get otherMessage(): readonly test.OtherMessage[];
    public set otherMessage(value: readonly test.OtherMessage[]);

    /**
     * Creates a new RepeatedMessage from properties
     * Returns a clone if a RepeatedMessage instance is provided
     */
    public static create(arena: IArena, properties?: RepeatedMessage | IRepeatedMessage): RepeatedMessage;
    /** Decode a buffer into a RepeatedMessage */
    public static decode(arena: IArena, buffer: Uint8Array): RepeatedMessage;
    /** Asynchronously decode a buffer into a RepeatedMessage */
    public static decodeAsync(arena: IArena, buffer: Uint8Array): Promise<RepeatedMessage>;
    /**
     * Encodes the provided RepeatedMessage into a buffer.
     * Calls encode() if an instance is provided, otherwise creates a new message with the given properties then calls encode() on it
     */
    public static encode(value: RepeatedMessage | IRepeatedMessage): Uint8Array;
    /**
     * Asynchronously encodes the provided RepeatedMessage into a buffer.
     * Calls encodeAsync() if an instance is provided, otherwise creates a new message with the given properties then calls encode() on it
     */
    public static encodeAsync(value: RepeatedMessage | IRepeatedMessage): Promise<Uint8Array>;
    /**
     * Asynchronously decode a JSON string into a RepeatedMessage.
     * This is discouraged and should be used as a debug option only.
     */
    public static decodeDebugJSONAsync(arena: IArena, json: string): Promise<RepeatedMessage>;
  }

  /** Interface for creating RepeatedMessage instances */
  export interface IRepeatedMessage {
    int32?: readonly number[];
    int64?: readonly Long[];
    uint32?: readonly number[];
    uint64?: readonly Long[];
    sint32?: readonly number[];
    sint64?: readonly Long[];
    fixed32?: readonly number[];
    fixed64?: readonly Long[];
    sfixed32?: readonly number[];
    sfixed64?: readonly Long[];
    float?: readonly number[];
    double?: readonly number[];
    bool?: readonly boolean[];
    string?: readonly string[];
    bytes?: readonly Uint8Array[];
    enum?: readonly test.Enum[];
    selfMessage?: readonly test.IRepeatedMessage[];
    otherMessage?: readonly test.IOtherMessage[];
  }

  export class ParentMessage extends ProtobufMessage<IParentMessage> {
    private constructor();

    public get childMessage(): test.ParentMessage.ChildMessage | undefined;
    public set childMessage(value: test.ParentMessage.ChildMessage | undefined);

    public get childEnum(): test.ParentMessage.ChildEnum;
    public set childEnum(value: test.ParentMessage.ChildEnum);

    /**
     * Creates a new ParentMessage from properties
     * Returns a clone if a ParentMessage instance is provided
     */
    public static create(arena: IArena, properties?: ParentMessage | IParentMessage): ParentMessage;
    /** Decode a buffer into a ParentMessage */
    public static decode(arena: IArena, buffer: Uint8Array): ParentMessage;
    /** Asynchronously decode a buffer into a ParentMessage */
    public static decodeAsync(arena: IArena, buffer: Uint8Array): Promise<ParentMessage>;
    /**
     * Encodes the provided ParentMessage into a buffer.
     * Calls encode() if an instance is provided, otherwise creates a new message with the given properties then calls encode() on it
     */
    public static encode(value: ParentMessage | IParentMessage): Uint8Array;
    /**
     * Asynchronously encodes the provided ParentMessage into a buffer.
     * Calls encodeAsync() if an instance is provided, otherwise creates a new message with the given properties then calls encode() on it
     */
    public static encodeAsync(value: ParentMessage | IParentMessage): Promise<Uint8Array>;
    /**
     * Asynchronously decode a JSON string into a ParentMessage.
     * This is discouraged and should be used as a debug option only.
     */
    public static decodeDebugJSONAsync(arena: IArena, json: string): Promise<ParentMessage>;
  }

  /** Interface for creating ParentMessage instances */
  export interface IParentMessage {
    childMessage?: test.ParentMessage.IChildMessage;
    childEnum?: test.ParentMessage.ChildEnum;
  }

  export namespace ParentMessage {
    /** Comment for child enum */
    export const enum ChildEnum {
      /** Comment for value 0 */
      VALUE_0 = 0,
      /** Comment for value 1 */
      VALUE_1 = 1,
      /** Unrecognized value */
      $UNRECOGNIZED_VALUE = 0xffffffffff
    }

    export class ChildMessage extends ProtobufMessage<IChildMessage> {
      private constructor();

      public get value(): string;
      public set value(value: string);

      /**
       * Creates a new ChildMessage from properties
       * Returns a clone if a ChildMessage instance is provided
       */
      public static create(arena: IArena, properties?: ChildMessage | IChildMessage): ChildMessage;
      /** Decode a buffer into a ChildMessage */
      public static decode(arena: IArena, buffer: Uint8Array): ChildMessage;
      /** Asynchronously decode a buffer into a ChildMessage */
      public static decodeAsync(arena: IArena, buffer: Uint8Array): Promise<ChildMessage>;
      /**
       * Encodes the provided ChildMessage into a buffer.
       * Calls encode() if an instance is provided, otherwise creates a new message with the given properties then calls encode() on it
       */
      public static encode(value: ChildMessage | IChildMessage): Uint8Array;
      /**
       * Asynchronously encodes the provided ChildMessage into a buffer.
       * Calls encodeAsync() if an instance is provided, otherwise creates a new message with the given properties then calls encode() on it
       */
      public static encodeAsync(value: ChildMessage | IChildMessage): Promise<Uint8Array>;
      /**
       * Asynchronously decode a JSON string into a ChildMessage.
       * This is discouraged and should be used as a debug option only.
       */
      public static decodeDebugJSONAsync(arena: IArena, json: string): Promise<ChildMessage>;
    }

    /** Interface for creating ChildMessage instances */
    export interface IChildMessage {
      value?: string;
    }
  }

  export class OneOfMessage extends ProtobufMessage<IOneOfMessage> {
    private constructor();

    public get string0(): string;
    public set string0(value: string);

    public get string1(): string;
    public set string1(value: string);

    public get message0(): test.OtherMessage | undefined;
    public set message0(value: test.OtherMessage | undefined);

    public get message1(): test.OtherMessage | undefined;
    public set message1(value: test.OtherMessage | undefined);

    public get bytes0(): Uint8Array;
    public set bytes0(value: Uint8Array);

    public get bytes1(): Uint8Array;
    public set bytes1(value: Uint8Array);

    /**
     * Creates a new OneOfMessage from properties
     * Returns a clone if a OneOfMessage instance is provided
     */
    public static create(arena: IArena, properties?: OneOfMessage | IOneOfMessage): OneOfMessage;
    /** Decode a buffer into a OneOfMessage */
    public static decode(arena: IArena, buffer: Uint8Array): OneOfMessage;
    /** Asynchronously decode a buffer into a OneOfMessage */
    public static decodeAsync(arena: IArena, buffer: Uint8Array): Promise<OneOfMessage>;
    /**
     * Encodes the provided OneOfMessage into a buffer.
     * Calls encode() if an instance is provided, otherwise creates a new message with the given properties then calls encode() on it
     */
    public static encode(value: OneOfMessage | IOneOfMessage): Uint8Array;
    /**
     * Asynchronously encodes the provided OneOfMessage into a buffer.
     * Calls encodeAsync() if an instance is provided, otherwise creates a new message with the given properties then calls encode() on it
     */
    public static encodeAsync(value: OneOfMessage | IOneOfMessage): Promise<Uint8Array>;
    /**
     * Asynchronously decode a JSON string into a OneOfMessage.
     * This is discouraged and should be used as a debug option only.
     */
    public static decodeDebugJSONAsync(arena: IArena, json: string): Promise<OneOfMessage>;
  }

  /** Interface for creating OneOfMessage instances */
  export interface IOneOfMessage {
    string0?: string;
    string1?: string;
    message0?: test.IOtherMessage;
    message1?: test.IOtherMessage;
    bytes0?: Uint8Array;
    bytes1?: Uint8Array;
  }

  export class OldMessage extends ProtobufMessage<IOldMessage> {
    private constructor();

    public get oldValue(): string;
    public set oldValue(value: string);

    /**
     * Creates a new OldMessage from properties
     * Returns a clone if a OldMessage instance is provided
     */
    public static create(arena: IArena, properties?: OldMessage | IOldMessage): OldMessage;
    /** Decode a buffer into a OldMessage */
    public static decode(arena: IArena, buffer: Uint8Array): OldMessage;
    /** Asynchronously decode a buffer into a OldMessage */
    public static decodeAsync(arena: IArena, buffer: Uint8Array): Promise<OldMessage>;
    /**
     * Encodes the provided OldMessage into a buffer.
     * Calls encode() if an instance is provided, otherwise creates a new message with the given properties then calls encode() on it
     */
    public static encode(value: OldMessage | IOldMessage): Uint8Array;
    /**
     * Asynchronously encodes the provided OldMessage into a buffer.
     * Calls encodeAsync() if an instance is provided, otherwise creates a new message with the given properties then calls encode() on it
     */
    public static encodeAsync(value: OldMessage | IOldMessage): Promise<Uint8Array>;
    /**
     * Asynchronously decode a JSON string into a OldMessage.
     * This is discouraged and should be used as a debug option only.
     */
    public static decodeDebugJSONAsync(arena: IArena, json: string): Promise<OldMessage>;
  }

  /** Interface for creating OldMessage instances */
  export interface IOldMessage {
    oldValue?: string;
  }

  export class NewMessage extends ProtobufMessage<INewMessage> {
    private constructor();

    public get oldValue(): string;
    public set oldValue(value: string);

    public get newValue(): string;
    public set newValue(value: string);

    /**
     * Creates a new NewMessage from properties
     * Returns a clone if a NewMessage instance is provided
     */
    public static create(arena: IArena, properties?: NewMessage | INewMessage): NewMessage;
    /** Decode a buffer into a NewMessage */
    public static decode(arena: IArena, buffer: Uint8Array): NewMessage;
    /** Asynchronously decode a buffer into a NewMessage */
    public static decodeAsync(arena: IArena, buffer: Uint8Array): Promise<NewMessage>;
    /**
     * Encodes the provided NewMessage into a buffer.
     * Calls encode() if an instance is provided, otherwise creates a new message with the given properties then calls encode() on it
     */
    public static encode(value: NewMessage | INewMessage): Uint8Array;
    /**
     * Asynchronously encodes the provided NewMessage into a buffer.
     * Calls encodeAsync() if an instance is provided, otherwise creates a new message with the given properties then calls encode() on it
     */
    public static encodeAsync(value: NewMessage | INewMessage): Promise<Uint8Array>;
    /**
     * Asynchronously decode a JSON string into a NewMessage.
     * This is discouraged and should be used as a debug option only.
     */
    public static decodeDebugJSONAsync(arena: IArena, json: string): Promise<NewMessage>;
  }

  /** Interface for creating NewMessage instances */
  export interface INewMessage {
    oldValue?: string;
    newValue?: string;
  }

  export class OldEnumMessage extends ProtobufMessage<IOldEnumMessage> {
    private constructor();

    public get value(): test.OldEnumMessage.OldEnum;
    public set value(value: test.OldEnumMessage.OldEnum);

    public get repeatedValue(): readonly test.OldEnumMessage.OldEnum[];
    public set repeatedValue(value: readonly test.OldEnumMessage.OldEnum[]);

    public get mappedValue(): ReadonlyMap<string, test.OldEnumMessage.OldEnum>;
    public set mappedValue(value: ReadonlyMap<string, test.OldEnumMessage.OldEnum>);

    /**
     * Creates a new OldEnumMessage from properties
     * Returns a clone if a OldEnumMessage instance is provided
     */
    public static create(arena: IArena, properties?: OldEnumMessage | IOldEnumMessage): OldEnumMessage;
    /** Decode a buffer into a OldEnumMessage */
    public static decode(arena: IArena, buffer: Uint8Array): OldEnumMessage;
    /** Asynchronously decode a buffer into a OldEnumMessage */
    public static decodeAsync(arena: IArena, buffer: Uint8Array): Promise<OldEnumMessage>;
    /**
     * Encodes the provided OldEnumMessage into a buffer.
     * Calls encode() if an instance is provided, otherwise creates a new message with the given properties then calls encode() on it
     */
    public static encode(value: OldEnumMessage | IOldEnumMessage): Uint8Array;
    /**
     * Asynchronously encodes the provided OldEnumMessage into a buffer.
     * Calls encodeAsync() if an instance is provided, otherwise creates a new message with the given properties then calls encode() on it
     */
    public static encodeAsync(value: OldEnumMessage | IOldEnumMessage): Promise<Uint8Array>;
    /**
     * Asynchronously decode a JSON string into a OldEnumMessage.
     * This is discouraged and should be used as a debug option only.
     */
    public static decodeDebugJSONAsync(arena: IArena, json: string): Promise<OldEnumMessage>;
  }

  /** Interface for creating OldEnumMessage instances */
  export interface IOldEnumMessage {
    value?: test.OldEnumMessage.OldEnum;
    repeatedValue?: readonly test.OldEnumMessage.OldEnum[];
    mappedValue?: ReadonlyMap<string, test.OldEnumMessage.OldEnum>;
  }

  export namespace OldEnumMessage {
    export const enum OldEnum {
      VALUE_0 = 0,
      VALUE_1 = 1,
      /** Unrecognized value */
      $UNRECOGNIZED_VALUE = 0xffffffffff
    }
  }

  export class NewEnumMessage extends ProtobufMessage<INewEnumMessage> {
    private constructor();

    public get value(): test.NewEnumMessage.NewEnum;
    public set value(value: test.NewEnumMessage.NewEnum);

    public get repeatedValue(): readonly test.NewEnumMessage.NewEnum[];
    public set repeatedValue(value: readonly test.NewEnumMessage.NewEnum[]);

    public get mappedValue(): ReadonlyMap<string, test.NewEnumMessage.NewEnum>;
    public set mappedValue(value: ReadonlyMap<string, test.NewEnumMessage.NewEnum>);

    /**
     * Creates a new NewEnumMessage from properties
     * Returns a clone if a NewEnumMessage instance is provided
     */
    public static create(arena: IArena, properties?: NewEnumMessage | INewEnumMessage): NewEnumMessage;
    /** Decode a buffer into a NewEnumMessage */
    public static decode(arena: IArena, buffer: Uint8Array): NewEnumMessage;
    /** Asynchronously decode a buffer into a NewEnumMessage */
    public static decodeAsync(arena: IArena, buffer: Uint8Array): Promise<NewEnumMessage>;
    /**
     * Encodes the provided NewEnumMessage into a buffer.
     * Calls encode() if an instance is provided, otherwise creates a new message with the given properties then calls encode() on it
     */
    public static encode(value: NewEnumMessage | INewEnumMessage): Uint8Array;
    /**
     * Asynchronously encodes the provided NewEnumMessage into a buffer.
     * Calls encodeAsync() if an instance is provided, otherwise creates a new message with the given properties then calls encode() on it
     */
    public static encodeAsync(value: NewEnumMessage | INewEnumMessage): Promise<Uint8Array>;
    /**
     * Asynchronously decode a JSON string into a NewEnumMessage.
     * This is discouraged and should be used as a debug option only.
     */
    public static decodeDebugJSONAsync(arena: IArena, json: string): Promise<NewEnumMessage>;
  }

  /** Interface for creating NewEnumMessage instances */
  export interface INewEnumMessage {
    value?: test.NewEnumMessage.NewEnum;
    repeatedValue?: readonly test.NewEnumMessage.NewEnum[];
    mappedValue?: ReadonlyMap<string, test.NewEnumMessage.NewEnum>;
  }

  export namespace NewEnumMessage {
    export const enum NewEnum {
      VALUE_0 = 0,
      VALUE_1 = 1,
      VALUE_2 = 200,
      VALUE_3 = 300,
      /** Unrecognized value */
      $UNRECOGNIZED_VALUE = 0xffffffffff
    }
  }

  export class MapMessage extends ProtobufMessage<IMapMessage> {
    private constructor();

    public get stringToString(): ReadonlyMap<string, string>;
    public set stringToString(value: ReadonlyMap<string, string>);

    public get stringToNumber(): ReadonlyMap<string, number>;
    public set stringToNumber(value: ReadonlyMap<string, number>);

    public get stringToSignedLong(): ReadonlyMap<string, Long>;
    public set stringToSignedLong(value: ReadonlyMap<string, Long>);

    public get stringToUnsignedLong(): ReadonlyMap<string, Long>;
    public set stringToUnsignedLong(value: ReadonlyMap<string, Long>);

    public get stringToDouble(): ReadonlyMap<string, number>;
    public set stringToDouble(value: ReadonlyMap<string, number>);

    public get stringToMessage(): ReadonlyMap<string, test.OtherMessage>;
    public set stringToMessage(value: ReadonlyMap<string, test.OtherMessage>);

    public get intToString(): ReadonlyMap<number, string>;
    public set intToString(value: ReadonlyMap<number, string>);

    public get longToString(): ReadonlyMap<Long, string>;
    public set longToString(value: ReadonlyMap<Long, string>);

    /**
     * Creates a new MapMessage from properties
     * Returns a clone if a MapMessage instance is provided
     */
    public static create(arena: IArena, properties?: MapMessage | IMapMessage): MapMessage;
    /** Decode a buffer into a MapMessage */
    public static decode(arena: IArena, buffer: Uint8Array): MapMessage;
    /** Asynchronously decode a buffer into a MapMessage */
    public static decodeAsync(arena: IArena, buffer: Uint8Array): Promise<MapMessage>;
    /**
     * Encodes the provided MapMessage into a buffer.
     * Calls encode() if an instance is provided, otherwise creates a new message with the given properties then calls encode() on it
     */
    public static encode(value: MapMessage | IMapMessage): Uint8Array;
    /**
     * Asynchronously encodes the provided MapMessage into a buffer.
     * Calls encodeAsync() if an instance is provided, otherwise creates a new message with the given properties then calls encode() on it
     */
    public static encodeAsync(value: MapMessage | IMapMessage): Promise<Uint8Array>;
    /**
     * Asynchronously decode a JSON string into a MapMessage.
     * This is discouraged and should be used as a debug option only.
     */
    public static decodeDebugJSONAsync(arena: IArena, json: string): Promise<MapMessage>;
  }

  /** Interface for creating MapMessage instances */
  export interface IMapMessage {
    stringToString?: ReadonlyMap<string, string>;
    stringToNumber?: ReadonlyMap<string, number>;
    stringToSignedLong?: ReadonlyMap<string, Long>;
    stringToUnsignedLong?: ReadonlyMap<string, Long>;
    stringToDouble?: ReadonlyMap<string, number>;
    stringToMessage?: ReadonlyMap<string, test.IOtherMessage>;
    intToString?: ReadonlyMap<number, string>;
    longToString?: ReadonlyMap<Long, string>;
  }

  export class ExternalMessages extends ProtobufMessage<IExternalMessages> {
    private constructor();

    public get otherMessage(): test3.Message3 | undefined;
    public set otherMessage(value: test3.Message3 | undefined);

    /**
     * Creates a new ExternalMessages from properties
     * Returns a clone if a ExternalMessages instance is provided
     */
    public static create(arena: IArena, properties?: ExternalMessages | IExternalMessages): ExternalMessages;
    /** Decode a buffer into a ExternalMessages */
    public static decode(arena: IArena, buffer: Uint8Array): ExternalMessages;
    /** Asynchronously decode a buffer into a ExternalMessages */
    public static decodeAsync(arena: IArena, buffer: Uint8Array): Promise<ExternalMessages>;
    /**
     * Encodes the provided ExternalMessages into a buffer.
     * Calls encode() if an instance is provided, otherwise creates a new message with the given properties then calls encode() on it
     */
    public static encode(value: ExternalMessages | IExternalMessages): Uint8Array;
    /**
     * Asynchronously encodes the provided ExternalMessages into a buffer.
     * Calls encodeAsync() if an instance is provided, otherwise creates a new message with the given properties then calls encode() on it
     */
    public static encodeAsync(value: ExternalMessages | IExternalMessages): Promise<Uint8Array>;
    /**
     * Asynchronously decode a JSON string into a ExternalMessages.
     * This is discouraged and should be used as a debug option only.
     */
    public static decodeDebugJSONAsync(arena: IArena, json: string): Promise<ExternalMessages>;
  }

  /** Interface for creating ExternalMessages instances */
  export interface IExternalMessages {
    otherMessage?: test3.IMessage3;
  }
}
import __test__ = test;

export namespace test3 {
  export class Message3 extends ProtobufMessage<IMessage3> {
    private constructor();

    public get value(): string;
    public set value(value: string);

    /**
     * Creates a new Message3 from properties
     * Returns a clone if a Message3 instance is provided
     */
    public static create(arena: IArena, properties?: Message3 | IMessage3): Message3;
    /** Decode a buffer into a Message3 */
    public static decode(arena: IArena, buffer: Uint8Array): Message3;
    /** Asynchronously decode a buffer into a Message3 */
    public static decodeAsync(arena: IArena, buffer: Uint8Array): Promise<Message3>;
    /**
     * Encodes the provided Message3 into a buffer.
     * Calls encode() if an instance is provided, otherwise creates a new message with the given properties then calls encode() on it
     */
    public static encode(value: Message3 | IMessage3): Uint8Array;
    /**
     * Asynchronously encodes the provided Message3 into a buffer.
     * Calls encodeAsync() if an instance is provided, otherwise creates a new message with the given properties then calls encode() on it
     */
    public static encodeAsync(value: Message3 | IMessage3): Promise<Uint8Array>;
    /**
     * Asynchronously decode a JSON string into a Message3.
     * This is discouraged and should be used as a debug option only.
     */
    public static decodeDebugJSONAsync(arena: IArena, json: string): Promise<Message3>;
  }

  /** Interface for creating Message3 instances */
  export interface IMessage3 {
    value?: string;
  }
}
import __test3__ = test3;

export namespace test2 {
  export class Message2 extends ProtobufMessage<IMessage2> {
    private constructor();

    public get value(): string;
    public set value(value: string);

    /**
     * Creates a new Message2 from properties
     * Returns a clone if a Message2 instance is provided
     */
    public static create(arena: IArena, properties?: Message2 | IMessage2): Message2;
    /** Decode a buffer into a Message2 */
    public static decode(arena: IArena, buffer: Uint8Array): Message2;
    /** Asynchronously decode a buffer into a Message2 */
    public static decodeAsync(arena: IArena, buffer: Uint8Array): Promise<Message2>;
    /**
     * Encodes the provided Message2 into a buffer.
     * Calls encode() if an instance is provided, otherwise creates a new message with the given properties then calls encode() on it
     */
    public static encode(value: Message2 | IMessage2): Uint8Array;
    /**
     * Asynchronously encodes the provided Message2 into a buffer.
     * Calls encodeAsync() if an instance is provided, otherwise creates a new message with the given properties then calls encode() on it
     */
    public static encodeAsync(value: Message2 | IMessage2): Promise<Uint8Array>;
    /**
     * Asynchronously decode a JSON string into a Message2.
     * This is discouraged and should be used as a debug option only.
     */
    public static decodeDebugJSONAsync(arena: IArena, json: string): Promise<Message2>;
  }

  /** Interface for creating Message2 instances */
  export interface IMessage2 {
    value?: string;
  }
}
import __test2__ = test2;

export namespace package_with_underscores {
  export const enum Enum_With_Underscores {
    ENUM_VALUE_0 = 0,
    ENUM_VALUE_1 = 1,
    E2NUM_VALUE_WITH_NUMBER = 2,
    /** Unrecognized value */
    $UNRECOGNIZED_VALUE = 0xffffffffff
  }

  export class Message_With_Underscores extends ProtobufMessage<IMessage_With_Underscores> {
    private constructor();

    public get fieldUnderscore(): number;
    public set fieldUnderscore(value: number);

    public get fieldUnderscoreAgain(): number;
    public set fieldUnderscoreAgain(value: number);

    public get enumValue(): package_with_underscores.Enum_With_Underscores;
    public set enumValue(value: package_with_underscores.Enum_With_Underscores);

    public get messageValue(): package_with_underscores.Message_With_Underscores | undefined;
    public set messageValue(value: package_with_underscores.Message_With_Underscores | undefined);

    /**
     * Creates a new Message_With_Underscores from properties
     * Returns a clone if a Message_With_Underscores instance is provided
     */
    public static create(arena: IArena, properties?: Message_With_Underscores | IMessage_With_Underscores): Message_With_Underscores;
    /** Decode a buffer into a Message_With_Underscores */
    public static decode(arena: IArena, buffer: Uint8Array): Message_With_Underscores;
    /** Asynchronously decode a buffer into a Message_With_Underscores */
    public static decodeAsync(arena: IArena, buffer: Uint8Array): Promise<Message_With_Underscores>;
    /**
     * Encodes the provided Message_With_Underscores into a buffer.
     * Calls encode() if an instance is provided, otherwise creates a new message with the given properties then calls encode() on it
     */
    public static encode(value: Message_With_Underscores | IMessage_With_Underscores): Uint8Array;
    /**
     * Asynchronously encodes the provided Message_With_Underscores into a buffer.
     * Calls encodeAsync() if an instance is provided, otherwise creates a new message with the given properties then calls encode() on it
     */
    public static encodeAsync(value: Message_With_Underscores | IMessage_With_Underscores): Promise<Uint8Array>;
    /**
     * Asynchronously decode a JSON string into a Message_With_Underscores.
     * This is discouraged and should be used as a debug option only.
     */
    public static decodeDebugJSONAsync(arena: IArena, json: string): Promise<Message_With_Underscores>;
  }

  /** Interface for creating Message_With_Underscores instances */
  export interface IMessage_With_Underscores {
    fieldUnderscore?: number;
    fieldUnderscoreAgain?: number;
    enumValue?: package_with_underscores.Enum_With_Underscores;
    messageValue?: package_with_underscores.IMessage_With_Underscores;
  }

  export class M3ssage1WithNumb3r2 extends ProtobufMessage<IM3ssage1WithNumb3r2> {
    private constructor();

    public get fie1ld(): number;
    public set fie1ld(value: number);

    public get field2(): number;
    public set field2(value: number);

    public get field3(): number;
    public set field3(value: number);

    public get a4Fiel4d(): number;
    public set a4Fiel4d(value: number);

    public get a5aFiel5d(): number;
    public set a5aFiel5d(value: number);

    public get enum(): package_with_underscores.Enum_With_Underscores;
    public set enum(value: package_with_underscores.Enum_With_Underscores);

    /**
     * Creates a new M3ssage1WithNumb3r2 from properties
     * Returns a clone if a M3ssage1WithNumb3r2 instance is provided
     */
    public static create(arena: IArena, properties?: M3ssage1WithNumb3r2 | IM3ssage1WithNumb3r2): M3ssage1WithNumb3r2;
    /** Decode a buffer into a M3ssage1WithNumb3r2 */
    public static decode(arena: IArena, buffer: Uint8Array): M3ssage1WithNumb3r2;
    /** Asynchronously decode a buffer into a M3ssage1WithNumb3r2 */
    public static decodeAsync(arena: IArena, buffer: Uint8Array): Promise<M3ssage1WithNumb3r2>;
    /**
     * Encodes the provided M3ssage1WithNumb3r2 into a buffer.
     * Calls encode() if an instance is provided, otherwise creates a new message with the given properties then calls encode() on it
     */
    public static encode(value: M3ssage1WithNumb3r2 | IM3ssage1WithNumb3r2): Uint8Array;
    /**
     * Asynchronously encodes the provided M3ssage1WithNumb3r2 into a buffer.
     * Calls encodeAsync() if an instance is provided, otherwise creates a new message with the given properties then calls encode() on it
     */
    public static encodeAsync(value: M3ssage1WithNumb3r2 | IM3ssage1WithNumb3r2): Promise<Uint8Array>;
    /**
     * Asynchronously decode a JSON string into a M3ssage1WithNumb3r2.
     * This is discouraged and should be used as a debug option only.
     */
    public static decodeDebugJSONAsync(arena: IArena, json: string): Promise<M3ssage1WithNumb3r2>;
  }

  /** Interface for creating M3ssage1WithNumb3r2 instances */
  export interface IM3ssage1WithNumb3r2 {
    fie1ld?: number;
    field2?: number;
    field3?: number;
    a4Fiel4d?: number;
    a5aFiel5d?: number;
    enum?: package_with_underscores.Enum_With_Underscores;
  }
}
import __package_with_underscores__ = package_with_underscores;
