// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: valdi.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_valdi_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_valdi_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3020000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3020000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/message_lite.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_util.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_valdi_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_valdi_2eproto {
  static const uint32_t offsets[];
};
namespace Valdi {
class CSSRuleIndex;
struct CSSRuleIndexDefaultTypeInternal;
extern CSSRuleIndexDefaultTypeInternal _CSSRuleIndex_default_instance_;
class CSSRuleIndex_AttributeRule;
struct CSSRuleIndex_AttributeRuleDefaultTypeInternal;
extern CSSRuleIndex_AttributeRuleDefaultTypeInternal _CSSRuleIndex_AttributeRule_default_instance_;
class CSSRuleIndex_NthChildRule;
struct CSSRuleIndex_NthChildRuleDefaultTypeInternal;
extern CSSRuleIndex_NthChildRuleDefaultTypeInternal _CSSRuleIndex_NthChildRule_default_instance_;
class ClientAwakeMessage;
struct ClientAwakeMessageDefaultTypeInternal;
extern ClientAwakeMessageDefaultTypeInternal _ClientAwakeMessage_default_instance_;
class DaemonAwakeMessage;
struct DaemonAwakeMessageDefaultTypeInternal;
extern DaemonAwakeMessageDefaultTypeInternal _DaemonAwakeMessage_default_instance_;
class DaemonServiceDiscoveryPayload;
struct DaemonServiceDiscoveryPayloadDefaultTypeInternal;
extern DaemonServiceDiscoveryPayloadDefaultTypeInternal _DaemonServiceDiscoveryPayload_default_instance_;
class DownloadableModuleArtifact;
struct DownloadableModuleArtifactDefaultTypeInternal;
extern DownloadableModuleArtifactDefaultTypeInternal _DownloadableModuleArtifact_default_instance_;
class DownloadableModuleAssets;
struct DownloadableModuleAssetsDefaultTypeInternal;
extern DownloadableModuleAssetsDefaultTypeInternal _DownloadableModuleAssets_default_instance_;
class DownloadableModuleManifest;
struct DownloadableModuleManifestDefaultTypeInternal;
extern DownloadableModuleManifestDefaultTypeInternal _DownloadableModuleManifest_default_instance_;
class NamedStyleNode;
struct NamedStyleNodeDefaultTypeInternal;
extern NamedStyleNodeDefaultTypeInternal _NamedStyleNode_default_instance_;
class NodeAttribute;
struct NodeAttributeDefaultTypeInternal;
extern NodeAttributeDefaultTypeInternal _NodeAttribute_default_instance_;
class StyleDeclaration;
struct StyleDeclarationDefaultTypeInternal;
extern StyleDeclarationDefaultTypeInternal _StyleDeclaration_default_instance_;
class StyleNode;
struct StyleNodeDefaultTypeInternal;
extern StyleNodeDefaultTypeInternal _StyleNode_default_instance_;
class TsnConfig;
struct TsnConfigDefaultTypeInternal;
extern TsnConfigDefaultTypeInternal _TsnConfig_default_instance_;
}  // namespace Valdi
PROTOBUF_NAMESPACE_OPEN
template<> ::Valdi::CSSRuleIndex* Arena::CreateMaybeMessage<::Valdi::CSSRuleIndex>(Arena*);
template<> ::Valdi::CSSRuleIndex_AttributeRule* Arena::CreateMaybeMessage<::Valdi::CSSRuleIndex_AttributeRule>(Arena*);
template<> ::Valdi::CSSRuleIndex_NthChildRule* Arena::CreateMaybeMessage<::Valdi::CSSRuleIndex_NthChildRule>(Arena*);
template<> ::Valdi::ClientAwakeMessage* Arena::CreateMaybeMessage<::Valdi::ClientAwakeMessage>(Arena*);
template<> ::Valdi::DaemonAwakeMessage* Arena::CreateMaybeMessage<::Valdi::DaemonAwakeMessage>(Arena*);
template<> ::Valdi::DaemonServiceDiscoveryPayload* Arena::CreateMaybeMessage<::Valdi::DaemonServiceDiscoveryPayload>(Arena*);
template<> ::Valdi::DownloadableModuleArtifact* Arena::CreateMaybeMessage<::Valdi::DownloadableModuleArtifact>(Arena*);
template<> ::Valdi::DownloadableModuleAssets* Arena::CreateMaybeMessage<::Valdi::DownloadableModuleAssets>(Arena*);
template<> ::Valdi::DownloadableModuleManifest* Arena::CreateMaybeMessage<::Valdi::DownloadableModuleManifest>(Arena*);
template<> ::Valdi::NamedStyleNode* Arena::CreateMaybeMessage<::Valdi::NamedStyleNode>(Arena*);
template<> ::Valdi::NodeAttribute* Arena::CreateMaybeMessage<::Valdi::NodeAttribute>(Arena*);
template<> ::Valdi::StyleDeclaration* Arena::CreateMaybeMessage<::Valdi::StyleDeclaration>(Arena*);
template<> ::Valdi::StyleNode* Arena::CreateMaybeMessage<::Valdi::StyleNode>(Arena*);
template<> ::Valdi::TsnConfig* Arena::CreateMaybeMessage<::Valdi::TsnConfig>(Arena*);
PROTOBUF_NAMESPACE_CLOSE
namespace Valdi {

enum NodeAttribute_Type : int {
  NodeAttribute_Type_NODE_ATTRIBUTE_TYPE_STRING = 0,
  NodeAttribute_Type_NODE_ATTRIBUTE_TYPE_INT = 1,
  NodeAttribute_Type_NODE_ATTRIBUTE_TYPE_DOUBLE = 2,
  NodeAttribute_Type_NodeAttribute_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  NodeAttribute_Type_NodeAttribute_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool NodeAttribute_Type_IsValid(int value);
constexpr NodeAttribute_Type NodeAttribute_Type_Type_MIN = NodeAttribute_Type_NODE_ATTRIBUTE_TYPE_STRING;
constexpr NodeAttribute_Type NodeAttribute_Type_Type_MAX = NodeAttribute_Type_NODE_ATTRIBUTE_TYPE_DOUBLE;
constexpr int NodeAttribute_Type_Type_ARRAYSIZE = NodeAttribute_Type_Type_MAX + 1;

const std::string& NodeAttribute_Type_Name(NodeAttribute_Type value);
template<typename T>
inline const std::string& NodeAttribute_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, NodeAttribute_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function NodeAttribute_Type_Name.");
  return NodeAttribute_Type_Name(static_cast<NodeAttribute_Type>(enum_t_value));
}
bool NodeAttribute_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NodeAttribute_Type* value);
enum CSSRuleIndex_AttributeRule_Type : int {
  CSSRuleIndex_AttributeRule_Type_EQUALS = 0,
  CSSRuleIndex_AttributeRule_Type_CONTAINS_WORD = 1,
  CSSRuleIndex_AttributeRule_Type_STARTS_WITH_WORD = 2,
  CSSRuleIndex_AttributeRule_Type_STARTS_WITH_SUBSTRING = 3,
  CSSRuleIndex_AttributeRule_Type_ENDS_WITH_SUBSTRING = 4,
  CSSRuleIndex_AttributeRule_Type_CONTAINS_SUBSTRING = 5,
  CSSRuleIndex_AttributeRule_Type_HAS_ATTRIBUTE = 6,
  CSSRuleIndex_AttributeRule_Type_CSSRuleIndex_AttributeRule_Type_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::min(),
  CSSRuleIndex_AttributeRule_Type_CSSRuleIndex_AttributeRule_Type_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<int32_t>::max()
};
bool CSSRuleIndex_AttributeRule_Type_IsValid(int value);
constexpr CSSRuleIndex_AttributeRule_Type CSSRuleIndex_AttributeRule_Type_Type_MIN = CSSRuleIndex_AttributeRule_Type_EQUALS;
constexpr CSSRuleIndex_AttributeRule_Type CSSRuleIndex_AttributeRule_Type_Type_MAX = CSSRuleIndex_AttributeRule_Type_HAS_ATTRIBUTE;
constexpr int CSSRuleIndex_AttributeRule_Type_Type_ARRAYSIZE = CSSRuleIndex_AttributeRule_Type_Type_MAX + 1;

const std::string& CSSRuleIndex_AttributeRule_Type_Name(CSSRuleIndex_AttributeRule_Type value);
template<typename T>
inline const std::string& CSSRuleIndex_AttributeRule_Type_Name(T enum_t_value) {
  static_assert(::std::is_same<T, CSSRuleIndex_AttributeRule_Type>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function CSSRuleIndex_AttributeRule_Type_Name.");
  return CSSRuleIndex_AttributeRule_Type_Name(static_cast<CSSRuleIndex_AttributeRule_Type>(enum_t_value));
}
bool CSSRuleIndex_AttributeRule_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CSSRuleIndex_AttributeRule_Type* value);
// ===================================================================

class NodeAttribute final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Valdi.NodeAttribute) */ {
 public:
  inline NodeAttribute() : NodeAttribute(nullptr) {}
  ~NodeAttribute() override;
  explicit PROTOBUF_CONSTEXPR NodeAttribute(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NodeAttribute(const NodeAttribute& from);
  NodeAttribute(NodeAttribute&& from) noexcept
    : NodeAttribute() {
    *this = ::std::move(from);
  }

  inline NodeAttribute& operator=(const NodeAttribute& from) {
    CopyFrom(from);
    return *this;
  }
  inline NodeAttribute& operator=(NodeAttribute&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const NodeAttribute& default_instance() {
    return *internal_default_instance();
  }
  static inline const NodeAttribute* internal_default_instance() {
    return reinterpret_cast<const NodeAttribute*>(
               &_NodeAttribute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  friend void swap(NodeAttribute& a, NodeAttribute& b) {
    a.Swap(&b);
  }
  inline void Swap(NodeAttribute* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NodeAttribute* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NodeAttribute* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NodeAttribute>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const NodeAttribute& from);
  void MergeFrom(const NodeAttribute& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NodeAttribute* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Valdi.NodeAttribute";
  }
  protected:
  explicit NodeAttribute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef NodeAttribute_Type Type;
  static constexpr Type NODE_ATTRIBUTE_TYPE_STRING =
    NodeAttribute_Type_NODE_ATTRIBUTE_TYPE_STRING;
  static constexpr Type NODE_ATTRIBUTE_TYPE_INT =
    NodeAttribute_Type_NODE_ATTRIBUTE_TYPE_INT;
  static constexpr Type NODE_ATTRIBUTE_TYPE_DOUBLE =
    NodeAttribute_Type_NODE_ATTRIBUTE_TYPE_DOUBLE;
  static inline bool Type_IsValid(int value) {
    return NodeAttribute_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    NodeAttribute_Type_Type_MIN;
  static constexpr Type Type_MAX =
    NodeAttribute_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    NodeAttribute_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return NodeAttribute_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return NodeAttribute_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 2,
    kStrValueFieldNumber = 3,
    kIntValueFieldNumber = 4,
    kDoubleValueFieldNumber = 5,
    kTypeFieldNumber = 1,
  };
  // string name = 2;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // string str_value = 3;
  void clear_str_value();
  const std::string& str_value() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_str_value(ArgT0&& arg0, ArgT... args);
  std::string* mutable_str_value();
  PROTOBUF_NODISCARD std::string* release_str_value();
  void set_allocated_str_value(std::string* str_value);
  private:
  const std::string& _internal_str_value() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_str_value(const std::string& value);
  std::string* _internal_mutable_str_value();
  public:

  // int64 int_value = 4;
  void clear_int_value();
  int64_t int_value() const;
  void set_int_value(int64_t value);
  private:
  int64_t _internal_int_value() const;
  void _internal_set_int_value(int64_t value);
  public:

  // double double_value = 5;
  void clear_double_value();
  double double_value() const;
  void set_double_value(double value);
  private:
  double _internal_double_value() const;
  void _internal_set_double_value(double value);
  public:

  // .Valdi.NodeAttribute.Type type = 1;
  void clear_type();
  ::Valdi::NodeAttribute_Type type() const;
  void set_type(::Valdi::NodeAttribute_Type value);
  private:
  ::Valdi::NodeAttribute_Type _internal_type() const;
  void _internal_set_type(::Valdi::NodeAttribute_Type value);
  public:

  // @@protoc_insertion_point(class_scope:Valdi.NodeAttribute)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr str_value_;
  int64_t int_value_;
  double double_value_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_valdi_2eproto;
};
// -------------------------------------------------------------------

class DownloadableModuleArtifact final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Valdi.DownloadableModuleArtifact) */ {
 public:
  inline DownloadableModuleArtifact() : DownloadableModuleArtifact(nullptr) {}
  ~DownloadableModuleArtifact() override;
  explicit PROTOBUF_CONSTEXPR DownloadableModuleArtifact(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DownloadableModuleArtifact(const DownloadableModuleArtifact& from);
  DownloadableModuleArtifact(DownloadableModuleArtifact&& from) noexcept
    : DownloadableModuleArtifact() {
    *this = ::std::move(from);
  }

  inline DownloadableModuleArtifact& operator=(const DownloadableModuleArtifact& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadableModuleArtifact& operator=(DownloadableModuleArtifact&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DownloadableModuleArtifact& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownloadableModuleArtifact* internal_default_instance() {
    return reinterpret_cast<const DownloadableModuleArtifact*>(
               &_DownloadableModuleArtifact_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  friend void swap(DownloadableModuleArtifact& a, DownloadableModuleArtifact& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadableModuleArtifact* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadableModuleArtifact* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DownloadableModuleArtifact* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DownloadableModuleArtifact>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DownloadableModuleArtifact& from);
  void MergeFrom(const DownloadableModuleArtifact& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DownloadableModuleArtifact* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Valdi.DownloadableModuleArtifact";
  }
  protected:
  explicit DownloadableModuleArtifact(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kUrlFieldNumber = 1,
    kSha256DigestFieldNumber = 2,
  };
  // string url = 1;
  void clear_url();
  const std::string& url() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_url(ArgT0&& arg0, ArgT... args);
  std::string* mutable_url();
  PROTOBUF_NODISCARD std::string* release_url();
  void set_allocated_url(std::string* url);
  private:
  const std::string& _internal_url() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_url(const std::string& value);
  std::string* _internal_mutable_url();
  public:

  // bytes sha256Digest = 2;
  void clear_sha256digest();
  const std::string& sha256digest() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_sha256digest(ArgT0&& arg0, ArgT... args);
  std::string* mutable_sha256digest();
  PROTOBUF_NODISCARD std::string* release_sha256digest();
  void set_allocated_sha256digest(std::string* sha256digest);
  private:
  const std::string& _internal_sha256digest() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_sha256digest(const std::string& value);
  std::string* _internal_mutable_sha256digest();
  public:

  // @@protoc_insertion_point(class_scope:Valdi.DownloadableModuleArtifact)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr url_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr sha256digest_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_valdi_2eproto;
};
// -------------------------------------------------------------------

class DownloadableModuleAssets final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Valdi.DownloadableModuleAssets) */ {
 public:
  inline DownloadableModuleAssets() : DownloadableModuleAssets(nullptr) {}
  ~DownloadableModuleAssets() override;
  explicit PROTOBUF_CONSTEXPR DownloadableModuleAssets(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DownloadableModuleAssets(const DownloadableModuleAssets& from);
  DownloadableModuleAssets(DownloadableModuleAssets&& from) noexcept
    : DownloadableModuleAssets() {
    *this = ::std::move(from);
  }

  inline DownloadableModuleAssets& operator=(const DownloadableModuleAssets& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadableModuleAssets& operator=(DownloadableModuleAssets&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DownloadableModuleAssets& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownloadableModuleAssets* internal_default_instance() {
    return reinterpret_cast<const DownloadableModuleAssets*>(
               &_DownloadableModuleAssets_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  friend void swap(DownloadableModuleAssets& a, DownloadableModuleAssets& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadableModuleAssets* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadableModuleAssets* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DownloadableModuleAssets* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DownloadableModuleAssets>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DownloadableModuleAssets& from);
  void MergeFrom(const DownloadableModuleAssets& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DownloadableModuleAssets* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Valdi.DownloadableModuleAssets";
  }
  protected:
  explicit DownloadableModuleAssets(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kArtifactFieldNumber = 1,
    kDeviceDensityFieldNumber = 3,
  };
  // .Valdi.DownloadableModuleArtifact artifact = 1;
  bool has_artifact() const;
  private:
  bool _internal_has_artifact() const;
  public:
  void clear_artifact();
  const ::Valdi::DownloadableModuleArtifact& artifact() const;
  PROTOBUF_NODISCARD ::Valdi::DownloadableModuleArtifact* release_artifact();
  ::Valdi::DownloadableModuleArtifact* mutable_artifact();
  void set_allocated_artifact(::Valdi::DownloadableModuleArtifact* artifact);
  private:
  const ::Valdi::DownloadableModuleArtifact& _internal_artifact() const;
  ::Valdi::DownloadableModuleArtifact* _internal_mutable_artifact();
  public:
  void unsafe_arena_set_allocated_artifact(
      ::Valdi::DownloadableModuleArtifact* artifact);
  ::Valdi::DownloadableModuleArtifact* unsafe_arena_release_artifact();

  // double device_density = 3;
  void clear_device_density();
  double device_density() const;
  void set_device_density(double value);
  private:
  double _internal_device_density() const;
  void _internal_set_device_density(double value);
  public:

  // @@protoc_insertion_point(class_scope:Valdi.DownloadableModuleAssets)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Valdi::DownloadableModuleArtifact* artifact_;
  double device_density_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_valdi_2eproto;
};
// -------------------------------------------------------------------

class DownloadableModuleManifest final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Valdi.DownloadableModuleManifest) */ {
 public:
  inline DownloadableModuleManifest() : DownloadableModuleManifest(nullptr) {}
  ~DownloadableModuleManifest() override;
  explicit PROTOBUF_CONSTEXPR DownloadableModuleManifest(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DownloadableModuleManifest(const DownloadableModuleManifest& from);
  DownloadableModuleManifest(DownloadableModuleManifest&& from) noexcept
    : DownloadableModuleManifest() {
    *this = ::std::move(from);
  }

  inline DownloadableModuleManifest& operator=(const DownloadableModuleManifest& from) {
    CopyFrom(from);
    return *this;
  }
  inline DownloadableModuleManifest& operator=(DownloadableModuleManifest&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DownloadableModuleManifest& default_instance() {
    return *internal_default_instance();
  }
  static inline const DownloadableModuleManifest* internal_default_instance() {
    return reinterpret_cast<const DownloadableModuleManifest*>(
               &_DownloadableModuleManifest_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  friend void swap(DownloadableModuleManifest& a, DownloadableModuleManifest& b) {
    a.Swap(&b);
  }
  inline void Swap(DownloadableModuleManifest* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DownloadableModuleManifest* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DownloadableModuleManifest* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DownloadableModuleManifest>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DownloadableModuleManifest& from);
  void MergeFrom(const DownloadableModuleManifest& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DownloadableModuleManifest* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Valdi.DownloadableModuleManifest";
  }
  protected:
  explicit DownloadableModuleManifest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAssetsFieldNumber = 3,
    kDependenciesFieldNumber = 4,
    kNameFieldNumber = 1,
    kArtifactFieldNumber = 2,
    kHasLocalAssetsFieldNumber = 5,
  };
  // repeated .Valdi.DownloadableModuleAssets assets = 3;
  int assets_size() const;
  private:
  int _internal_assets_size() const;
  public:
  void clear_assets();
  ::Valdi::DownloadableModuleAssets* mutable_assets(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Valdi::DownloadableModuleAssets >*
      mutable_assets();
  private:
  const ::Valdi::DownloadableModuleAssets& _internal_assets(int index) const;
  ::Valdi::DownloadableModuleAssets* _internal_add_assets();
  public:
  const ::Valdi::DownloadableModuleAssets& assets(int index) const;
  ::Valdi::DownloadableModuleAssets* add_assets();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Valdi::DownloadableModuleAssets >&
      assets() const;

  // repeated string dependencies = 4;
  int dependencies_size() const;
  private:
  int _internal_dependencies_size() const;
  public:
  void clear_dependencies();
  const std::string& dependencies(int index) const;
  std::string* mutable_dependencies(int index);
  void set_dependencies(int index, const std::string& value);
  void set_dependencies(int index, std::string&& value);
  void set_dependencies(int index, const char* value);
  void set_dependencies(int index, const char* value, size_t size);
  std::string* add_dependencies();
  void add_dependencies(const std::string& value);
  void add_dependencies(std::string&& value);
  void add_dependencies(const char* value);
  void add_dependencies(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& dependencies() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_dependencies();
  private:
  const std::string& _internal_dependencies(int index) const;
  std::string* _internal_add_dependencies();
  public:

  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .Valdi.DownloadableModuleArtifact artifact = 2;
  bool has_artifact() const;
  private:
  bool _internal_has_artifact() const;
  public:
  void clear_artifact();
  const ::Valdi::DownloadableModuleArtifact& artifact() const;
  PROTOBUF_NODISCARD ::Valdi::DownloadableModuleArtifact* release_artifact();
  ::Valdi::DownloadableModuleArtifact* mutable_artifact();
  void set_allocated_artifact(::Valdi::DownloadableModuleArtifact* artifact);
  private:
  const ::Valdi::DownloadableModuleArtifact& _internal_artifact() const;
  ::Valdi::DownloadableModuleArtifact* _internal_mutable_artifact();
  public:
  void unsafe_arena_set_allocated_artifact(
      ::Valdi::DownloadableModuleArtifact* artifact);
  ::Valdi::DownloadableModuleArtifact* unsafe_arena_release_artifact();

  // bool has_local_assets = 5;
  void clear_has_local_assets();
  bool has_local_assets() const;
  void set_has_local_assets(bool value);
  private:
  bool _internal_has_local_assets() const;
  void _internal_set_has_local_assets(bool value);
  public:

  // @@protoc_insertion_point(class_scope:Valdi.DownloadableModuleManifest)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Valdi::DownloadableModuleAssets > assets_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> dependencies_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::Valdi::DownloadableModuleArtifact* artifact_;
  bool has_local_assets_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_valdi_2eproto;
};
// -------------------------------------------------------------------

class DaemonAwakeMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Valdi.DaemonAwakeMessage) */ {
 public:
  inline DaemonAwakeMessage() : DaemonAwakeMessage(nullptr) {}
  ~DaemonAwakeMessage() override;
  explicit PROTOBUF_CONSTEXPR DaemonAwakeMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DaemonAwakeMessage(const DaemonAwakeMessage& from);
  DaemonAwakeMessage(DaemonAwakeMessage&& from) noexcept
    : DaemonAwakeMessage() {
    *this = ::std::move(from);
  }

  inline DaemonAwakeMessage& operator=(const DaemonAwakeMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline DaemonAwakeMessage& operator=(DaemonAwakeMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DaemonAwakeMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const DaemonAwakeMessage* internal_default_instance() {
    return reinterpret_cast<const DaemonAwakeMessage*>(
               &_DaemonAwakeMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  friend void swap(DaemonAwakeMessage& a, DaemonAwakeMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(DaemonAwakeMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DaemonAwakeMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DaemonAwakeMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DaemonAwakeMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DaemonAwakeMessage& from);
  void MergeFrom(const DaemonAwakeMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DaemonAwakeMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Valdi.DaemonAwakeMessage";
  }
  protected:
  explicit DaemonAwakeMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kServiceAddressesFieldNumber = 1,
    kDeviceIdsFieldNumber = 16,
    kUsernamesFieldNumber = 17,
    kProcessIdFieldNumber = 3,
    kServicePortFieldNumber = 2,
  };
  // repeated string service_addresses = 1;
  int service_addresses_size() const;
  private:
  int _internal_service_addresses_size() const;
  public:
  void clear_service_addresses();
  const std::string& service_addresses(int index) const;
  std::string* mutable_service_addresses(int index);
  void set_service_addresses(int index, const std::string& value);
  void set_service_addresses(int index, std::string&& value);
  void set_service_addresses(int index, const char* value);
  void set_service_addresses(int index, const char* value, size_t size);
  std::string* add_service_addresses();
  void add_service_addresses(const std::string& value);
  void add_service_addresses(std::string&& value);
  void add_service_addresses(const char* value);
  void add_service_addresses(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& service_addresses() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_service_addresses();
  private:
  const std::string& _internal_service_addresses(int index) const;
  std::string* _internal_add_service_addresses();
  public:

  // repeated string device_ids = 16;
  int device_ids_size() const;
  private:
  int _internal_device_ids_size() const;
  public:
  void clear_device_ids();
  const std::string& device_ids(int index) const;
  std::string* mutable_device_ids(int index);
  void set_device_ids(int index, const std::string& value);
  void set_device_ids(int index, std::string&& value);
  void set_device_ids(int index, const char* value);
  void set_device_ids(int index, const char* value, size_t size);
  std::string* add_device_ids();
  void add_device_ids(const std::string& value);
  void add_device_ids(std::string&& value);
  void add_device_ids(const char* value);
  void add_device_ids(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& device_ids() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_device_ids();
  private:
  const std::string& _internal_device_ids(int index) const;
  std::string* _internal_add_device_ids();
  public:

  // repeated string usernames = 17;
  int usernames_size() const;
  private:
  int _internal_usernames_size() const;
  public:
  void clear_usernames();
  const std::string& usernames(int index) const;
  std::string* mutable_usernames(int index);
  void set_usernames(int index, const std::string& value);
  void set_usernames(int index, std::string&& value);
  void set_usernames(int index, const char* value);
  void set_usernames(int index, const char* value, size_t size);
  std::string* add_usernames();
  void add_usernames(const std::string& value);
  void add_usernames(std::string&& value);
  void add_usernames(const char* value);
  void add_usernames(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& usernames() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_usernames();
  private:
  const std::string& _internal_usernames(int index) const;
  std::string* _internal_add_usernames();
  public:

  // string process_id = 3;
  void clear_process_id();
  const std::string& process_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_process_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_process_id();
  PROTOBUF_NODISCARD std::string* release_process_id();
  void set_allocated_process_id(std::string* process_id);
  private:
  const std::string& _internal_process_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_process_id(const std::string& value);
  std::string* _internal_mutable_process_id();
  public:

  // int32 service_port = 2;
  void clear_service_port();
  int32_t service_port() const;
  void set_service_port(int32_t value);
  private:
  int32_t _internal_service_port() const;
  void _internal_set_service_port(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Valdi.DaemonAwakeMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> service_addresses_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> device_ids_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> usernames_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr process_id_;
  int32_t service_port_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_valdi_2eproto;
};
// -------------------------------------------------------------------

class ClientAwakeMessage final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Valdi.ClientAwakeMessage) */ {
 public:
  inline ClientAwakeMessage() : ClientAwakeMessage(nullptr) {}
  ~ClientAwakeMessage() override;
  explicit PROTOBUF_CONSTEXPR ClientAwakeMessage(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  ClientAwakeMessage(const ClientAwakeMessage& from);
  ClientAwakeMessage(ClientAwakeMessage&& from) noexcept
    : ClientAwakeMessage() {
    *this = ::std::move(from);
  }

  inline ClientAwakeMessage& operator=(const ClientAwakeMessage& from) {
    CopyFrom(from);
    return *this;
  }
  inline ClientAwakeMessage& operator=(ClientAwakeMessage&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const ClientAwakeMessage& default_instance() {
    return *internal_default_instance();
  }
  static inline const ClientAwakeMessage* internal_default_instance() {
    return reinterpret_cast<const ClientAwakeMessage*>(
               &_ClientAwakeMessage_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  friend void swap(ClientAwakeMessage& a, ClientAwakeMessage& b) {
    a.Swap(&b);
  }
  inline void Swap(ClientAwakeMessage* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(ClientAwakeMessage* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  ClientAwakeMessage* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<ClientAwakeMessage>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const ClientAwakeMessage& from);
  void MergeFrom(const ClientAwakeMessage& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(ClientAwakeMessage* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Valdi.ClientAwakeMessage";
  }
  protected:
  explicit ClientAwakeMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDeviceIdFieldNumber = 1,
    kUsernameFieldNumber = 2,
  };
  // string device_id = 1;
  void clear_device_id();
  const std::string& device_id() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_device_id(ArgT0&& arg0, ArgT... args);
  std::string* mutable_device_id();
  PROTOBUF_NODISCARD std::string* release_device_id();
  void set_allocated_device_id(std::string* device_id);
  private:
  const std::string& _internal_device_id() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_device_id(const std::string& value);
  std::string* _internal_mutable_device_id();
  public:

  // string username = 2;
  void clear_username();
  const std::string& username() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_username(ArgT0&& arg0, ArgT... args);
  std::string* mutable_username();
  PROTOBUF_NODISCARD std::string* release_username();
  void set_allocated_username(std::string* username);
  private:
  const std::string& _internal_username() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_username(const std::string& value);
  std::string* _internal_mutable_username();
  public:

  // @@protoc_insertion_point(class_scope:Valdi.ClientAwakeMessage)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr device_id_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr username_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_valdi_2eproto;
};
// -------------------------------------------------------------------

class DaemonServiceDiscoveryPayload final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Valdi.DaemonServiceDiscoveryPayload) */ {
 public:
  inline DaemonServiceDiscoveryPayload() : DaemonServiceDiscoveryPayload(nullptr) {}
  ~DaemonServiceDiscoveryPayload() override;
  explicit PROTOBUF_CONSTEXPR DaemonServiceDiscoveryPayload(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  DaemonServiceDiscoveryPayload(const DaemonServiceDiscoveryPayload& from);
  DaemonServiceDiscoveryPayload(DaemonServiceDiscoveryPayload&& from) noexcept
    : DaemonServiceDiscoveryPayload() {
    *this = ::std::move(from);
  }

  inline DaemonServiceDiscoveryPayload& operator=(const DaemonServiceDiscoveryPayload& from) {
    CopyFrom(from);
    return *this;
  }
  inline DaemonServiceDiscoveryPayload& operator=(DaemonServiceDiscoveryPayload&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const DaemonServiceDiscoveryPayload& default_instance() {
    return *internal_default_instance();
  }
  enum MessageCase {
    kDaemonAwakeMessage = 1,
    kClientAwakeMessage = 2,
    MESSAGE_NOT_SET = 0,
  };

  static inline const DaemonServiceDiscoveryPayload* internal_default_instance() {
    return reinterpret_cast<const DaemonServiceDiscoveryPayload*>(
               &_DaemonServiceDiscoveryPayload_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  friend void swap(DaemonServiceDiscoveryPayload& a, DaemonServiceDiscoveryPayload& b) {
    a.Swap(&b);
  }
  inline void Swap(DaemonServiceDiscoveryPayload* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(DaemonServiceDiscoveryPayload* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  DaemonServiceDiscoveryPayload* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<DaemonServiceDiscoveryPayload>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const DaemonServiceDiscoveryPayload& from);
  void MergeFrom(const DaemonServiceDiscoveryPayload& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(DaemonServiceDiscoveryPayload* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Valdi.DaemonServiceDiscoveryPayload";
  }
  protected:
  explicit DaemonServiceDiscoveryPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kDaemonAwakeMessageFieldNumber = 1,
    kClientAwakeMessageFieldNumber = 2,
  };
  // .Valdi.DaemonAwakeMessage daemon_awake_message = 1;
  bool has_daemon_awake_message() const;
  private:
  bool _internal_has_daemon_awake_message() const;
  public:
  void clear_daemon_awake_message();
  const ::Valdi::DaemonAwakeMessage& daemon_awake_message() const;
  PROTOBUF_NODISCARD ::Valdi::DaemonAwakeMessage* release_daemon_awake_message();
  ::Valdi::DaemonAwakeMessage* mutable_daemon_awake_message();
  void set_allocated_daemon_awake_message(::Valdi::DaemonAwakeMessage* daemon_awake_message);
  private:
  const ::Valdi::DaemonAwakeMessage& _internal_daemon_awake_message() const;
  ::Valdi::DaemonAwakeMessage* _internal_mutable_daemon_awake_message();
  public:
  void unsafe_arena_set_allocated_daemon_awake_message(
      ::Valdi::DaemonAwakeMessage* daemon_awake_message);
  ::Valdi::DaemonAwakeMessage* unsafe_arena_release_daemon_awake_message();

  // .Valdi.ClientAwakeMessage client_awake_message = 2;
  bool has_client_awake_message() const;
  private:
  bool _internal_has_client_awake_message() const;
  public:
  void clear_client_awake_message();
  const ::Valdi::ClientAwakeMessage& client_awake_message() const;
  PROTOBUF_NODISCARD ::Valdi::ClientAwakeMessage* release_client_awake_message();
  ::Valdi::ClientAwakeMessage* mutable_client_awake_message();
  void set_allocated_client_awake_message(::Valdi::ClientAwakeMessage* client_awake_message);
  private:
  const ::Valdi::ClientAwakeMessage& _internal_client_awake_message() const;
  ::Valdi::ClientAwakeMessage* _internal_mutable_client_awake_message();
  public:
  void unsafe_arena_set_allocated_client_awake_message(
      ::Valdi::ClientAwakeMessage* client_awake_message);
  ::Valdi::ClientAwakeMessage* unsafe_arena_release_client_awake_message();

  void clear_message();
  MessageCase message_case() const;
  // @@protoc_insertion_point(class_scope:Valdi.DaemonServiceDiscoveryPayload)
 private:
  class _Internal;
  void set_has_daemon_awake_message();
  void set_has_client_awake_message();

  inline bool has_message() const;
  inline void clear_has_message();

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  union MessageUnion {
    constexpr MessageUnion() : _constinit_{} {}
      ::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized _constinit_;
    ::Valdi::DaemonAwakeMessage* daemon_awake_message_;
    ::Valdi::ClientAwakeMessage* client_awake_message_;
  } message_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  uint32_t _oneof_case_[1];

  friend struct ::TableStruct_valdi_2eproto;
};
// -------------------------------------------------------------------

class StyleNode final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Valdi.StyleNode) */ {
 public:
  inline StyleNode() : StyleNode(nullptr) {}
  ~StyleNode() override;
  explicit PROTOBUF_CONSTEXPR StyleNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StyleNode(const StyleNode& from);
  StyleNode(StyleNode&& from) noexcept
    : StyleNode() {
    *this = ::std::move(from);
  }

  inline StyleNode& operator=(const StyleNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline StyleNode& operator=(StyleNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const StyleNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const StyleNode* internal_default_instance() {
    return reinterpret_cast<const StyleNode*>(
               &_StyleNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  friend void swap(StyleNode& a, StyleNode& b) {
    a.Swap(&b);
  }
  inline void Swap(StyleNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StyleNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StyleNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StyleNode>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const StyleNode& from);
  void MergeFrom(const StyleNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StyleNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Valdi.StyleNode";
  }
  protected:
  explicit StyleNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kStylesFieldNumber = 1,
    kRuleIndexFieldNumber = 2,
  };
  // repeated .Valdi.StyleDeclaration styles = 1;
  int styles_size() const;
  private:
  int _internal_styles_size() const;
  public:
  void clear_styles();
  ::Valdi::StyleDeclaration* mutable_styles(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Valdi::StyleDeclaration >*
      mutable_styles();
  private:
  const ::Valdi::StyleDeclaration& _internal_styles(int index) const;
  ::Valdi::StyleDeclaration* _internal_add_styles();
  public:
  const ::Valdi::StyleDeclaration& styles(int index) const;
  ::Valdi::StyleDeclaration* add_styles();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Valdi::StyleDeclaration >&
      styles() const;

  // .Valdi.CSSRuleIndex ruleIndex = 2;
  bool has_ruleindex() const;
  private:
  bool _internal_has_ruleindex() const;
  public:
  void clear_ruleindex();
  const ::Valdi::CSSRuleIndex& ruleindex() const;
  PROTOBUF_NODISCARD ::Valdi::CSSRuleIndex* release_ruleindex();
  ::Valdi::CSSRuleIndex* mutable_ruleindex();
  void set_allocated_ruleindex(::Valdi::CSSRuleIndex* ruleindex);
  private:
  const ::Valdi::CSSRuleIndex& _internal_ruleindex() const;
  ::Valdi::CSSRuleIndex* _internal_mutable_ruleindex();
  public:
  void unsafe_arena_set_allocated_ruleindex(
      ::Valdi::CSSRuleIndex* ruleindex);
  ::Valdi::CSSRuleIndex* unsafe_arena_release_ruleindex();

  // @@protoc_insertion_point(class_scope:Valdi.StyleNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Valdi::StyleDeclaration > styles_;
  ::Valdi::CSSRuleIndex* ruleindex_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_valdi_2eproto;
};
// -------------------------------------------------------------------

class StyleDeclaration final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Valdi.StyleDeclaration) */ {
 public:
  inline StyleDeclaration() : StyleDeclaration(nullptr) {}
  ~StyleDeclaration() override;
  explicit PROTOBUF_CONSTEXPR StyleDeclaration(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  StyleDeclaration(const StyleDeclaration& from);
  StyleDeclaration(StyleDeclaration&& from) noexcept
    : StyleDeclaration() {
    *this = ::std::move(from);
  }

  inline StyleDeclaration& operator=(const StyleDeclaration& from) {
    CopyFrom(from);
    return *this;
  }
  inline StyleDeclaration& operator=(StyleDeclaration&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const StyleDeclaration& default_instance() {
    return *internal_default_instance();
  }
  static inline const StyleDeclaration* internal_default_instance() {
    return reinterpret_cast<const StyleDeclaration*>(
               &_StyleDeclaration_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  friend void swap(StyleDeclaration& a, StyleDeclaration& b) {
    a.Swap(&b);
  }
  inline void Swap(StyleDeclaration* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(StyleDeclaration* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  StyleDeclaration* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<StyleDeclaration>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const StyleDeclaration& from);
  void MergeFrom(const StyleDeclaration& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(StyleDeclaration* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Valdi.StyleDeclaration";
  }
  protected:
  explicit StyleDeclaration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kAttributeFieldNumber = 1,
    kPriorityFieldNumber = 2,
    kOrderFieldNumber = 3,
    kIdFieldNumber = 4,
  };
  // .Valdi.NodeAttribute attribute = 1;
  bool has_attribute() const;
  private:
  bool _internal_has_attribute() const;
  public:
  void clear_attribute();
  const ::Valdi::NodeAttribute& attribute() const;
  PROTOBUF_NODISCARD ::Valdi::NodeAttribute* release_attribute();
  ::Valdi::NodeAttribute* mutable_attribute();
  void set_allocated_attribute(::Valdi::NodeAttribute* attribute);
  private:
  const ::Valdi::NodeAttribute& _internal_attribute() const;
  ::Valdi::NodeAttribute* _internal_mutable_attribute();
  public:
  void unsafe_arena_set_allocated_attribute(
      ::Valdi::NodeAttribute* attribute);
  ::Valdi::NodeAttribute* unsafe_arena_release_attribute();

  // int32 priority = 2;
  void clear_priority();
  int32_t priority() const;
  void set_priority(int32_t value);
  private:
  int32_t _internal_priority() const;
  void _internal_set_priority(int32_t value);
  public:

  // int32 order = 3;
  void clear_order();
  int32_t order() const;
  void set_order(int32_t value);
  private:
  int32_t _internal_order() const;
  void _internal_set_order(int32_t value);
  public:

  // int32 id = 4;
  void clear_id();
  int32_t id() const;
  void set_id(int32_t value);
  private:
  int32_t _internal_id() const;
  void _internal_set_id(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Valdi.StyleDeclaration)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Valdi::NodeAttribute* attribute_;
  int32_t priority_;
  int32_t order_;
  int32_t id_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_valdi_2eproto;
};
// -------------------------------------------------------------------

class NamedStyleNode final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Valdi.NamedStyleNode) */ {
 public:
  inline NamedStyleNode() : NamedStyleNode(nullptr) {}
  ~NamedStyleNode() override;
  explicit PROTOBUF_CONSTEXPR NamedStyleNode(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  NamedStyleNode(const NamedStyleNode& from);
  NamedStyleNode(NamedStyleNode&& from) noexcept
    : NamedStyleNode() {
    *this = ::std::move(from);
  }

  inline NamedStyleNode& operator=(const NamedStyleNode& from) {
    CopyFrom(from);
    return *this;
  }
  inline NamedStyleNode& operator=(NamedStyleNode&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const NamedStyleNode& default_instance() {
    return *internal_default_instance();
  }
  static inline const NamedStyleNode* internal_default_instance() {
    return reinterpret_cast<const NamedStyleNode*>(
               &_NamedStyleNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  friend void swap(NamedStyleNode& a, NamedStyleNode& b) {
    a.Swap(&b);
  }
  inline void Swap(NamedStyleNode* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(NamedStyleNode* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  NamedStyleNode* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<NamedStyleNode>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const NamedStyleNode& from);
  void MergeFrom(const NamedStyleNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(NamedStyleNode* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Valdi.NamedStyleNode";
  }
  protected:
  explicit NamedStyleNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNameFieldNumber = 1,
    kNodeFieldNumber = 2,
  };
  // string name = 1;
  void clear_name();
  const std::string& name() const;
  template <typename ArgT0 = const std::string&, typename... ArgT>
  void set_name(ArgT0&& arg0, ArgT... args);
  std::string* mutable_name();
  PROTOBUF_NODISCARD std::string* release_name();
  void set_allocated_name(std::string* name);
  private:
  const std::string& _internal_name() const;
  inline PROTOBUF_ALWAYS_INLINE void _internal_set_name(const std::string& value);
  std::string* _internal_mutable_name();
  public:

  // .Valdi.StyleNode node = 2;
  bool has_node() const;
  private:
  bool _internal_has_node() const;
  public:
  void clear_node();
  const ::Valdi::StyleNode& node() const;
  PROTOBUF_NODISCARD ::Valdi::StyleNode* release_node();
  ::Valdi::StyleNode* mutable_node();
  void set_allocated_node(::Valdi::StyleNode* node);
  private:
  const ::Valdi::StyleNode& _internal_node() const;
  ::Valdi::StyleNode* _internal_mutable_node();
  public:
  void unsafe_arena_set_allocated_node(
      ::Valdi::StyleNode* node);
  ::Valdi::StyleNode* unsafe_arena_release_node();

  // @@protoc_insertion_point(class_scope:Valdi.NamedStyleNode)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr name_;
  ::Valdi::StyleNode* node_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_valdi_2eproto;
};
// -------------------------------------------------------------------

class CSSRuleIndex_AttributeRule final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Valdi.CSSRuleIndex.AttributeRule) */ {
 public:
  inline CSSRuleIndex_AttributeRule() : CSSRuleIndex_AttributeRule(nullptr) {}
  ~CSSRuleIndex_AttributeRule() override;
  explicit PROTOBUF_CONSTEXPR CSSRuleIndex_AttributeRule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSSRuleIndex_AttributeRule(const CSSRuleIndex_AttributeRule& from);
  CSSRuleIndex_AttributeRule(CSSRuleIndex_AttributeRule&& from) noexcept
    : CSSRuleIndex_AttributeRule() {
    *this = ::std::move(from);
  }

  inline CSSRuleIndex_AttributeRule& operator=(const CSSRuleIndex_AttributeRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSSRuleIndex_AttributeRule& operator=(CSSRuleIndex_AttributeRule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const CSSRuleIndex_AttributeRule& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSSRuleIndex_AttributeRule* internal_default_instance() {
    return reinterpret_cast<const CSSRuleIndex_AttributeRule*>(
               &_CSSRuleIndex_AttributeRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  friend void swap(CSSRuleIndex_AttributeRule& a, CSSRuleIndex_AttributeRule& b) {
    a.Swap(&b);
  }
  inline void Swap(CSSRuleIndex_AttributeRule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSSRuleIndex_AttributeRule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSSRuleIndex_AttributeRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSSRuleIndex_AttributeRule>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CSSRuleIndex_AttributeRule& from);
  void MergeFrom(const CSSRuleIndex_AttributeRule& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CSSRuleIndex_AttributeRule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Valdi.CSSRuleIndex.AttributeRule";
  }
  protected:
  explicit CSSRuleIndex_AttributeRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CSSRuleIndex_AttributeRule_Type Type;
  static constexpr Type EQUALS =
    CSSRuleIndex_AttributeRule_Type_EQUALS;
  static constexpr Type CONTAINS_WORD =
    CSSRuleIndex_AttributeRule_Type_CONTAINS_WORD;
  static constexpr Type STARTS_WITH_WORD =
    CSSRuleIndex_AttributeRule_Type_STARTS_WITH_WORD;
  static constexpr Type STARTS_WITH_SUBSTRING =
    CSSRuleIndex_AttributeRule_Type_STARTS_WITH_SUBSTRING;
  static constexpr Type ENDS_WITH_SUBSTRING =
    CSSRuleIndex_AttributeRule_Type_ENDS_WITH_SUBSTRING;
  static constexpr Type CONTAINS_SUBSTRING =
    CSSRuleIndex_AttributeRule_Type_CONTAINS_SUBSTRING;
  static constexpr Type HAS_ATTRIBUTE =
    CSSRuleIndex_AttributeRule_Type_HAS_ATTRIBUTE;
  static inline bool Type_IsValid(int value) {
    return CSSRuleIndex_AttributeRule_Type_IsValid(value);
  }
  static constexpr Type Type_MIN =
    CSSRuleIndex_AttributeRule_Type_Type_MIN;
  static constexpr Type Type_MAX =
    CSSRuleIndex_AttributeRule_Type_Type_MAX;
  static constexpr int Type_ARRAYSIZE =
    CSSRuleIndex_AttributeRule_Type_Type_ARRAYSIZE;
  template<typename T>
  static inline const std::string& Type_Name(T enum_t_value) {
    static_assert(::std::is_same<T, Type>::value ||
      ::std::is_integral<T>::value,
      "Incorrect type passed to function Type_Name.");
    return CSSRuleIndex_AttributeRule_Type_Name(enum_t_value);
  }
  static inline bool Type_Parse(::PROTOBUF_NAMESPACE_ID::ConstStringParam name,
      Type* value) {
    return CSSRuleIndex_AttributeRule_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  enum : int {
    kAttributeFieldNumber = 2,
    kNodeFieldNumber = 3,
    kTypeFieldNumber = 1,
  };
  // .Valdi.NodeAttribute attribute = 2;
  bool has_attribute() const;
  private:
  bool _internal_has_attribute() const;
  public:
  void clear_attribute();
  const ::Valdi::NodeAttribute& attribute() const;
  PROTOBUF_NODISCARD ::Valdi::NodeAttribute* release_attribute();
  ::Valdi::NodeAttribute* mutable_attribute();
  void set_allocated_attribute(::Valdi::NodeAttribute* attribute);
  private:
  const ::Valdi::NodeAttribute& _internal_attribute() const;
  ::Valdi::NodeAttribute* _internal_mutable_attribute();
  public:
  void unsafe_arena_set_allocated_attribute(
      ::Valdi::NodeAttribute* attribute);
  ::Valdi::NodeAttribute* unsafe_arena_release_attribute();

  // .Valdi.StyleNode node = 3;
  bool has_node() const;
  private:
  bool _internal_has_node() const;
  public:
  void clear_node();
  const ::Valdi::StyleNode& node() const;
  PROTOBUF_NODISCARD ::Valdi::StyleNode* release_node();
  ::Valdi::StyleNode* mutable_node();
  void set_allocated_node(::Valdi::StyleNode* node);
  private:
  const ::Valdi::StyleNode& _internal_node() const;
  ::Valdi::StyleNode* _internal_mutable_node();
  public:
  void unsafe_arena_set_allocated_node(
      ::Valdi::StyleNode* node);
  ::Valdi::StyleNode* unsafe_arena_release_node();

  // .Valdi.CSSRuleIndex.AttributeRule.Type type = 1;
  void clear_type();
  ::Valdi::CSSRuleIndex_AttributeRule_Type type() const;
  void set_type(::Valdi::CSSRuleIndex_AttributeRule_Type value);
  private:
  ::Valdi::CSSRuleIndex_AttributeRule_Type _internal_type() const;
  void _internal_set_type(::Valdi::CSSRuleIndex_AttributeRule_Type value);
  public:

  // @@protoc_insertion_point(class_scope:Valdi.CSSRuleIndex.AttributeRule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Valdi::NodeAttribute* attribute_;
  ::Valdi::StyleNode* node_;
  int type_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_valdi_2eproto;
};
// -------------------------------------------------------------------

class CSSRuleIndex_NthChildRule final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Valdi.CSSRuleIndex.NthChildRule) */ {
 public:
  inline CSSRuleIndex_NthChildRule() : CSSRuleIndex_NthChildRule(nullptr) {}
  ~CSSRuleIndex_NthChildRule() override;
  explicit PROTOBUF_CONSTEXPR CSSRuleIndex_NthChildRule(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSSRuleIndex_NthChildRule(const CSSRuleIndex_NthChildRule& from);
  CSSRuleIndex_NthChildRule(CSSRuleIndex_NthChildRule&& from) noexcept
    : CSSRuleIndex_NthChildRule() {
    *this = ::std::move(from);
  }

  inline CSSRuleIndex_NthChildRule& operator=(const CSSRuleIndex_NthChildRule& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSSRuleIndex_NthChildRule& operator=(CSSRuleIndex_NthChildRule&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const CSSRuleIndex_NthChildRule& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSSRuleIndex_NthChildRule* internal_default_instance() {
    return reinterpret_cast<const CSSRuleIndex_NthChildRule*>(
               &_CSSRuleIndex_NthChildRule_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  friend void swap(CSSRuleIndex_NthChildRule& a, CSSRuleIndex_NthChildRule& b) {
    a.Swap(&b);
  }
  inline void Swap(CSSRuleIndex_NthChildRule* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSSRuleIndex_NthChildRule* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSSRuleIndex_NthChildRule* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSSRuleIndex_NthChildRule>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CSSRuleIndex_NthChildRule& from);
  void MergeFrom(const CSSRuleIndex_NthChildRule& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CSSRuleIndex_NthChildRule* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Valdi.CSSRuleIndex.NthChildRule";
  }
  protected:
  explicit CSSRuleIndex_NthChildRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kNodeFieldNumber = 3,
    kNFieldNumber = 1,
    kOffsetFieldNumber = 2,
  };
  // .Valdi.StyleNode node = 3;
  bool has_node() const;
  private:
  bool _internal_has_node() const;
  public:
  void clear_node();
  const ::Valdi::StyleNode& node() const;
  PROTOBUF_NODISCARD ::Valdi::StyleNode* release_node();
  ::Valdi::StyleNode* mutable_node();
  void set_allocated_node(::Valdi::StyleNode* node);
  private:
  const ::Valdi::StyleNode& _internal_node() const;
  ::Valdi::StyleNode* _internal_mutable_node();
  public:
  void unsafe_arena_set_allocated_node(
      ::Valdi::StyleNode* node);
  ::Valdi::StyleNode* unsafe_arena_release_node();

  // int32 n = 1;
  void clear_n();
  int32_t n() const;
  void set_n(int32_t value);
  private:
  int32_t _internal_n() const;
  void _internal_set_n(int32_t value);
  public:

  // int32 offset = 2;
  void clear_offset();
  int32_t offset() const;
  void set_offset(int32_t value);
  private:
  int32_t _internal_offset() const;
  void _internal_set_offset(int32_t value);
  public:

  // @@protoc_insertion_point(class_scope:Valdi.CSSRuleIndex.NthChildRule)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::Valdi::StyleNode* node_;
  int32_t n_;
  int32_t offset_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_valdi_2eproto;
};
// -------------------------------------------------------------------

class CSSRuleIndex final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Valdi.CSSRuleIndex) */ {
 public:
  inline CSSRuleIndex() : CSSRuleIndex(nullptr) {}
  ~CSSRuleIndex() override;
  explicit PROTOBUF_CONSTEXPR CSSRuleIndex(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  CSSRuleIndex(const CSSRuleIndex& from);
  CSSRuleIndex(CSSRuleIndex&& from) noexcept
    : CSSRuleIndex() {
    *this = ::std::move(from);
  }

  inline CSSRuleIndex& operator=(const CSSRuleIndex& from) {
    CopyFrom(from);
    return *this;
  }
  inline CSSRuleIndex& operator=(CSSRuleIndex&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const CSSRuleIndex& default_instance() {
    return *internal_default_instance();
  }
  static inline const CSSRuleIndex* internal_default_instance() {
    return reinterpret_cast<const CSSRuleIndex*>(
               &_CSSRuleIndex_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  friend void swap(CSSRuleIndex& a, CSSRuleIndex& b) {
    a.Swap(&b);
  }
  inline void Swap(CSSRuleIndex* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(CSSRuleIndex* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  CSSRuleIndex* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<CSSRuleIndex>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const CSSRuleIndex& from);
  void MergeFrom(const CSSRuleIndex& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CSSRuleIndex* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Valdi.CSSRuleIndex";
  }
  protected:
  explicit CSSRuleIndex(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  typedef CSSRuleIndex_AttributeRule AttributeRule;
  typedef CSSRuleIndex_NthChildRule NthChildRule;

  // accessors -------------------------------------------------------

  enum : int {
    kIdRulesFieldNumber = 1,
    kClassRulesFieldNumber = 2,
    kTagRulesFieldNumber = 3,
    kAttributeRulesFieldNumber = 4,
    kNthChildRulesFieldNumber = 7,
    kFirstChildRuleFieldNumber = 5,
    kLastChildRuleFieldNumber = 6,
    kAncestorRulesFieldNumber = 8,
    kDirectParentRulesFieldNumber = 9,
  };
  // repeated .Valdi.NamedStyleNode id_rules = 1;
  int id_rules_size() const;
  private:
  int _internal_id_rules_size() const;
  public:
  void clear_id_rules();
  ::Valdi::NamedStyleNode* mutable_id_rules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Valdi::NamedStyleNode >*
      mutable_id_rules();
  private:
  const ::Valdi::NamedStyleNode& _internal_id_rules(int index) const;
  ::Valdi::NamedStyleNode* _internal_add_id_rules();
  public:
  const ::Valdi::NamedStyleNode& id_rules(int index) const;
  ::Valdi::NamedStyleNode* add_id_rules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Valdi::NamedStyleNode >&
      id_rules() const;

  // repeated .Valdi.NamedStyleNode class_rules = 2;
  int class_rules_size() const;
  private:
  int _internal_class_rules_size() const;
  public:
  void clear_class_rules();
  ::Valdi::NamedStyleNode* mutable_class_rules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Valdi::NamedStyleNode >*
      mutable_class_rules();
  private:
  const ::Valdi::NamedStyleNode& _internal_class_rules(int index) const;
  ::Valdi::NamedStyleNode* _internal_add_class_rules();
  public:
  const ::Valdi::NamedStyleNode& class_rules(int index) const;
  ::Valdi::NamedStyleNode* add_class_rules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Valdi::NamedStyleNode >&
      class_rules() const;

  // repeated .Valdi.NamedStyleNode tag_rules = 3;
  int tag_rules_size() const;
  private:
  int _internal_tag_rules_size() const;
  public:
  void clear_tag_rules();
  ::Valdi::NamedStyleNode* mutable_tag_rules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Valdi::NamedStyleNode >*
      mutable_tag_rules();
  private:
  const ::Valdi::NamedStyleNode& _internal_tag_rules(int index) const;
  ::Valdi::NamedStyleNode* _internal_add_tag_rules();
  public:
  const ::Valdi::NamedStyleNode& tag_rules(int index) const;
  ::Valdi::NamedStyleNode* add_tag_rules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Valdi::NamedStyleNode >&
      tag_rules() const;

  // repeated .Valdi.CSSRuleIndex.AttributeRule attribute_rules = 4;
  int attribute_rules_size() const;
  private:
  int _internal_attribute_rules_size() const;
  public:
  void clear_attribute_rules();
  ::Valdi::CSSRuleIndex_AttributeRule* mutable_attribute_rules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Valdi::CSSRuleIndex_AttributeRule >*
      mutable_attribute_rules();
  private:
  const ::Valdi::CSSRuleIndex_AttributeRule& _internal_attribute_rules(int index) const;
  ::Valdi::CSSRuleIndex_AttributeRule* _internal_add_attribute_rules();
  public:
  const ::Valdi::CSSRuleIndex_AttributeRule& attribute_rules(int index) const;
  ::Valdi::CSSRuleIndex_AttributeRule* add_attribute_rules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Valdi::CSSRuleIndex_AttributeRule >&
      attribute_rules() const;

  // repeated .Valdi.CSSRuleIndex.NthChildRule nth_child_rules = 7;
  int nth_child_rules_size() const;
  private:
  int _internal_nth_child_rules_size() const;
  public:
  void clear_nth_child_rules();
  ::Valdi::CSSRuleIndex_NthChildRule* mutable_nth_child_rules(int index);
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Valdi::CSSRuleIndex_NthChildRule >*
      mutable_nth_child_rules();
  private:
  const ::Valdi::CSSRuleIndex_NthChildRule& _internal_nth_child_rules(int index) const;
  ::Valdi::CSSRuleIndex_NthChildRule* _internal_add_nth_child_rules();
  public:
  const ::Valdi::CSSRuleIndex_NthChildRule& nth_child_rules(int index) const;
  ::Valdi::CSSRuleIndex_NthChildRule* add_nth_child_rules();
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Valdi::CSSRuleIndex_NthChildRule >&
      nth_child_rules() const;

  // .Valdi.StyleNode first_child_rule = 5;
  bool has_first_child_rule() const;
  private:
  bool _internal_has_first_child_rule() const;
  public:
  void clear_first_child_rule();
  const ::Valdi::StyleNode& first_child_rule() const;
  PROTOBUF_NODISCARD ::Valdi::StyleNode* release_first_child_rule();
  ::Valdi::StyleNode* mutable_first_child_rule();
  void set_allocated_first_child_rule(::Valdi::StyleNode* first_child_rule);
  private:
  const ::Valdi::StyleNode& _internal_first_child_rule() const;
  ::Valdi::StyleNode* _internal_mutable_first_child_rule();
  public:
  void unsafe_arena_set_allocated_first_child_rule(
      ::Valdi::StyleNode* first_child_rule);
  ::Valdi::StyleNode* unsafe_arena_release_first_child_rule();

  // .Valdi.StyleNode last_child_rule = 6;
  bool has_last_child_rule() const;
  private:
  bool _internal_has_last_child_rule() const;
  public:
  void clear_last_child_rule();
  const ::Valdi::StyleNode& last_child_rule() const;
  PROTOBUF_NODISCARD ::Valdi::StyleNode* release_last_child_rule();
  ::Valdi::StyleNode* mutable_last_child_rule();
  void set_allocated_last_child_rule(::Valdi::StyleNode* last_child_rule);
  private:
  const ::Valdi::StyleNode& _internal_last_child_rule() const;
  ::Valdi::StyleNode* _internal_mutable_last_child_rule();
  public:
  void unsafe_arena_set_allocated_last_child_rule(
      ::Valdi::StyleNode* last_child_rule);
  ::Valdi::StyleNode* unsafe_arena_release_last_child_rule();

  // .Valdi.CSSRuleIndex ancestor_rules = 8;
  bool has_ancestor_rules() const;
  private:
  bool _internal_has_ancestor_rules() const;
  public:
  void clear_ancestor_rules();
  const ::Valdi::CSSRuleIndex& ancestor_rules() const;
  PROTOBUF_NODISCARD ::Valdi::CSSRuleIndex* release_ancestor_rules();
  ::Valdi::CSSRuleIndex* mutable_ancestor_rules();
  void set_allocated_ancestor_rules(::Valdi::CSSRuleIndex* ancestor_rules);
  private:
  const ::Valdi::CSSRuleIndex& _internal_ancestor_rules() const;
  ::Valdi::CSSRuleIndex* _internal_mutable_ancestor_rules();
  public:
  void unsafe_arena_set_allocated_ancestor_rules(
      ::Valdi::CSSRuleIndex* ancestor_rules);
  ::Valdi::CSSRuleIndex* unsafe_arena_release_ancestor_rules();

  // .Valdi.CSSRuleIndex direct_parent_rules = 9;
  bool has_direct_parent_rules() const;
  private:
  bool _internal_has_direct_parent_rules() const;
  public:
  void clear_direct_parent_rules();
  const ::Valdi::CSSRuleIndex& direct_parent_rules() const;
  PROTOBUF_NODISCARD ::Valdi::CSSRuleIndex* release_direct_parent_rules();
  ::Valdi::CSSRuleIndex* mutable_direct_parent_rules();
  void set_allocated_direct_parent_rules(::Valdi::CSSRuleIndex* direct_parent_rules);
  private:
  const ::Valdi::CSSRuleIndex& _internal_direct_parent_rules() const;
  ::Valdi::CSSRuleIndex* _internal_mutable_direct_parent_rules();
  public:
  void unsafe_arena_set_allocated_direct_parent_rules(
      ::Valdi::CSSRuleIndex* direct_parent_rules);
  ::Valdi::CSSRuleIndex* unsafe_arena_release_direct_parent_rules();

  // @@protoc_insertion_point(class_scope:Valdi.CSSRuleIndex)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Valdi::NamedStyleNode > id_rules_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Valdi::NamedStyleNode > class_rules_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Valdi::NamedStyleNode > tag_rules_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Valdi::CSSRuleIndex_AttributeRule > attribute_rules_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Valdi::CSSRuleIndex_NthChildRule > nth_child_rules_;
  ::Valdi::StyleNode* first_child_rule_;
  ::Valdi::StyleNode* last_child_rule_;
  ::Valdi::CSSRuleIndex* ancestor_rules_;
  ::Valdi::CSSRuleIndex* direct_parent_rules_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_valdi_2eproto;
};
// -------------------------------------------------------------------

class TsnConfig final :
    public ::PROTOBUF_NAMESPACE_ID::MessageLite /* @@protoc_insertion_point(class_definition:Valdi.TsnConfig) */ {
 public:
  inline TsnConfig() : TsnConfig(nullptr) {}
  ~TsnConfig() override;
  explicit PROTOBUF_CONSTEXPR TsnConfig(::PROTOBUF_NAMESPACE_ID::internal::ConstantInitialized);

  TsnConfig(const TsnConfig& from);
  TsnConfig(TsnConfig&& from) noexcept
    : TsnConfig() {
    *this = ::std::move(from);
  }

  inline TsnConfig& operator=(const TsnConfig& from) {
    CopyFrom(from);
    return *this;
  }
  inline TsnConfig& operator=(TsnConfig&& from) noexcept {
    if (this == &from) return *this;
    if (GetOwningArena() == from.GetOwningArena()
  #ifdef PROTOBUF_FORCE_COPY_IN_MOVE
        && GetOwningArena() != nullptr
  #endif  // !PROTOBUF_FORCE_COPY_IN_MOVE
    ) {
      InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }

  static const TsnConfig& default_instance() {
    return *internal_default_instance();
  }
  static inline const TsnConfig* internal_default_instance() {
    return reinterpret_cast<const TsnConfig*>(
               &_TsnConfig_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  friend void swap(TsnConfig& a, TsnConfig& b) {
    a.Swap(&b);
  }
  inline void Swap(TsnConfig* other) {
    if (other == this) return;
  #ifdef PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() != nullptr &&
        GetOwningArena() == other->GetOwningArena()) {
   #else  // PROTOBUF_FORCE_COPY_IN_SWAP
    if (GetOwningArena() == other->GetOwningArena()) {
  #endif  // !PROTOBUF_FORCE_COPY_IN_SWAP
      InternalSwap(other);
    } else {
      ::PROTOBUF_NAMESPACE_ID::internal::GenericSwap(this, other);
    }
  }
  void UnsafeArenaSwap(TsnConfig* other) {
    if (other == this) return;
    GOOGLE_DCHECK(GetOwningArena() == other->GetOwningArena());
    InternalSwap(other);
  }

  // implements Message ----------------------------------------------

  TsnConfig* New(::PROTOBUF_NAMESPACE_ID::Arena* arena = nullptr) const final {
    return CreateMaybeMessage<TsnConfig>(arena);
  }
  void CheckTypeAndMergeFrom(const ::PROTOBUF_NAMESPACE_ID::MessageLite& from)  final;
  void CopyFrom(const TsnConfig& from);
  void MergeFrom(const TsnConfig& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  const char* _InternalParse(const char* ptr, ::PROTOBUF_NAMESPACE_ID::internal::ParseContext* ctx) final;
  uint8_t* _InternalSerialize(
      uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(TsnConfig* other);

  private:
  friend class ::PROTOBUF_NAMESPACE_ID::internal::AnyMetadata;
  static ::PROTOBUF_NAMESPACE_ID::StringPiece FullMessageName() {
    return "Valdi.TsnConfig";
  }
  protected:
  explicit TsnConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                       bool is_message_owned = false);
  public:

  std::string GetTypeName() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  enum : int {
    kEnabledModulesFieldNumber = 1,
  };
  // repeated string enabled_modules = 1;
  int enabled_modules_size() const;
  private:
  int _internal_enabled_modules_size() const;
  public:
  void clear_enabled_modules();
  const std::string& enabled_modules(int index) const;
  std::string* mutable_enabled_modules(int index);
  void set_enabled_modules(int index, const std::string& value);
  void set_enabled_modules(int index, std::string&& value);
  void set_enabled_modules(int index, const char* value);
  void set_enabled_modules(int index, const char* value, size_t size);
  std::string* add_enabled_modules();
  void add_enabled_modules(const std::string& value);
  void add_enabled_modules(std::string&& value);
  void add_enabled_modules(const char* value);
  void add_enabled_modules(const char* value, size_t size);
  const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>& enabled_modules() const;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>* mutable_enabled_modules();
  private:
  const std::string& _internal_enabled_modules(int index) const;
  std::string* _internal_add_enabled_modules();
  public:

  // @@protoc_insertion_point(class_scope:Valdi.TsnConfig)
 private:
  class _Internal;

  template <typename T> friend class ::PROTOBUF_NAMESPACE_ID::Arena::InternalHelper;
  typedef void InternalArenaConstructable_;
  typedef void DestructorSkippable_;
  ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string> enabled_modules_;
  mutable ::PROTOBUF_NAMESPACE_ID::internal::CachedSize _cached_size_;
  friend struct ::TableStruct_valdi_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// NodeAttribute

// .Valdi.NodeAttribute.Type type = 1;
inline void NodeAttribute::clear_type() {
  type_ = 0;
}
inline ::Valdi::NodeAttribute_Type NodeAttribute::_internal_type() const {
  return static_cast< ::Valdi::NodeAttribute_Type >(type_);
}
inline ::Valdi::NodeAttribute_Type NodeAttribute::type() const {
  // @@protoc_insertion_point(field_get:Valdi.NodeAttribute.type)
  return _internal_type();
}
inline void NodeAttribute::_internal_set_type(::Valdi::NodeAttribute_Type value) {
  
  type_ = value;
}
inline void NodeAttribute::set_type(::Valdi::NodeAttribute_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Valdi.NodeAttribute.type)
}

// string name = 2;
inline void NodeAttribute::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& NodeAttribute::name() const {
  // @@protoc_insertion_point(field_get:Valdi.NodeAttribute.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeAttribute::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Valdi.NodeAttribute.name)
}
inline std::string* NodeAttribute::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Valdi.NodeAttribute.name)
  return _s;
}
inline const std::string& NodeAttribute::_internal_name() const {
  return name_.Get();
}
inline void NodeAttribute::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeAttribute::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeAttribute::release_name() {
  // @@protoc_insertion_point(field_release:Valdi.NodeAttribute.name)
  return name_.Release();
}
inline void NodeAttribute::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Valdi.NodeAttribute.name)
}

// string str_value = 3;
inline void NodeAttribute::clear_str_value() {
  str_value_.ClearToEmpty();
}
inline const std::string& NodeAttribute::str_value() const {
  // @@protoc_insertion_point(field_get:Valdi.NodeAttribute.str_value)
  return _internal_str_value();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NodeAttribute::set_str_value(ArgT0&& arg0, ArgT... args) {
 
 str_value_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Valdi.NodeAttribute.str_value)
}
inline std::string* NodeAttribute::mutable_str_value() {
  std::string* _s = _internal_mutable_str_value();
  // @@protoc_insertion_point(field_mutable:Valdi.NodeAttribute.str_value)
  return _s;
}
inline const std::string& NodeAttribute::_internal_str_value() const {
  return str_value_.Get();
}
inline void NodeAttribute::_internal_set_str_value(const std::string& value) {
  
  str_value_.Set(value, GetArenaForAllocation());
}
inline std::string* NodeAttribute::_internal_mutable_str_value() {
  
  return str_value_.Mutable(GetArenaForAllocation());
}
inline std::string* NodeAttribute::release_str_value() {
  // @@protoc_insertion_point(field_release:Valdi.NodeAttribute.str_value)
  return str_value_.Release();
}
inline void NodeAttribute::set_allocated_str_value(std::string* str_value) {
  if (str_value != nullptr) {
    
  } else {
    
  }
  str_value_.SetAllocated(str_value, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (str_value_.IsDefault()) {
    str_value_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Valdi.NodeAttribute.str_value)
}

// int64 int_value = 4;
inline void NodeAttribute::clear_int_value() {
  int_value_ = int64_t{0};
}
inline int64_t NodeAttribute::_internal_int_value() const {
  return int_value_;
}
inline int64_t NodeAttribute::int_value() const {
  // @@protoc_insertion_point(field_get:Valdi.NodeAttribute.int_value)
  return _internal_int_value();
}
inline void NodeAttribute::_internal_set_int_value(int64_t value) {
  
  int_value_ = value;
}
inline void NodeAttribute::set_int_value(int64_t value) {
  _internal_set_int_value(value);
  // @@protoc_insertion_point(field_set:Valdi.NodeAttribute.int_value)
}

// double double_value = 5;
inline void NodeAttribute::clear_double_value() {
  double_value_ = 0;
}
inline double NodeAttribute::_internal_double_value() const {
  return double_value_;
}
inline double NodeAttribute::double_value() const {
  // @@protoc_insertion_point(field_get:Valdi.NodeAttribute.double_value)
  return _internal_double_value();
}
inline void NodeAttribute::_internal_set_double_value(double value) {
  
  double_value_ = value;
}
inline void NodeAttribute::set_double_value(double value) {
  _internal_set_double_value(value);
  // @@protoc_insertion_point(field_set:Valdi.NodeAttribute.double_value)
}

// -------------------------------------------------------------------

// DownloadableModuleArtifact

// string url = 1;
inline void DownloadableModuleArtifact::clear_url() {
  url_.ClearToEmpty();
}
inline const std::string& DownloadableModuleArtifact::url() const {
  // @@protoc_insertion_point(field_get:Valdi.DownloadableModuleArtifact.url)
  return _internal_url();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DownloadableModuleArtifact::set_url(ArgT0&& arg0, ArgT... args) {
 
 url_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Valdi.DownloadableModuleArtifact.url)
}
inline std::string* DownloadableModuleArtifact::mutable_url() {
  std::string* _s = _internal_mutable_url();
  // @@protoc_insertion_point(field_mutable:Valdi.DownloadableModuleArtifact.url)
  return _s;
}
inline const std::string& DownloadableModuleArtifact::_internal_url() const {
  return url_.Get();
}
inline void DownloadableModuleArtifact::_internal_set_url(const std::string& value) {
  
  url_.Set(value, GetArenaForAllocation());
}
inline std::string* DownloadableModuleArtifact::_internal_mutable_url() {
  
  return url_.Mutable(GetArenaForAllocation());
}
inline std::string* DownloadableModuleArtifact::release_url() {
  // @@protoc_insertion_point(field_release:Valdi.DownloadableModuleArtifact.url)
  return url_.Release();
}
inline void DownloadableModuleArtifact::set_allocated_url(std::string* url) {
  if (url != nullptr) {
    
  } else {
    
  }
  url_.SetAllocated(url, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (url_.IsDefault()) {
    url_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Valdi.DownloadableModuleArtifact.url)
}

// bytes sha256Digest = 2;
inline void DownloadableModuleArtifact::clear_sha256digest() {
  sha256digest_.ClearToEmpty();
}
inline const std::string& DownloadableModuleArtifact::sha256digest() const {
  // @@protoc_insertion_point(field_get:Valdi.DownloadableModuleArtifact.sha256Digest)
  return _internal_sha256digest();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DownloadableModuleArtifact::set_sha256digest(ArgT0&& arg0, ArgT... args) {
 
 sha256digest_.SetBytes(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Valdi.DownloadableModuleArtifact.sha256Digest)
}
inline std::string* DownloadableModuleArtifact::mutable_sha256digest() {
  std::string* _s = _internal_mutable_sha256digest();
  // @@protoc_insertion_point(field_mutable:Valdi.DownloadableModuleArtifact.sha256Digest)
  return _s;
}
inline const std::string& DownloadableModuleArtifact::_internal_sha256digest() const {
  return sha256digest_.Get();
}
inline void DownloadableModuleArtifact::_internal_set_sha256digest(const std::string& value) {
  
  sha256digest_.Set(value, GetArenaForAllocation());
}
inline std::string* DownloadableModuleArtifact::_internal_mutable_sha256digest() {
  
  return sha256digest_.Mutable(GetArenaForAllocation());
}
inline std::string* DownloadableModuleArtifact::release_sha256digest() {
  // @@protoc_insertion_point(field_release:Valdi.DownloadableModuleArtifact.sha256Digest)
  return sha256digest_.Release();
}
inline void DownloadableModuleArtifact::set_allocated_sha256digest(std::string* sha256digest) {
  if (sha256digest != nullptr) {
    
  } else {
    
  }
  sha256digest_.SetAllocated(sha256digest, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (sha256digest_.IsDefault()) {
    sha256digest_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Valdi.DownloadableModuleArtifact.sha256Digest)
}

// -------------------------------------------------------------------

// DownloadableModuleAssets

// .Valdi.DownloadableModuleArtifact artifact = 1;
inline bool DownloadableModuleAssets::_internal_has_artifact() const {
  return this != internal_default_instance() && artifact_ != nullptr;
}
inline bool DownloadableModuleAssets::has_artifact() const {
  return _internal_has_artifact();
}
inline void DownloadableModuleAssets::clear_artifact() {
  if (GetArenaForAllocation() == nullptr && artifact_ != nullptr) {
    delete artifact_;
  }
  artifact_ = nullptr;
}
inline const ::Valdi::DownloadableModuleArtifact& DownloadableModuleAssets::_internal_artifact() const {
  const ::Valdi::DownloadableModuleArtifact* p = artifact_;
  return p != nullptr ? *p : reinterpret_cast<const ::Valdi::DownloadableModuleArtifact&>(
      ::Valdi::_DownloadableModuleArtifact_default_instance_);
}
inline const ::Valdi::DownloadableModuleArtifact& DownloadableModuleAssets::artifact() const {
  // @@protoc_insertion_point(field_get:Valdi.DownloadableModuleAssets.artifact)
  return _internal_artifact();
}
inline void DownloadableModuleAssets::unsafe_arena_set_allocated_artifact(
    ::Valdi::DownloadableModuleArtifact* artifact) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(artifact_);
  }
  artifact_ = artifact;
  if (artifact) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Valdi.DownloadableModuleAssets.artifact)
}
inline ::Valdi::DownloadableModuleArtifact* DownloadableModuleAssets::release_artifact() {
  
  ::Valdi::DownloadableModuleArtifact* temp = artifact_;
  artifact_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Valdi::DownloadableModuleArtifact* DownloadableModuleAssets::unsafe_arena_release_artifact() {
  // @@protoc_insertion_point(field_release:Valdi.DownloadableModuleAssets.artifact)
  
  ::Valdi::DownloadableModuleArtifact* temp = artifact_;
  artifact_ = nullptr;
  return temp;
}
inline ::Valdi::DownloadableModuleArtifact* DownloadableModuleAssets::_internal_mutable_artifact() {
  
  if (artifact_ == nullptr) {
    auto* p = CreateMaybeMessage<::Valdi::DownloadableModuleArtifact>(GetArenaForAllocation());
    artifact_ = p;
  }
  return artifact_;
}
inline ::Valdi::DownloadableModuleArtifact* DownloadableModuleAssets::mutable_artifact() {
  ::Valdi::DownloadableModuleArtifact* _msg = _internal_mutable_artifact();
  // @@protoc_insertion_point(field_mutable:Valdi.DownloadableModuleAssets.artifact)
  return _msg;
}
inline void DownloadableModuleAssets::set_allocated_artifact(::Valdi::DownloadableModuleArtifact* artifact) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete artifact_;
  }
  if (artifact) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(artifact);
    if (message_arena != submessage_arena) {
      artifact = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, artifact, submessage_arena);
    }
    
  } else {
    
  }
  artifact_ = artifact;
  // @@protoc_insertion_point(field_set_allocated:Valdi.DownloadableModuleAssets.artifact)
}

// double device_density = 3;
inline void DownloadableModuleAssets::clear_device_density() {
  device_density_ = 0;
}
inline double DownloadableModuleAssets::_internal_device_density() const {
  return device_density_;
}
inline double DownloadableModuleAssets::device_density() const {
  // @@protoc_insertion_point(field_get:Valdi.DownloadableModuleAssets.device_density)
  return _internal_device_density();
}
inline void DownloadableModuleAssets::_internal_set_device_density(double value) {
  
  device_density_ = value;
}
inline void DownloadableModuleAssets::set_device_density(double value) {
  _internal_set_device_density(value);
  // @@protoc_insertion_point(field_set:Valdi.DownloadableModuleAssets.device_density)
}

// -------------------------------------------------------------------

// DownloadableModuleManifest

// string name = 1;
inline void DownloadableModuleManifest::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& DownloadableModuleManifest::name() const {
  // @@protoc_insertion_point(field_get:Valdi.DownloadableModuleManifest.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DownloadableModuleManifest::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Valdi.DownloadableModuleManifest.name)
}
inline std::string* DownloadableModuleManifest::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Valdi.DownloadableModuleManifest.name)
  return _s;
}
inline const std::string& DownloadableModuleManifest::_internal_name() const {
  return name_.Get();
}
inline void DownloadableModuleManifest::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* DownloadableModuleManifest::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* DownloadableModuleManifest::release_name() {
  // @@protoc_insertion_point(field_release:Valdi.DownloadableModuleManifest.name)
  return name_.Release();
}
inline void DownloadableModuleManifest::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Valdi.DownloadableModuleManifest.name)
}

// .Valdi.DownloadableModuleArtifact artifact = 2;
inline bool DownloadableModuleManifest::_internal_has_artifact() const {
  return this != internal_default_instance() && artifact_ != nullptr;
}
inline bool DownloadableModuleManifest::has_artifact() const {
  return _internal_has_artifact();
}
inline void DownloadableModuleManifest::clear_artifact() {
  if (GetArenaForAllocation() == nullptr && artifact_ != nullptr) {
    delete artifact_;
  }
  artifact_ = nullptr;
}
inline const ::Valdi::DownloadableModuleArtifact& DownloadableModuleManifest::_internal_artifact() const {
  const ::Valdi::DownloadableModuleArtifact* p = artifact_;
  return p != nullptr ? *p : reinterpret_cast<const ::Valdi::DownloadableModuleArtifact&>(
      ::Valdi::_DownloadableModuleArtifact_default_instance_);
}
inline const ::Valdi::DownloadableModuleArtifact& DownloadableModuleManifest::artifact() const {
  // @@protoc_insertion_point(field_get:Valdi.DownloadableModuleManifest.artifact)
  return _internal_artifact();
}
inline void DownloadableModuleManifest::unsafe_arena_set_allocated_artifact(
    ::Valdi::DownloadableModuleArtifact* artifact) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(artifact_);
  }
  artifact_ = artifact;
  if (artifact) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Valdi.DownloadableModuleManifest.artifact)
}
inline ::Valdi::DownloadableModuleArtifact* DownloadableModuleManifest::release_artifact() {
  
  ::Valdi::DownloadableModuleArtifact* temp = artifact_;
  artifact_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Valdi::DownloadableModuleArtifact* DownloadableModuleManifest::unsafe_arena_release_artifact() {
  // @@protoc_insertion_point(field_release:Valdi.DownloadableModuleManifest.artifact)
  
  ::Valdi::DownloadableModuleArtifact* temp = artifact_;
  artifact_ = nullptr;
  return temp;
}
inline ::Valdi::DownloadableModuleArtifact* DownloadableModuleManifest::_internal_mutable_artifact() {
  
  if (artifact_ == nullptr) {
    auto* p = CreateMaybeMessage<::Valdi::DownloadableModuleArtifact>(GetArenaForAllocation());
    artifact_ = p;
  }
  return artifact_;
}
inline ::Valdi::DownloadableModuleArtifact* DownloadableModuleManifest::mutable_artifact() {
  ::Valdi::DownloadableModuleArtifact* _msg = _internal_mutable_artifact();
  // @@protoc_insertion_point(field_mutable:Valdi.DownloadableModuleManifest.artifact)
  return _msg;
}
inline void DownloadableModuleManifest::set_allocated_artifact(::Valdi::DownloadableModuleArtifact* artifact) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete artifact_;
  }
  if (artifact) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(artifact);
    if (message_arena != submessage_arena) {
      artifact = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, artifact, submessage_arena);
    }
    
  } else {
    
  }
  artifact_ = artifact;
  // @@protoc_insertion_point(field_set_allocated:Valdi.DownloadableModuleManifest.artifact)
}

// repeated .Valdi.DownloadableModuleAssets assets = 3;
inline int DownloadableModuleManifest::_internal_assets_size() const {
  return assets_.size();
}
inline int DownloadableModuleManifest::assets_size() const {
  return _internal_assets_size();
}
inline void DownloadableModuleManifest::clear_assets() {
  assets_.Clear();
}
inline ::Valdi::DownloadableModuleAssets* DownloadableModuleManifest::mutable_assets(int index) {
  // @@protoc_insertion_point(field_mutable:Valdi.DownloadableModuleManifest.assets)
  return assets_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Valdi::DownloadableModuleAssets >*
DownloadableModuleManifest::mutable_assets() {
  // @@protoc_insertion_point(field_mutable_list:Valdi.DownloadableModuleManifest.assets)
  return &assets_;
}
inline const ::Valdi::DownloadableModuleAssets& DownloadableModuleManifest::_internal_assets(int index) const {
  return assets_.Get(index);
}
inline const ::Valdi::DownloadableModuleAssets& DownloadableModuleManifest::assets(int index) const {
  // @@protoc_insertion_point(field_get:Valdi.DownloadableModuleManifest.assets)
  return _internal_assets(index);
}
inline ::Valdi::DownloadableModuleAssets* DownloadableModuleManifest::_internal_add_assets() {
  return assets_.Add();
}
inline ::Valdi::DownloadableModuleAssets* DownloadableModuleManifest::add_assets() {
  ::Valdi::DownloadableModuleAssets* _add = _internal_add_assets();
  // @@protoc_insertion_point(field_add:Valdi.DownloadableModuleManifest.assets)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Valdi::DownloadableModuleAssets >&
DownloadableModuleManifest::assets() const {
  // @@protoc_insertion_point(field_list:Valdi.DownloadableModuleManifest.assets)
  return assets_;
}

// repeated string dependencies = 4;
inline int DownloadableModuleManifest::_internal_dependencies_size() const {
  return dependencies_.size();
}
inline int DownloadableModuleManifest::dependencies_size() const {
  return _internal_dependencies_size();
}
inline void DownloadableModuleManifest::clear_dependencies() {
  dependencies_.Clear();
}
inline std::string* DownloadableModuleManifest::add_dependencies() {
  std::string* _s = _internal_add_dependencies();
  // @@protoc_insertion_point(field_add_mutable:Valdi.DownloadableModuleManifest.dependencies)
  return _s;
}
inline const std::string& DownloadableModuleManifest::_internal_dependencies(int index) const {
  return dependencies_.Get(index);
}
inline const std::string& DownloadableModuleManifest::dependencies(int index) const {
  // @@protoc_insertion_point(field_get:Valdi.DownloadableModuleManifest.dependencies)
  return _internal_dependencies(index);
}
inline std::string* DownloadableModuleManifest::mutable_dependencies(int index) {
  // @@protoc_insertion_point(field_mutable:Valdi.DownloadableModuleManifest.dependencies)
  return dependencies_.Mutable(index);
}
inline void DownloadableModuleManifest::set_dependencies(int index, const std::string& value) {
  dependencies_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Valdi.DownloadableModuleManifest.dependencies)
}
inline void DownloadableModuleManifest::set_dependencies(int index, std::string&& value) {
  dependencies_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Valdi.DownloadableModuleManifest.dependencies)
}
inline void DownloadableModuleManifest::set_dependencies(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  dependencies_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Valdi.DownloadableModuleManifest.dependencies)
}
inline void DownloadableModuleManifest::set_dependencies(int index, const char* value, size_t size) {
  dependencies_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Valdi.DownloadableModuleManifest.dependencies)
}
inline std::string* DownloadableModuleManifest::_internal_add_dependencies() {
  return dependencies_.Add();
}
inline void DownloadableModuleManifest::add_dependencies(const std::string& value) {
  dependencies_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Valdi.DownloadableModuleManifest.dependencies)
}
inline void DownloadableModuleManifest::add_dependencies(std::string&& value) {
  dependencies_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Valdi.DownloadableModuleManifest.dependencies)
}
inline void DownloadableModuleManifest::add_dependencies(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  dependencies_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Valdi.DownloadableModuleManifest.dependencies)
}
inline void DownloadableModuleManifest::add_dependencies(const char* value, size_t size) {
  dependencies_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Valdi.DownloadableModuleManifest.dependencies)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DownloadableModuleManifest::dependencies() const {
  // @@protoc_insertion_point(field_list:Valdi.DownloadableModuleManifest.dependencies)
  return dependencies_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DownloadableModuleManifest::mutable_dependencies() {
  // @@protoc_insertion_point(field_mutable_list:Valdi.DownloadableModuleManifest.dependencies)
  return &dependencies_;
}

// bool has_local_assets = 5;
inline void DownloadableModuleManifest::clear_has_local_assets() {
  has_local_assets_ = false;
}
inline bool DownloadableModuleManifest::_internal_has_local_assets() const {
  return has_local_assets_;
}
inline bool DownloadableModuleManifest::has_local_assets() const {
  // @@protoc_insertion_point(field_get:Valdi.DownloadableModuleManifest.has_local_assets)
  return _internal_has_local_assets();
}
inline void DownloadableModuleManifest::_internal_set_has_local_assets(bool value) {
  
  has_local_assets_ = value;
}
inline void DownloadableModuleManifest::set_has_local_assets(bool value) {
  _internal_set_has_local_assets(value);
  // @@protoc_insertion_point(field_set:Valdi.DownloadableModuleManifest.has_local_assets)
}

// -------------------------------------------------------------------

// DaemonAwakeMessage

// repeated string device_ids = 16;
inline int DaemonAwakeMessage::_internal_device_ids_size() const {
  return device_ids_.size();
}
inline int DaemonAwakeMessage::device_ids_size() const {
  return _internal_device_ids_size();
}
inline void DaemonAwakeMessage::clear_device_ids() {
  device_ids_.Clear();
}
inline std::string* DaemonAwakeMessage::add_device_ids() {
  std::string* _s = _internal_add_device_ids();
  // @@protoc_insertion_point(field_add_mutable:Valdi.DaemonAwakeMessage.device_ids)
  return _s;
}
inline const std::string& DaemonAwakeMessage::_internal_device_ids(int index) const {
  return device_ids_.Get(index);
}
inline const std::string& DaemonAwakeMessage::device_ids(int index) const {
  // @@protoc_insertion_point(field_get:Valdi.DaemonAwakeMessage.device_ids)
  return _internal_device_ids(index);
}
inline std::string* DaemonAwakeMessage::mutable_device_ids(int index) {
  // @@protoc_insertion_point(field_mutable:Valdi.DaemonAwakeMessage.device_ids)
  return device_ids_.Mutable(index);
}
inline void DaemonAwakeMessage::set_device_ids(int index, const std::string& value) {
  device_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Valdi.DaemonAwakeMessage.device_ids)
}
inline void DaemonAwakeMessage::set_device_ids(int index, std::string&& value) {
  device_ids_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Valdi.DaemonAwakeMessage.device_ids)
}
inline void DaemonAwakeMessage::set_device_ids(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  device_ids_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Valdi.DaemonAwakeMessage.device_ids)
}
inline void DaemonAwakeMessage::set_device_ids(int index, const char* value, size_t size) {
  device_ids_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Valdi.DaemonAwakeMessage.device_ids)
}
inline std::string* DaemonAwakeMessage::_internal_add_device_ids() {
  return device_ids_.Add();
}
inline void DaemonAwakeMessage::add_device_ids(const std::string& value) {
  device_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Valdi.DaemonAwakeMessage.device_ids)
}
inline void DaemonAwakeMessage::add_device_ids(std::string&& value) {
  device_ids_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Valdi.DaemonAwakeMessage.device_ids)
}
inline void DaemonAwakeMessage::add_device_ids(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  device_ids_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Valdi.DaemonAwakeMessage.device_ids)
}
inline void DaemonAwakeMessage::add_device_ids(const char* value, size_t size) {
  device_ids_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Valdi.DaemonAwakeMessage.device_ids)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DaemonAwakeMessage::device_ids() const {
  // @@protoc_insertion_point(field_list:Valdi.DaemonAwakeMessage.device_ids)
  return device_ids_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DaemonAwakeMessage::mutable_device_ids() {
  // @@protoc_insertion_point(field_mutable_list:Valdi.DaemonAwakeMessage.device_ids)
  return &device_ids_;
}

// repeated string usernames = 17;
inline int DaemonAwakeMessage::_internal_usernames_size() const {
  return usernames_.size();
}
inline int DaemonAwakeMessage::usernames_size() const {
  return _internal_usernames_size();
}
inline void DaemonAwakeMessage::clear_usernames() {
  usernames_.Clear();
}
inline std::string* DaemonAwakeMessage::add_usernames() {
  std::string* _s = _internal_add_usernames();
  // @@protoc_insertion_point(field_add_mutable:Valdi.DaemonAwakeMessage.usernames)
  return _s;
}
inline const std::string& DaemonAwakeMessage::_internal_usernames(int index) const {
  return usernames_.Get(index);
}
inline const std::string& DaemonAwakeMessage::usernames(int index) const {
  // @@protoc_insertion_point(field_get:Valdi.DaemonAwakeMessage.usernames)
  return _internal_usernames(index);
}
inline std::string* DaemonAwakeMessage::mutable_usernames(int index) {
  // @@protoc_insertion_point(field_mutable:Valdi.DaemonAwakeMessage.usernames)
  return usernames_.Mutable(index);
}
inline void DaemonAwakeMessage::set_usernames(int index, const std::string& value) {
  usernames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Valdi.DaemonAwakeMessage.usernames)
}
inline void DaemonAwakeMessage::set_usernames(int index, std::string&& value) {
  usernames_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Valdi.DaemonAwakeMessage.usernames)
}
inline void DaemonAwakeMessage::set_usernames(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  usernames_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Valdi.DaemonAwakeMessage.usernames)
}
inline void DaemonAwakeMessage::set_usernames(int index, const char* value, size_t size) {
  usernames_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Valdi.DaemonAwakeMessage.usernames)
}
inline std::string* DaemonAwakeMessage::_internal_add_usernames() {
  return usernames_.Add();
}
inline void DaemonAwakeMessage::add_usernames(const std::string& value) {
  usernames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Valdi.DaemonAwakeMessage.usernames)
}
inline void DaemonAwakeMessage::add_usernames(std::string&& value) {
  usernames_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Valdi.DaemonAwakeMessage.usernames)
}
inline void DaemonAwakeMessage::add_usernames(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  usernames_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Valdi.DaemonAwakeMessage.usernames)
}
inline void DaemonAwakeMessage::add_usernames(const char* value, size_t size) {
  usernames_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Valdi.DaemonAwakeMessage.usernames)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DaemonAwakeMessage::usernames() const {
  // @@protoc_insertion_point(field_list:Valdi.DaemonAwakeMessage.usernames)
  return usernames_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DaemonAwakeMessage::mutable_usernames() {
  // @@protoc_insertion_point(field_mutable_list:Valdi.DaemonAwakeMessage.usernames)
  return &usernames_;
}

// repeated string service_addresses = 1;
inline int DaemonAwakeMessage::_internal_service_addresses_size() const {
  return service_addresses_.size();
}
inline int DaemonAwakeMessage::service_addresses_size() const {
  return _internal_service_addresses_size();
}
inline void DaemonAwakeMessage::clear_service_addresses() {
  service_addresses_.Clear();
}
inline std::string* DaemonAwakeMessage::add_service_addresses() {
  std::string* _s = _internal_add_service_addresses();
  // @@protoc_insertion_point(field_add_mutable:Valdi.DaemonAwakeMessage.service_addresses)
  return _s;
}
inline const std::string& DaemonAwakeMessage::_internal_service_addresses(int index) const {
  return service_addresses_.Get(index);
}
inline const std::string& DaemonAwakeMessage::service_addresses(int index) const {
  // @@protoc_insertion_point(field_get:Valdi.DaemonAwakeMessage.service_addresses)
  return _internal_service_addresses(index);
}
inline std::string* DaemonAwakeMessage::mutable_service_addresses(int index) {
  // @@protoc_insertion_point(field_mutable:Valdi.DaemonAwakeMessage.service_addresses)
  return service_addresses_.Mutable(index);
}
inline void DaemonAwakeMessage::set_service_addresses(int index, const std::string& value) {
  service_addresses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Valdi.DaemonAwakeMessage.service_addresses)
}
inline void DaemonAwakeMessage::set_service_addresses(int index, std::string&& value) {
  service_addresses_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Valdi.DaemonAwakeMessage.service_addresses)
}
inline void DaemonAwakeMessage::set_service_addresses(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  service_addresses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Valdi.DaemonAwakeMessage.service_addresses)
}
inline void DaemonAwakeMessage::set_service_addresses(int index, const char* value, size_t size) {
  service_addresses_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Valdi.DaemonAwakeMessage.service_addresses)
}
inline std::string* DaemonAwakeMessage::_internal_add_service_addresses() {
  return service_addresses_.Add();
}
inline void DaemonAwakeMessage::add_service_addresses(const std::string& value) {
  service_addresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Valdi.DaemonAwakeMessage.service_addresses)
}
inline void DaemonAwakeMessage::add_service_addresses(std::string&& value) {
  service_addresses_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Valdi.DaemonAwakeMessage.service_addresses)
}
inline void DaemonAwakeMessage::add_service_addresses(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  service_addresses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Valdi.DaemonAwakeMessage.service_addresses)
}
inline void DaemonAwakeMessage::add_service_addresses(const char* value, size_t size) {
  service_addresses_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Valdi.DaemonAwakeMessage.service_addresses)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
DaemonAwakeMessage::service_addresses() const {
  // @@protoc_insertion_point(field_list:Valdi.DaemonAwakeMessage.service_addresses)
  return service_addresses_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
DaemonAwakeMessage::mutable_service_addresses() {
  // @@protoc_insertion_point(field_mutable_list:Valdi.DaemonAwakeMessage.service_addresses)
  return &service_addresses_;
}

// int32 service_port = 2;
inline void DaemonAwakeMessage::clear_service_port() {
  service_port_ = 0;
}
inline int32_t DaemonAwakeMessage::_internal_service_port() const {
  return service_port_;
}
inline int32_t DaemonAwakeMessage::service_port() const {
  // @@protoc_insertion_point(field_get:Valdi.DaemonAwakeMessage.service_port)
  return _internal_service_port();
}
inline void DaemonAwakeMessage::_internal_set_service_port(int32_t value) {
  
  service_port_ = value;
}
inline void DaemonAwakeMessage::set_service_port(int32_t value) {
  _internal_set_service_port(value);
  // @@protoc_insertion_point(field_set:Valdi.DaemonAwakeMessage.service_port)
}

// string process_id = 3;
inline void DaemonAwakeMessage::clear_process_id() {
  process_id_.ClearToEmpty();
}
inline const std::string& DaemonAwakeMessage::process_id() const {
  // @@protoc_insertion_point(field_get:Valdi.DaemonAwakeMessage.process_id)
  return _internal_process_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void DaemonAwakeMessage::set_process_id(ArgT0&& arg0, ArgT... args) {
 
 process_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Valdi.DaemonAwakeMessage.process_id)
}
inline std::string* DaemonAwakeMessage::mutable_process_id() {
  std::string* _s = _internal_mutable_process_id();
  // @@protoc_insertion_point(field_mutable:Valdi.DaemonAwakeMessage.process_id)
  return _s;
}
inline const std::string& DaemonAwakeMessage::_internal_process_id() const {
  return process_id_.Get();
}
inline void DaemonAwakeMessage::_internal_set_process_id(const std::string& value) {
  
  process_id_.Set(value, GetArenaForAllocation());
}
inline std::string* DaemonAwakeMessage::_internal_mutable_process_id() {
  
  return process_id_.Mutable(GetArenaForAllocation());
}
inline std::string* DaemonAwakeMessage::release_process_id() {
  // @@protoc_insertion_point(field_release:Valdi.DaemonAwakeMessage.process_id)
  return process_id_.Release();
}
inline void DaemonAwakeMessage::set_allocated_process_id(std::string* process_id) {
  if (process_id != nullptr) {
    
  } else {
    
  }
  process_id_.SetAllocated(process_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (process_id_.IsDefault()) {
    process_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Valdi.DaemonAwakeMessage.process_id)
}

// -------------------------------------------------------------------

// ClientAwakeMessage

// string device_id = 1;
inline void ClientAwakeMessage::clear_device_id() {
  device_id_.ClearToEmpty();
}
inline const std::string& ClientAwakeMessage::device_id() const {
  // @@protoc_insertion_point(field_get:Valdi.ClientAwakeMessage.device_id)
  return _internal_device_id();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientAwakeMessage::set_device_id(ArgT0&& arg0, ArgT... args) {
 
 device_id_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Valdi.ClientAwakeMessage.device_id)
}
inline std::string* ClientAwakeMessage::mutable_device_id() {
  std::string* _s = _internal_mutable_device_id();
  // @@protoc_insertion_point(field_mutable:Valdi.ClientAwakeMessage.device_id)
  return _s;
}
inline const std::string& ClientAwakeMessage::_internal_device_id() const {
  return device_id_.Get();
}
inline void ClientAwakeMessage::_internal_set_device_id(const std::string& value) {
  
  device_id_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientAwakeMessage::_internal_mutable_device_id() {
  
  return device_id_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientAwakeMessage::release_device_id() {
  // @@protoc_insertion_point(field_release:Valdi.ClientAwakeMessage.device_id)
  return device_id_.Release();
}
inline void ClientAwakeMessage::set_allocated_device_id(std::string* device_id) {
  if (device_id != nullptr) {
    
  } else {
    
  }
  device_id_.SetAllocated(device_id, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (device_id_.IsDefault()) {
    device_id_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Valdi.ClientAwakeMessage.device_id)
}

// string username = 2;
inline void ClientAwakeMessage::clear_username() {
  username_.ClearToEmpty();
}
inline const std::string& ClientAwakeMessage::username() const {
  // @@protoc_insertion_point(field_get:Valdi.ClientAwakeMessage.username)
  return _internal_username();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void ClientAwakeMessage::set_username(ArgT0&& arg0, ArgT... args) {
 
 username_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Valdi.ClientAwakeMessage.username)
}
inline std::string* ClientAwakeMessage::mutable_username() {
  std::string* _s = _internal_mutable_username();
  // @@protoc_insertion_point(field_mutable:Valdi.ClientAwakeMessage.username)
  return _s;
}
inline const std::string& ClientAwakeMessage::_internal_username() const {
  return username_.Get();
}
inline void ClientAwakeMessage::_internal_set_username(const std::string& value) {
  
  username_.Set(value, GetArenaForAllocation());
}
inline std::string* ClientAwakeMessage::_internal_mutable_username() {
  
  return username_.Mutable(GetArenaForAllocation());
}
inline std::string* ClientAwakeMessage::release_username() {
  // @@protoc_insertion_point(field_release:Valdi.ClientAwakeMessage.username)
  return username_.Release();
}
inline void ClientAwakeMessage::set_allocated_username(std::string* username) {
  if (username != nullptr) {
    
  } else {
    
  }
  username_.SetAllocated(username, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (username_.IsDefault()) {
    username_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Valdi.ClientAwakeMessage.username)
}

// -------------------------------------------------------------------

// DaemonServiceDiscoveryPayload

// .Valdi.DaemonAwakeMessage daemon_awake_message = 1;
inline bool DaemonServiceDiscoveryPayload::_internal_has_daemon_awake_message() const {
  return message_case() == kDaemonAwakeMessage;
}
inline bool DaemonServiceDiscoveryPayload::has_daemon_awake_message() const {
  return _internal_has_daemon_awake_message();
}
inline void DaemonServiceDiscoveryPayload::set_has_daemon_awake_message() {
  _oneof_case_[0] = kDaemonAwakeMessage;
}
inline void DaemonServiceDiscoveryPayload::clear_daemon_awake_message() {
  if (_internal_has_daemon_awake_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.daemon_awake_message_;
    }
    clear_has_message();
  }
}
inline ::Valdi::DaemonAwakeMessage* DaemonServiceDiscoveryPayload::release_daemon_awake_message() {
  // @@protoc_insertion_point(field_release:Valdi.DaemonServiceDiscoveryPayload.daemon_awake_message)
  if (_internal_has_daemon_awake_message()) {
    clear_has_message();
    ::Valdi::DaemonAwakeMessage* temp = message_.daemon_awake_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.daemon_awake_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Valdi::DaemonAwakeMessage& DaemonServiceDiscoveryPayload::_internal_daemon_awake_message() const {
  return _internal_has_daemon_awake_message()
      ? *message_.daemon_awake_message_
      : reinterpret_cast< ::Valdi::DaemonAwakeMessage&>(::Valdi::_DaemonAwakeMessage_default_instance_);
}
inline const ::Valdi::DaemonAwakeMessage& DaemonServiceDiscoveryPayload::daemon_awake_message() const {
  // @@protoc_insertion_point(field_get:Valdi.DaemonServiceDiscoveryPayload.daemon_awake_message)
  return _internal_daemon_awake_message();
}
inline ::Valdi::DaemonAwakeMessage* DaemonServiceDiscoveryPayload::unsafe_arena_release_daemon_awake_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Valdi.DaemonServiceDiscoveryPayload.daemon_awake_message)
  if (_internal_has_daemon_awake_message()) {
    clear_has_message();
    ::Valdi::DaemonAwakeMessage* temp = message_.daemon_awake_message_;
    message_.daemon_awake_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DaemonServiceDiscoveryPayload::unsafe_arena_set_allocated_daemon_awake_message(::Valdi::DaemonAwakeMessage* daemon_awake_message) {
  clear_message();
  if (daemon_awake_message) {
    set_has_daemon_awake_message();
    message_.daemon_awake_message_ = daemon_awake_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Valdi.DaemonServiceDiscoveryPayload.daemon_awake_message)
}
inline ::Valdi::DaemonAwakeMessage* DaemonServiceDiscoveryPayload::_internal_mutable_daemon_awake_message() {
  if (!_internal_has_daemon_awake_message()) {
    clear_message();
    set_has_daemon_awake_message();
    message_.daemon_awake_message_ = CreateMaybeMessage< ::Valdi::DaemonAwakeMessage >(GetArenaForAllocation());
  }
  return message_.daemon_awake_message_;
}
inline ::Valdi::DaemonAwakeMessage* DaemonServiceDiscoveryPayload::mutable_daemon_awake_message() {
  ::Valdi::DaemonAwakeMessage* _msg = _internal_mutable_daemon_awake_message();
  // @@protoc_insertion_point(field_mutable:Valdi.DaemonServiceDiscoveryPayload.daemon_awake_message)
  return _msg;
}

// .Valdi.ClientAwakeMessage client_awake_message = 2;
inline bool DaemonServiceDiscoveryPayload::_internal_has_client_awake_message() const {
  return message_case() == kClientAwakeMessage;
}
inline bool DaemonServiceDiscoveryPayload::has_client_awake_message() const {
  return _internal_has_client_awake_message();
}
inline void DaemonServiceDiscoveryPayload::set_has_client_awake_message() {
  _oneof_case_[0] = kClientAwakeMessage;
}
inline void DaemonServiceDiscoveryPayload::clear_client_awake_message() {
  if (_internal_has_client_awake_message()) {
    if (GetArenaForAllocation() == nullptr) {
      delete message_.client_awake_message_;
    }
    clear_has_message();
  }
}
inline ::Valdi::ClientAwakeMessage* DaemonServiceDiscoveryPayload::release_client_awake_message() {
  // @@protoc_insertion_point(field_release:Valdi.DaemonServiceDiscoveryPayload.client_awake_message)
  if (_internal_has_client_awake_message()) {
    clear_has_message();
    ::Valdi::ClientAwakeMessage* temp = message_.client_awake_message_;
    if (GetArenaForAllocation() != nullptr) {
      temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
    }
    message_.client_awake_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline const ::Valdi::ClientAwakeMessage& DaemonServiceDiscoveryPayload::_internal_client_awake_message() const {
  return _internal_has_client_awake_message()
      ? *message_.client_awake_message_
      : reinterpret_cast< ::Valdi::ClientAwakeMessage&>(::Valdi::_ClientAwakeMessage_default_instance_);
}
inline const ::Valdi::ClientAwakeMessage& DaemonServiceDiscoveryPayload::client_awake_message() const {
  // @@protoc_insertion_point(field_get:Valdi.DaemonServiceDiscoveryPayload.client_awake_message)
  return _internal_client_awake_message();
}
inline ::Valdi::ClientAwakeMessage* DaemonServiceDiscoveryPayload::unsafe_arena_release_client_awake_message() {
  // @@protoc_insertion_point(field_unsafe_arena_release:Valdi.DaemonServiceDiscoveryPayload.client_awake_message)
  if (_internal_has_client_awake_message()) {
    clear_has_message();
    ::Valdi::ClientAwakeMessage* temp = message_.client_awake_message_;
    message_.client_awake_message_ = nullptr;
    return temp;
  } else {
    return nullptr;
  }
}
inline void DaemonServiceDiscoveryPayload::unsafe_arena_set_allocated_client_awake_message(::Valdi::ClientAwakeMessage* client_awake_message) {
  clear_message();
  if (client_awake_message) {
    set_has_client_awake_message();
    message_.client_awake_message_ = client_awake_message;
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Valdi.DaemonServiceDiscoveryPayload.client_awake_message)
}
inline ::Valdi::ClientAwakeMessage* DaemonServiceDiscoveryPayload::_internal_mutable_client_awake_message() {
  if (!_internal_has_client_awake_message()) {
    clear_message();
    set_has_client_awake_message();
    message_.client_awake_message_ = CreateMaybeMessage< ::Valdi::ClientAwakeMessage >(GetArenaForAllocation());
  }
  return message_.client_awake_message_;
}
inline ::Valdi::ClientAwakeMessage* DaemonServiceDiscoveryPayload::mutable_client_awake_message() {
  ::Valdi::ClientAwakeMessage* _msg = _internal_mutable_client_awake_message();
  // @@protoc_insertion_point(field_mutable:Valdi.DaemonServiceDiscoveryPayload.client_awake_message)
  return _msg;
}

inline bool DaemonServiceDiscoveryPayload::has_message() const {
  return message_case() != MESSAGE_NOT_SET;
}
inline void DaemonServiceDiscoveryPayload::clear_has_message() {
  _oneof_case_[0] = MESSAGE_NOT_SET;
}
inline DaemonServiceDiscoveryPayload::MessageCase DaemonServiceDiscoveryPayload::message_case() const {
  return DaemonServiceDiscoveryPayload::MessageCase(_oneof_case_[0]);
}
// -------------------------------------------------------------------

// StyleNode

// repeated .Valdi.StyleDeclaration styles = 1;
inline int StyleNode::_internal_styles_size() const {
  return styles_.size();
}
inline int StyleNode::styles_size() const {
  return _internal_styles_size();
}
inline void StyleNode::clear_styles() {
  styles_.Clear();
}
inline ::Valdi::StyleDeclaration* StyleNode::mutable_styles(int index) {
  // @@protoc_insertion_point(field_mutable:Valdi.StyleNode.styles)
  return styles_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Valdi::StyleDeclaration >*
StyleNode::mutable_styles() {
  // @@protoc_insertion_point(field_mutable_list:Valdi.StyleNode.styles)
  return &styles_;
}
inline const ::Valdi::StyleDeclaration& StyleNode::_internal_styles(int index) const {
  return styles_.Get(index);
}
inline const ::Valdi::StyleDeclaration& StyleNode::styles(int index) const {
  // @@protoc_insertion_point(field_get:Valdi.StyleNode.styles)
  return _internal_styles(index);
}
inline ::Valdi::StyleDeclaration* StyleNode::_internal_add_styles() {
  return styles_.Add();
}
inline ::Valdi::StyleDeclaration* StyleNode::add_styles() {
  ::Valdi::StyleDeclaration* _add = _internal_add_styles();
  // @@protoc_insertion_point(field_add:Valdi.StyleNode.styles)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Valdi::StyleDeclaration >&
StyleNode::styles() const {
  // @@protoc_insertion_point(field_list:Valdi.StyleNode.styles)
  return styles_;
}

// .Valdi.CSSRuleIndex ruleIndex = 2;
inline bool StyleNode::_internal_has_ruleindex() const {
  return this != internal_default_instance() && ruleindex_ != nullptr;
}
inline bool StyleNode::has_ruleindex() const {
  return _internal_has_ruleindex();
}
inline void StyleNode::clear_ruleindex() {
  if (GetArenaForAllocation() == nullptr && ruleindex_ != nullptr) {
    delete ruleindex_;
  }
  ruleindex_ = nullptr;
}
inline const ::Valdi::CSSRuleIndex& StyleNode::_internal_ruleindex() const {
  const ::Valdi::CSSRuleIndex* p = ruleindex_;
  return p != nullptr ? *p : reinterpret_cast<const ::Valdi::CSSRuleIndex&>(
      ::Valdi::_CSSRuleIndex_default_instance_);
}
inline const ::Valdi::CSSRuleIndex& StyleNode::ruleindex() const {
  // @@protoc_insertion_point(field_get:Valdi.StyleNode.ruleIndex)
  return _internal_ruleindex();
}
inline void StyleNode::unsafe_arena_set_allocated_ruleindex(
    ::Valdi::CSSRuleIndex* ruleindex) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ruleindex_);
  }
  ruleindex_ = ruleindex;
  if (ruleindex) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Valdi.StyleNode.ruleIndex)
}
inline ::Valdi::CSSRuleIndex* StyleNode::release_ruleindex() {
  
  ::Valdi::CSSRuleIndex* temp = ruleindex_;
  ruleindex_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Valdi::CSSRuleIndex* StyleNode::unsafe_arena_release_ruleindex() {
  // @@protoc_insertion_point(field_release:Valdi.StyleNode.ruleIndex)
  
  ::Valdi::CSSRuleIndex* temp = ruleindex_;
  ruleindex_ = nullptr;
  return temp;
}
inline ::Valdi::CSSRuleIndex* StyleNode::_internal_mutable_ruleindex() {
  
  if (ruleindex_ == nullptr) {
    auto* p = CreateMaybeMessage<::Valdi::CSSRuleIndex>(GetArenaForAllocation());
    ruleindex_ = p;
  }
  return ruleindex_;
}
inline ::Valdi::CSSRuleIndex* StyleNode::mutable_ruleindex() {
  ::Valdi::CSSRuleIndex* _msg = _internal_mutable_ruleindex();
  // @@protoc_insertion_point(field_mutable:Valdi.StyleNode.ruleIndex)
  return _msg;
}
inline void StyleNode::set_allocated_ruleindex(::Valdi::CSSRuleIndex* ruleindex) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete ruleindex_;
  }
  if (ruleindex) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ruleindex);
    if (message_arena != submessage_arena) {
      ruleindex = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ruleindex, submessage_arena);
    }
    
  } else {
    
  }
  ruleindex_ = ruleindex;
  // @@protoc_insertion_point(field_set_allocated:Valdi.StyleNode.ruleIndex)
}

// -------------------------------------------------------------------

// StyleDeclaration

// .Valdi.NodeAttribute attribute = 1;
inline bool StyleDeclaration::_internal_has_attribute() const {
  return this != internal_default_instance() && attribute_ != nullptr;
}
inline bool StyleDeclaration::has_attribute() const {
  return _internal_has_attribute();
}
inline void StyleDeclaration::clear_attribute() {
  if (GetArenaForAllocation() == nullptr && attribute_ != nullptr) {
    delete attribute_;
  }
  attribute_ = nullptr;
}
inline const ::Valdi::NodeAttribute& StyleDeclaration::_internal_attribute() const {
  const ::Valdi::NodeAttribute* p = attribute_;
  return p != nullptr ? *p : reinterpret_cast<const ::Valdi::NodeAttribute&>(
      ::Valdi::_NodeAttribute_default_instance_);
}
inline const ::Valdi::NodeAttribute& StyleDeclaration::attribute() const {
  // @@protoc_insertion_point(field_get:Valdi.StyleDeclaration.attribute)
  return _internal_attribute();
}
inline void StyleDeclaration::unsafe_arena_set_allocated_attribute(
    ::Valdi::NodeAttribute* attribute) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(attribute_);
  }
  attribute_ = attribute;
  if (attribute) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Valdi.StyleDeclaration.attribute)
}
inline ::Valdi::NodeAttribute* StyleDeclaration::release_attribute() {
  
  ::Valdi::NodeAttribute* temp = attribute_;
  attribute_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Valdi::NodeAttribute* StyleDeclaration::unsafe_arena_release_attribute() {
  // @@protoc_insertion_point(field_release:Valdi.StyleDeclaration.attribute)
  
  ::Valdi::NodeAttribute* temp = attribute_;
  attribute_ = nullptr;
  return temp;
}
inline ::Valdi::NodeAttribute* StyleDeclaration::_internal_mutable_attribute() {
  
  if (attribute_ == nullptr) {
    auto* p = CreateMaybeMessage<::Valdi::NodeAttribute>(GetArenaForAllocation());
    attribute_ = p;
  }
  return attribute_;
}
inline ::Valdi::NodeAttribute* StyleDeclaration::mutable_attribute() {
  ::Valdi::NodeAttribute* _msg = _internal_mutable_attribute();
  // @@protoc_insertion_point(field_mutable:Valdi.StyleDeclaration.attribute)
  return _msg;
}
inline void StyleDeclaration::set_allocated_attribute(::Valdi::NodeAttribute* attribute) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete attribute_;
  }
  if (attribute) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(attribute);
    if (message_arena != submessage_arena) {
      attribute = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attribute, submessage_arena);
    }
    
  } else {
    
  }
  attribute_ = attribute;
  // @@protoc_insertion_point(field_set_allocated:Valdi.StyleDeclaration.attribute)
}

// int32 priority = 2;
inline void StyleDeclaration::clear_priority() {
  priority_ = 0;
}
inline int32_t StyleDeclaration::_internal_priority() const {
  return priority_;
}
inline int32_t StyleDeclaration::priority() const {
  // @@protoc_insertion_point(field_get:Valdi.StyleDeclaration.priority)
  return _internal_priority();
}
inline void StyleDeclaration::_internal_set_priority(int32_t value) {
  
  priority_ = value;
}
inline void StyleDeclaration::set_priority(int32_t value) {
  _internal_set_priority(value);
  // @@protoc_insertion_point(field_set:Valdi.StyleDeclaration.priority)
}

// int32 order = 3;
inline void StyleDeclaration::clear_order() {
  order_ = 0;
}
inline int32_t StyleDeclaration::_internal_order() const {
  return order_;
}
inline int32_t StyleDeclaration::order() const {
  // @@protoc_insertion_point(field_get:Valdi.StyleDeclaration.order)
  return _internal_order();
}
inline void StyleDeclaration::_internal_set_order(int32_t value) {
  
  order_ = value;
}
inline void StyleDeclaration::set_order(int32_t value) {
  _internal_set_order(value);
  // @@protoc_insertion_point(field_set:Valdi.StyleDeclaration.order)
}

// int32 id = 4;
inline void StyleDeclaration::clear_id() {
  id_ = 0;
}
inline int32_t StyleDeclaration::_internal_id() const {
  return id_;
}
inline int32_t StyleDeclaration::id() const {
  // @@protoc_insertion_point(field_get:Valdi.StyleDeclaration.id)
  return _internal_id();
}
inline void StyleDeclaration::_internal_set_id(int32_t value) {
  
  id_ = value;
}
inline void StyleDeclaration::set_id(int32_t value) {
  _internal_set_id(value);
  // @@protoc_insertion_point(field_set:Valdi.StyleDeclaration.id)
}

// -------------------------------------------------------------------

// NamedStyleNode

// string name = 1;
inline void NamedStyleNode::clear_name() {
  name_.ClearToEmpty();
}
inline const std::string& NamedStyleNode::name() const {
  // @@protoc_insertion_point(field_get:Valdi.NamedStyleNode.name)
  return _internal_name();
}
template <typename ArgT0, typename... ArgT>
inline PROTOBUF_ALWAYS_INLINE
void NamedStyleNode::set_name(ArgT0&& arg0, ArgT... args) {
 
 name_.Set(static_cast<ArgT0 &&>(arg0), args..., GetArenaForAllocation());
  // @@protoc_insertion_point(field_set:Valdi.NamedStyleNode.name)
}
inline std::string* NamedStyleNode::mutable_name() {
  std::string* _s = _internal_mutable_name();
  // @@protoc_insertion_point(field_mutable:Valdi.NamedStyleNode.name)
  return _s;
}
inline const std::string& NamedStyleNode::_internal_name() const {
  return name_.Get();
}
inline void NamedStyleNode::_internal_set_name(const std::string& value) {
  
  name_.Set(value, GetArenaForAllocation());
}
inline std::string* NamedStyleNode::_internal_mutable_name() {
  
  return name_.Mutable(GetArenaForAllocation());
}
inline std::string* NamedStyleNode::release_name() {
  // @@protoc_insertion_point(field_release:Valdi.NamedStyleNode.name)
  return name_.Release();
}
inline void NamedStyleNode::set_allocated_name(std::string* name) {
  if (name != nullptr) {
    
  } else {
    
  }
  name_.SetAllocated(name, GetArenaForAllocation());
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (name_.IsDefault()) {
    name_.Set("", GetArenaForAllocation());
  }
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  // @@protoc_insertion_point(field_set_allocated:Valdi.NamedStyleNode.name)
}

// .Valdi.StyleNode node = 2;
inline bool NamedStyleNode::_internal_has_node() const {
  return this != internal_default_instance() && node_ != nullptr;
}
inline bool NamedStyleNode::has_node() const {
  return _internal_has_node();
}
inline void NamedStyleNode::clear_node() {
  if (GetArenaForAllocation() == nullptr && node_ != nullptr) {
    delete node_;
  }
  node_ = nullptr;
}
inline const ::Valdi::StyleNode& NamedStyleNode::_internal_node() const {
  const ::Valdi::StyleNode* p = node_;
  return p != nullptr ? *p : reinterpret_cast<const ::Valdi::StyleNode&>(
      ::Valdi::_StyleNode_default_instance_);
}
inline const ::Valdi::StyleNode& NamedStyleNode::node() const {
  // @@protoc_insertion_point(field_get:Valdi.NamedStyleNode.node)
  return _internal_node();
}
inline void NamedStyleNode::unsafe_arena_set_allocated_node(
    ::Valdi::StyleNode* node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(node_);
  }
  node_ = node;
  if (node) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Valdi.NamedStyleNode.node)
}
inline ::Valdi::StyleNode* NamedStyleNode::release_node() {
  
  ::Valdi::StyleNode* temp = node_;
  node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Valdi::StyleNode* NamedStyleNode::unsafe_arena_release_node() {
  // @@protoc_insertion_point(field_release:Valdi.NamedStyleNode.node)
  
  ::Valdi::StyleNode* temp = node_;
  node_ = nullptr;
  return temp;
}
inline ::Valdi::StyleNode* NamedStyleNode::_internal_mutable_node() {
  
  if (node_ == nullptr) {
    auto* p = CreateMaybeMessage<::Valdi::StyleNode>(GetArenaForAllocation());
    node_ = p;
  }
  return node_;
}
inline ::Valdi::StyleNode* NamedStyleNode::mutable_node() {
  ::Valdi::StyleNode* _msg = _internal_mutable_node();
  // @@protoc_insertion_point(field_mutable:Valdi.NamedStyleNode.node)
  return _msg;
}
inline void NamedStyleNode::set_allocated_node(::Valdi::StyleNode* node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete node_;
  }
  if (node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(node);
    if (message_arena != submessage_arena) {
      node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, node, submessage_arena);
    }
    
  } else {
    
  }
  node_ = node;
  // @@protoc_insertion_point(field_set_allocated:Valdi.NamedStyleNode.node)
}

// -------------------------------------------------------------------

// CSSRuleIndex_AttributeRule

// .Valdi.CSSRuleIndex.AttributeRule.Type type = 1;
inline void CSSRuleIndex_AttributeRule::clear_type() {
  type_ = 0;
}
inline ::Valdi::CSSRuleIndex_AttributeRule_Type CSSRuleIndex_AttributeRule::_internal_type() const {
  return static_cast< ::Valdi::CSSRuleIndex_AttributeRule_Type >(type_);
}
inline ::Valdi::CSSRuleIndex_AttributeRule_Type CSSRuleIndex_AttributeRule::type() const {
  // @@protoc_insertion_point(field_get:Valdi.CSSRuleIndex.AttributeRule.type)
  return _internal_type();
}
inline void CSSRuleIndex_AttributeRule::_internal_set_type(::Valdi::CSSRuleIndex_AttributeRule_Type value) {
  
  type_ = value;
}
inline void CSSRuleIndex_AttributeRule::set_type(::Valdi::CSSRuleIndex_AttributeRule_Type value) {
  _internal_set_type(value);
  // @@protoc_insertion_point(field_set:Valdi.CSSRuleIndex.AttributeRule.type)
}

// .Valdi.NodeAttribute attribute = 2;
inline bool CSSRuleIndex_AttributeRule::_internal_has_attribute() const {
  return this != internal_default_instance() && attribute_ != nullptr;
}
inline bool CSSRuleIndex_AttributeRule::has_attribute() const {
  return _internal_has_attribute();
}
inline void CSSRuleIndex_AttributeRule::clear_attribute() {
  if (GetArenaForAllocation() == nullptr && attribute_ != nullptr) {
    delete attribute_;
  }
  attribute_ = nullptr;
}
inline const ::Valdi::NodeAttribute& CSSRuleIndex_AttributeRule::_internal_attribute() const {
  const ::Valdi::NodeAttribute* p = attribute_;
  return p != nullptr ? *p : reinterpret_cast<const ::Valdi::NodeAttribute&>(
      ::Valdi::_NodeAttribute_default_instance_);
}
inline const ::Valdi::NodeAttribute& CSSRuleIndex_AttributeRule::attribute() const {
  // @@protoc_insertion_point(field_get:Valdi.CSSRuleIndex.AttributeRule.attribute)
  return _internal_attribute();
}
inline void CSSRuleIndex_AttributeRule::unsafe_arena_set_allocated_attribute(
    ::Valdi::NodeAttribute* attribute) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(attribute_);
  }
  attribute_ = attribute;
  if (attribute) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Valdi.CSSRuleIndex.AttributeRule.attribute)
}
inline ::Valdi::NodeAttribute* CSSRuleIndex_AttributeRule::release_attribute() {
  
  ::Valdi::NodeAttribute* temp = attribute_;
  attribute_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Valdi::NodeAttribute* CSSRuleIndex_AttributeRule::unsafe_arena_release_attribute() {
  // @@protoc_insertion_point(field_release:Valdi.CSSRuleIndex.AttributeRule.attribute)
  
  ::Valdi::NodeAttribute* temp = attribute_;
  attribute_ = nullptr;
  return temp;
}
inline ::Valdi::NodeAttribute* CSSRuleIndex_AttributeRule::_internal_mutable_attribute() {
  
  if (attribute_ == nullptr) {
    auto* p = CreateMaybeMessage<::Valdi::NodeAttribute>(GetArenaForAllocation());
    attribute_ = p;
  }
  return attribute_;
}
inline ::Valdi::NodeAttribute* CSSRuleIndex_AttributeRule::mutable_attribute() {
  ::Valdi::NodeAttribute* _msg = _internal_mutable_attribute();
  // @@protoc_insertion_point(field_mutable:Valdi.CSSRuleIndex.AttributeRule.attribute)
  return _msg;
}
inline void CSSRuleIndex_AttributeRule::set_allocated_attribute(::Valdi::NodeAttribute* attribute) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete attribute_;
  }
  if (attribute) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(attribute);
    if (message_arena != submessage_arena) {
      attribute = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, attribute, submessage_arena);
    }
    
  } else {
    
  }
  attribute_ = attribute;
  // @@protoc_insertion_point(field_set_allocated:Valdi.CSSRuleIndex.AttributeRule.attribute)
}

// .Valdi.StyleNode node = 3;
inline bool CSSRuleIndex_AttributeRule::_internal_has_node() const {
  return this != internal_default_instance() && node_ != nullptr;
}
inline bool CSSRuleIndex_AttributeRule::has_node() const {
  return _internal_has_node();
}
inline void CSSRuleIndex_AttributeRule::clear_node() {
  if (GetArenaForAllocation() == nullptr && node_ != nullptr) {
    delete node_;
  }
  node_ = nullptr;
}
inline const ::Valdi::StyleNode& CSSRuleIndex_AttributeRule::_internal_node() const {
  const ::Valdi::StyleNode* p = node_;
  return p != nullptr ? *p : reinterpret_cast<const ::Valdi::StyleNode&>(
      ::Valdi::_StyleNode_default_instance_);
}
inline const ::Valdi::StyleNode& CSSRuleIndex_AttributeRule::node() const {
  // @@protoc_insertion_point(field_get:Valdi.CSSRuleIndex.AttributeRule.node)
  return _internal_node();
}
inline void CSSRuleIndex_AttributeRule::unsafe_arena_set_allocated_node(
    ::Valdi::StyleNode* node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(node_);
  }
  node_ = node;
  if (node) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Valdi.CSSRuleIndex.AttributeRule.node)
}
inline ::Valdi::StyleNode* CSSRuleIndex_AttributeRule::release_node() {
  
  ::Valdi::StyleNode* temp = node_;
  node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Valdi::StyleNode* CSSRuleIndex_AttributeRule::unsafe_arena_release_node() {
  // @@protoc_insertion_point(field_release:Valdi.CSSRuleIndex.AttributeRule.node)
  
  ::Valdi::StyleNode* temp = node_;
  node_ = nullptr;
  return temp;
}
inline ::Valdi::StyleNode* CSSRuleIndex_AttributeRule::_internal_mutable_node() {
  
  if (node_ == nullptr) {
    auto* p = CreateMaybeMessage<::Valdi::StyleNode>(GetArenaForAllocation());
    node_ = p;
  }
  return node_;
}
inline ::Valdi::StyleNode* CSSRuleIndex_AttributeRule::mutable_node() {
  ::Valdi::StyleNode* _msg = _internal_mutable_node();
  // @@protoc_insertion_point(field_mutable:Valdi.CSSRuleIndex.AttributeRule.node)
  return _msg;
}
inline void CSSRuleIndex_AttributeRule::set_allocated_node(::Valdi::StyleNode* node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete node_;
  }
  if (node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(node);
    if (message_arena != submessage_arena) {
      node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, node, submessage_arena);
    }
    
  } else {
    
  }
  node_ = node;
  // @@protoc_insertion_point(field_set_allocated:Valdi.CSSRuleIndex.AttributeRule.node)
}

// -------------------------------------------------------------------

// CSSRuleIndex_NthChildRule

// int32 n = 1;
inline void CSSRuleIndex_NthChildRule::clear_n() {
  n_ = 0;
}
inline int32_t CSSRuleIndex_NthChildRule::_internal_n() const {
  return n_;
}
inline int32_t CSSRuleIndex_NthChildRule::n() const {
  // @@protoc_insertion_point(field_get:Valdi.CSSRuleIndex.NthChildRule.n)
  return _internal_n();
}
inline void CSSRuleIndex_NthChildRule::_internal_set_n(int32_t value) {
  
  n_ = value;
}
inline void CSSRuleIndex_NthChildRule::set_n(int32_t value) {
  _internal_set_n(value);
  // @@protoc_insertion_point(field_set:Valdi.CSSRuleIndex.NthChildRule.n)
}

// int32 offset = 2;
inline void CSSRuleIndex_NthChildRule::clear_offset() {
  offset_ = 0;
}
inline int32_t CSSRuleIndex_NthChildRule::_internal_offset() const {
  return offset_;
}
inline int32_t CSSRuleIndex_NthChildRule::offset() const {
  // @@protoc_insertion_point(field_get:Valdi.CSSRuleIndex.NthChildRule.offset)
  return _internal_offset();
}
inline void CSSRuleIndex_NthChildRule::_internal_set_offset(int32_t value) {
  
  offset_ = value;
}
inline void CSSRuleIndex_NthChildRule::set_offset(int32_t value) {
  _internal_set_offset(value);
  // @@protoc_insertion_point(field_set:Valdi.CSSRuleIndex.NthChildRule.offset)
}

// .Valdi.StyleNode node = 3;
inline bool CSSRuleIndex_NthChildRule::_internal_has_node() const {
  return this != internal_default_instance() && node_ != nullptr;
}
inline bool CSSRuleIndex_NthChildRule::has_node() const {
  return _internal_has_node();
}
inline void CSSRuleIndex_NthChildRule::clear_node() {
  if (GetArenaForAllocation() == nullptr && node_ != nullptr) {
    delete node_;
  }
  node_ = nullptr;
}
inline const ::Valdi::StyleNode& CSSRuleIndex_NthChildRule::_internal_node() const {
  const ::Valdi::StyleNode* p = node_;
  return p != nullptr ? *p : reinterpret_cast<const ::Valdi::StyleNode&>(
      ::Valdi::_StyleNode_default_instance_);
}
inline const ::Valdi::StyleNode& CSSRuleIndex_NthChildRule::node() const {
  // @@protoc_insertion_point(field_get:Valdi.CSSRuleIndex.NthChildRule.node)
  return _internal_node();
}
inline void CSSRuleIndex_NthChildRule::unsafe_arena_set_allocated_node(
    ::Valdi::StyleNode* node) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(node_);
  }
  node_ = node;
  if (node) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Valdi.CSSRuleIndex.NthChildRule.node)
}
inline ::Valdi::StyleNode* CSSRuleIndex_NthChildRule::release_node() {
  
  ::Valdi::StyleNode* temp = node_;
  node_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Valdi::StyleNode* CSSRuleIndex_NthChildRule::unsafe_arena_release_node() {
  // @@protoc_insertion_point(field_release:Valdi.CSSRuleIndex.NthChildRule.node)
  
  ::Valdi::StyleNode* temp = node_;
  node_ = nullptr;
  return temp;
}
inline ::Valdi::StyleNode* CSSRuleIndex_NthChildRule::_internal_mutable_node() {
  
  if (node_ == nullptr) {
    auto* p = CreateMaybeMessage<::Valdi::StyleNode>(GetArenaForAllocation());
    node_ = p;
  }
  return node_;
}
inline ::Valdi::StyleNode* CSSRuleIndex_NthChildRule::mutable_node() {
  ::Valdi::StyleNode* _msg = _internal_mutable_node();
  // @@protoc_insertion_point(field_mutable:Valdi.CSSRuleIndex.NthChildRule.node)
  return _msg;
}
inline void CSSRuleIndex_NthChildRule::set_allocated_node(::Valdi::StyleNode* node) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete node_;
  }
  if (node) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(node);
    if (message_arena != submessage_arena) {
      node = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, node, submessage_arena);
    }
    
  } else {
    
  }
  node_ = node;
  // @@protoc_insertion_point(field_set_allocated:Valdi.CSSRuleIndex.NthChildRule.node)
}

// -------------------------------------------------------------------

// CSSRuleIndex

// repeated .Valdi.NamedStyleNode id_rules = 1;
inline int CSSRuleIndex::_internal_id_rules_size() const {
  return id_rules_.size();
}
inline int CSSRuleIndex::id_rules_size() const {
  return _internal_id_rules_size();
}
inline void CSSRuleIndex::clear_id_rules() {
  id_rules_.Clear();
}
inline ::Valdi::NamedStyleNode* CSSRuleIndex::mutable_id_rules(int index) {
  // @@protoc_insertion_point(field_mutable:Valdi.CSSRuleIndex.id_rules)
  return id_rules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Valdi::NamedStyleNode >*
CSSRuleIndex::mutable_id_rules() {
  // @@protoc_insertion_point(field_mutable_list:Valdi.CSSRuleIndex.id_rules)
  return &id_rules_;
}
inline const ::Valdi::NamedStyleNode& CSSRuleIndex::_internal_id_rules(int index) const {
  return id_rules_.Get(index);
}
inline const ::Valdi::NamedStyleNode& CSSRuleIndex::id_rules(int index) const {
  // @@protoc_insertion_point(field_get:Valdi.CSSRuleIndex.id_rules)
  return _internal_id_rules(index);
}
inline ::Valdi::NamedStyleNode* CSSRuleIndex::_internal_add_id_rules() {
  return id_rules_.Add();
}
inline ::Valdi::NamedStyleNode* CSSRuleIndex::add_id_rules() {
  ::Valdi::NamedStyleNode* _add = _internal_add_id_rules();
  // @@protoc_insertion_point(field_add:Valdi.CSSRuleIndex.id_rules)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Valdi::NamedStyleNode >&
CSSRuleIndex::id_rules() const {
  // @@protoc_insertion_point(field_list:Valdi.CSSRuleIndex.id_rules)
  return id_rules_;
}

// repeated .Valdi.NamedStyleNode class_rules = 2;
inline int CSSRuleIndex::_internal_class_rules_size() const {
  return class_rules_.size();
}
inline int CSSRuleIndex::class_rules_size() const {
  return _internal_class_rules_size();
}
inline void CSSRuleIndex::clear_class_rules() {
  class_rules_.Clear();
}
inline ::Valdi::NamedStyleNode* CSSRuleIndex::mutable_class_rules(int index) {
  // @@protoc_insertion_point(field_mutable:Valdi.CSSRuleIndex.class_rules)
  return class_rules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Valdi::NamedStyleNode >*
CSSRuleIndex::mutable_class_rules() {
  // @@protoc_insertion_point(field_mutable_list:Valdi.CSSRuleIndex.class_rules)
  return &class_rules_;
}
inline const ::Valdi::NamedStyleNode& CSSRuleIndex::_internal_class_rules(int index) const {
  return class_rules_.Get(index);
}
inline const ::Valdi::NamedStyleNode& CSSRuleIndex::class_rules(int index) const {
  // @@protoc_insertion_point(field_get:Valdi.CSSRuleIndex.class_rules)
  return _internal_class_rules(index);
}
inline ::Valdi::NamedStyleNode* CSSRuleIndex::_internal_add_class_rules() {
  return class_rules_.Add();
}
inline ::Valdi::NamedStyleNode* CSSRuleIndex::add_class_rules() {
  ::Valdi::NamedStyleNode* _add = _internal_add_class_rules();
  // @@protoc_insertion_point(field_add:Valdi.CSSRuleIndex.class_rules)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Valdi::NamedStyleNode >&
CSSRuleIndex::class_rules() const {
  // @@protoc_insertion_point(field_list:Valdi.CSSRuleIndex.class_rules)
  return class_rules_;
}

// repeated .Valdi.NamedStyleNode tag_rules = 3;
inline int CSSRuleIndex::_internal_tag_rules_size() const {
  return tag_rules_.size();
}
inline int CSSRuleIndex::tag_rules_size() const {
  return _internal_tag_rules_size();
}
inline void CSSRuleIndex::clear_tag_rules() {
  tag_rules_.Clear();
}
inline ::Valdi::NamedStyleNode* CSSRuleIndex::mutable_tag_rules(int index) {
  // @@protoc_insertion_point(field_mutable:Valdi.CSSRuleIndex.tag_rules)
  return tag_rules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Valdi::NamedStyleNode >*
CSSRuleIndex::mutable_tag_rules() {
  // @@protoc_insertion_point(field_mutable_list:Valdi.CSSRuleIndex.tag_rules)
  return &tag_rules_;
}
inline const ::Valdi::NamedStyleNode& CSSRuleIndex::_internal_tag_rules(int index) const {
  return tag_rules_.Get(index);
}
inline const ::Valdi::NamedStyleNode& CSSRuleIndex::tag_rules(int index) const {
  // @@protoc_insertion_point(field_get:Valdi.CSSRuleIndex.tag_rules)
  return _internal_tag_rules(index);
}
inline ::Valdi::NamedStyleNode* CSSRuleIndex::_internal_add_tag_rules() {
  return tag_rules_.Add();
}
inline ::Valdi::NamedStyleNode* CSSRuleIndex::add_tag_rules() {
  ::Valdi::NamedStyleNode* _add = _internal_add_tag_rules();
  // @@protoc_insertion_point(field_add:Valdi.CSSRuleIndex.tag_rules)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Valdi::NamedStyleNode >&
CSSRuleIndex::tag_rules() const {
  // @@protoc_insertion_point(field_list:Valdi.CSSRuleIndex.tag_rules)
  return tag_rules_;
}

// repeated .Valdi.CSSRuleIndex.AttributeRule attribute_rules = 4;
inline int CSSRuleIndex::_internal_attribute_rules_size() const {
  return attribute_rules_.size();
}
inline int CSSRuleIndex::attribute_rules_size() const {
  return _internal_attribute_rules_size();
}
inline void CSSRuleIndex::clear_attribute_rules() {
  attribute_rules_.Clear();
}
inline ::Valdi::CSSRuleIndex_AttributeRule* CSSRuleIndex::mutable_attribute_rules(int index) {
  // @@protoc_insertion_point(field_mutable:Valdi.CSSRuleIndex.attribute_rules)
  return attribute_rules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Valdi::CSSRuleIndex_AttributeRule >*
CSSRuleIndex::mutable_attribute_rules() {
  // @@protoc_insertion_point(field_mutable_list:Valdi.CSSRuleIndex.attribute_rules)
  return &attribute_rules_;
}
inline const ::Valdi::CSSRuleIndex_AttributeRule& CSSRuleIndex::_internal_attribute_rules(int index) const {
  return attribute_rules_.Get(index);
}
inline const ::Valdi::CSSRuleIndex_AttributeRule& CSSRuleIndex::attribute_rules(int index) const {
  // @@protoc_insertion_point(field_get:Valdi.CSSRuleIndex.attribute_rules)
  return _internal_attribute_rules(index);
}
inline ::Valdi::CSSRuleIndex_AttributeRule* CSSRuleIndex::_internal_add_attribute_rules() {
  return attribute_rules_.Add();
}
inline ::Valdi::CSSRuleIndex_AttributeRule* CSSRuleIndex::add_attribute_rules() {
  ::Valdi::CSSRuleIndex_AttributeRule* _add = _internal_add_attribute_rules();
  // @@protoc_insertion_point(field_add:Valdi.CSSRuleIndex.attribute_rules)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Valdi::CSSRuleIndex_AttributeRule >&
CSSRuleIndex::attribute_rules() const {
  // @@protoc_insertion_point(field_list:Valdi.CSSRuleIndex.attribute_rules)
  return attribute_rules_;
}

// .Valdi.StyleNode first_child_rule = 5;
inline bool CSSRuleIndex::_internal_has_first_child_rule() const {
  return this != internal_default_instance() && first_child_rule_ != nullptr;
}
inline bool CSSRuleIndex::has_first_child_rule() const {
  return _internal_has_first_child_rule();
}
inline void CSSRuleIndex::clear_first_child_rule() {
  if (GetArenaForAllocation() == nullptr && first_child_rule_ != nullptr) {
    delete first_child_rule_;
  }
  first_child_rule_ = nullptr;
}
inline const ::Valdi::StyleNode& CSSRuleIndex::_internal_first_child_rule() const {
  const ::Valdi::StyleNode* p = first_child_rule_;
  return p != nullptr ? *p : reinterpret_cast<const ::Valdi::StyleNode&>(
      ::Valdi::_StyleNode_default_instance_);
}
inline const ::Valdi::StyleNode& CSSRuleIndex::first_child_rule() const {
  // @@protoc_insertion_point(field_get:Valdi.CSSRuleIndex.first_child_rule)
  return _internal_first_child_rule();
}
inline void CSSRuleIndex::unsafe_arena_set_allocated_first_child_rule(
    ::Valdi::StyleNode* first_child_rule) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(first_child_rule_);
  }
  first_child_rule_ = first_child_rule;
  if (first_child_rule) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Valdi.CSSRuleIndex.first_child_rule)
}
inline ::Valdi::StyleNode* CSSRuleIndex::release_first_child_rule() {
  
  ::Valdi::StyleNode* temp = first_child_rule_;
  first_child_rule_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Valdi::StyleNode* CSSRuleIndex::unsafe_arena_release_first_child_rule() {
  // @@protoc_insertion_point(field_release:Valdi.CSSRuleIndex.first_child_rule)
  
  ::Valdi::StyleNode* temp = first_child_rule_;
  first_child_rule_ = nullptr;
  return temp;
}
inline ::Valdi::StyleNode* CSSRuleIndex::_internal_mutable_first_child_rule() {
  
  if (first_child_rule_ == nullptr) {
    auto* p = CreateMaybeMessage<::Valdi::StyleNode>(GetArenaForAllocation());
    first_child_rule_ = p;
  }
  return first_child_rule_;
}
inline ::Valdi::StyleNode* CSSRuleIndex::mutable_first_child_rule() {
  ::Valdi::StyleNode* _msg = _internal_mutable_first_child_rule();
  // @@protoc_insertion_point(field_mutable:Valdi.CSSRuleIndex.first_child_rule)
  return _msg;
}
inline void CSSRuleIndex::set_allocated_first_child_rule(::Valdi::StyleNode* first_child_rule) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete first_child_rule_;
  }
  if (first_child_rule) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(first_child_rule);
    if (message_arena != submessage_arena) {
      first_child_rule = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, first_child_rule, submessage_arena);
    }
    
  } else {
    
  }
  first_child_rule_ = first_child_rule;
  // @@protoc_insertion_point(field_set_allocated:Valdi.CSSRuleIndex.first_child_rule)
}

// .Valdi.StyleNode last_child_rule = 6;
inline bool CSSRuleIndex::_internal_has_last_child_rule() const {
  return this != internal_default_instance() && last_child_rule_ != nullptr;
}
inline bool CSSRuleIndex::has_last_child_rule() const {
  return _internal_has_last_child_rule();
}
inline void CSSRuleIndex::clear_last_child_rule() {
  if (GetArenaForAllocation() == nullptr && last_child_rule_ != nullptr) {
    delete last_child_rule_;
  }
  last_child_rule_ = nullptr;
}
inline const ::Valdi::StyleNode& CSSRuleIndex::_internal_last_child_rule() const {
  const ::Valdi::StyleNode* p = last_child_rule_;
  return p != nullptr ? *p : reinterpret_cast<const ::Valdi::StyleNode&>(
      ::Valdi::_StyleNode_default_instance_);
}
inline const ::Valdi::StyleNode& CSSRuleIndex::last_child_rule() const {
  // @@protoc_insertion_point(field_get:Valdi.CSSRuleIndex.last_child_rule)
  return _internal_last_child_rule();
}
inline void CSSRuleIndex::unsafe_arena_set_allocated_last_child_rule(
    ::Valdi::StyleNode* last_child_rule) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(last_child_rule_);
  }
  last_child_rule_ = last_child_rule;
  if (last_child_rule) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Valdi.CSSRuleIndex.last_child_rule)
}
inline ::Valdi::StyleNode* CSSRuleIndex::release_last_child_rule() {
  
  ::Valdi::StyleNode* temp = last_child_rule_;
  last_child_rule_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Valdi::StyleNode* CSSRuleIndex::unsafe_arena_release_last_child_rule() {
  // @@protoc_insertion_point(field_release:Valdi.CSSRuleIndex.last_child_rule)
  
  ::Valdi::StyleNode* temp = last_child_rule_;
  last_child_rule_ = nullptr;
  return temp;
}
inline ::Valdi::StyleNode* CSSRuleIndex::_internal_mutable_last_child_rule() {
  
  if (last_child_rule_ == nullptr) {
    auto* p = CreateMaybeMessage<::Valdi::StyleNode>(GetArenaForAllocation());
    last_child_rule_ = p;
  }
  return last_child_rule_;
}
inline ::Valdi::StyleNode* CSSRuleIndex::mutable_last_child_rule() {
  ::Valdi::StyleNode* _msg = _internal_mutable_last_child_rule();
  // @@protoc_insertion_point(field_mutable:Valdi.CSSRuleIndex.last_child_rule)
  return _msg;
}
inline void CSSRuleIndex::set_allocated_last_child_rule(::Valdi::StyleNode* last_child_rule) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete last_child_rule_;
  }
  if (last_child_rule) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(last_child_rule);
    if (message_arena != submessage_arena) {
      last_child_rule = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, last_child_rule, submessage_arena);
    }
    
  } else {
    
  }
  last_child_rule_ = last_child_rule;
  // @@protoc_insertion_point(field_set_allocated:Valdi.CSSRuleIndex.last_child_rule)
}

// repeated .Valdi.CSSRuleIndex.NthChildRule nth_child_rules = 7;
inline int CSSRuleIndex::_internal_nth_child_rules_size() const {
  return nth_child_rules_.size();
}
inline int CSSRuleIndex::nth_child_rules_size() const {
  return _internal_nth_child_rules_size();
}
inline void CSSRuleIndex::clear_nth_child_rules() {
  nth_child_rules_.Clear();
}
inline ::Valdi::CSSRuleIndex_NthChildRule* CSSRuleIndex::mutable_nth_child_rules(int index) {
  // @@protoc_insertion_point(field_mutable:Valdi.CSSRuleIndex.nth_child_rules)
  return nth_child_rules_.Mutable(index);
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Valdi::CSSRuleIndex_NthChildRule >*
CSSRuleIndex::mutable_nth_child_rules() {
  // @@protoc_insertion_point(field_mutable_list:Valdi.CSSRuleIndex.nth_child_rules)
  return &nth_child_rules_;
}
inline const ::Valdi::CSSRuleIndex_NthChildRule& CSSRuleIndex::_internal_nth_child_rules(int index) const {
  return nth_child_rules_.Get(index);
}
inline const ::Valdi::CSSRuleIndex_NthChildRule& CSSRuleIndex::nth_child_rules(int index) const {
  // @@protoc_insertion_point(field_get:Valdi.CSSRuleIndex.nth_child_rules)
  return _internal_nth_child_rules(index);
}
inline ::Valdi::CSSRuleIndex_NthChildRule* CSSRuleIndex::_internal_add_nth_child_rules() {
  return nth_child_rules_.Add();
}
inline ::Valdi::CSSRuleIndex_NthChildRule* CSSRuleIndex::add_nth_child_rules() {
  ::Valdi::CSSRuleIndex_NthChildRule* _add = _internal_add_nth_child_rules();
  // @@protoc_insertion_point(field_add:Valdi.CSSRuleIndex.nth_child_rules)
  return _add;
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField< ::Valdi::CSSRuleIndex_NthChildRule >&
CSSRuleIndex::nth_child_rules() const {
  // @@protoc_insertion_point(field_list:Valdi.CSSRuleIndex.nth_child_rules)
  return nth_child_rules_;
}

// .Valdi.CSSRuleIndex ancestor_rules = 8;
inline bool CSSRuleIndex::_internal_has_ancestor_rules() const {
  return this != internal_default_instance() && ancestor_rules_ != nullptr;
}
inline bool CSSRuleIndex::has_ancestor_rules() const {
  return _internal_has_ancestor_rules();
}
inline void CSSRuleIndex::clear_ancestor_rules() {
  if (GetArenaForAllocation() == nullptr && ancestor_rules_ != nullptr) {
    delete ancestor_rules_;
  }
  ancestor_rules_ = nullptr;
}
inline const ::Valdi::CSSRuleIndex& CSSRuleIndex::_internal_ancestor_rules() const {
  const ::Valdi::CSSRuleIndex* p = ancestor_rules_;
  return p != nullptr ? *p : reinterpret_cast<const ::Valdi::CSSRuleIndex&>(
      ::Valdi::_CSSRuleIndex_default_instance_);
}
inline const ::Valdi::CSSRuleIndex& CSSRuleIndex::ancestor_rules() const {
  // @@protoc_insertion_point(field_get:Valdi.CSSRuleIndex.ancestor_rules)
  return _internal_ancestor_rules();
}
inline void CSSRuleIndex::unsafe_arena_set_allocated_ancestor_rules(
    ::Valdi::CSSRuleIndex* ancestor_rules) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(ancestor_rules_);
  }
  ancestor_rules_ = ancestor_rules;
  if (ancestor_rules) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Valdi.CSSRuleIndex.ancestor_rules)
}
inline ::Valdi::CSSRuleIndex* CSSRuleIndex::release_ancestor_rules() {
  
  ::Valdi::CSSRuleIndex* temp = ancestor_rules_;
  ancestor_rules_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Valdi::CSSRuleIndex* CSSRuleIndex::unsafe_arena_release_ancestor_rules() {
  // @@protoc_insertion_point(field_release:Valdi.CSSRuleIndex.ancestor_rules)
  
  ::Valdi::CSSRuleIndex* temp = ancestor_rules_;
  ancestor_rules_ = nullptr;
  return temp;
}
inline ::Valdi::CSSRuleIndex* CSSRuleIndex::_internal_mutable_ancestor_rules() {
  
  if (ancestor_rules_ == nullptr) {
    auto* p = CreateMaybeMessage<::Valdi::CSSRuleIndex>(GetArenaForAllocation());
    ancestor_rules_ = p;
  }
  return ancestor_rules_;
}
inline ::Valdi::CSSRuleIndex* CSSRuleIndex::mutable_ancestor_rules() {
  ::Valdi::CSSRuleIndex* _msg = _internal_mutable_ancestor_rules();
  // @@protoc_insertion_point(field_mutable:Valdi.CSSRuleIndex.ancestor_rules)
  return _msg;
}
inline void CSSRuleIndex::set_allocated_ancestor_rules(::Valdi::CSSRuleIndex* ancestor_rules) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete ancestor_rules_;
  }
  if (ancestor_rules) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(ancestor_rules);
    if (message_arena != submessage_arena) {
      ancestor_rules = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, ancestor_rules, submessage_arena);
    }
    
  } else {
    
  }
  ancestor_rules_ = ancestor_rules;
  // @@protoc_insertion_point(field_set_allocated:Valdi.CSSRuleIndex.ancestor_rules)
}

// .Valdi.CSSRuleIndex direct_parent_rules = 9;
inline bool CSSRuleIndex::_internal_has_direct_parent_rules() const {
  return this != internal_default_instance() && direct_parent_rules_ != nullptr;
}
inline bool CSSRuleIndex::has_direct_parent_rules() const {
  return _internal_has_direct_parent_rules();
}
inline void CSSRuleIndex::clear_direct_parent_rules() {
  if (GetArenaForAllocation() == nullptr && direct_parent_rules_ != nullptr) {
    delete direct_parent_rules_;
  }
  direct_parent_rules_ = nullptr;
}
inline const ::Valdi::CSSRuleIndex& CSSRuleIndex::_internal_direct_parent_rules() const {
  const ::Valdi::CSSRuleIndex* p = direct_parent_rules_;
  return p != nullptr ? *p : reinterpret_cast<const ::Valdi::CSSRuleIndex&>(
      ::Valdi::_CSSRuleIndex_default_instance_);
}
inline const ::Valdi::CSSRuleIndex& CSSRuleIndex::direct_parent_rules() const {
  // @@protoc_insertion_point(field_get:Valdi.CSSRuleIndex.direct_parent_rules)
  return _internal_direct_parent_rules();
}
inline void CSSRuleIndex::unsafe_arena_set_allocated_direct_parent_rules(
    ::Valdi::CSSRuleIndex* direct_parent_rules) {
  if (GetArenaForAllocation() == nullptr) {
    delete reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(direct_parent_rules_);
  }
  direct_parent_rules_ = direct_parent_rules;
  if (direct_parent_rules) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_unsafe_arena_set_allocated:Valdi.CSSRuleIndex.direct_parent_rules)
}
inline ::Valdi::CSSRuleIndex* CSSRuleIndex::release_direct_parent_rules() {
  
  ::Valdi::CSSRuleIndex* temp = direct_parent_rules_;
  direct_parent_rules_ = nullptr;
#ifdef PROTOBUF_FORCE_COPY_IN_RELEASE
  auto* old =  reinterpret_cast<::PROTOBUF_NAMESPACE_ID::MessageLite*>(temp);
  temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  if (GetArenaForAllocation() == nullptr) { delete old; }
#else  // PROTOBUF_FORCE_COPY_IN_RELEASE
  if (GetArenaForAllocation() != nullptr) {
    temp = ::PROTOBUF_NAMESPACE_ID::internal::DuplicateIfNonNull(temp);
  }
#endif  // !PROTOBUF_FORCE_COPY_IN_RELEASE
  return temp;
}
inline ::Valdi::CSSRuleIndex* CSSRuleIndex::unsafe_arena_release_direct_parent_rules() {
  // @@protoc_insertion_point(field_release:Valdi.CSSRuleIndex.direct_parent_rules)
  
  ::Valdi::CSSRuleIndex* temp = direct_parent_rules_;
  direct_parent_rules_ = nullptr;
  return temp;
}
inline ::Valdi::CSSRuleIndex* CSSRuleIndex::_internal_mutable_direct_parent_rules() {
  
  if (direct_parent_rules_ == nullptr) {
    auto* p = CreateMaybeMessage<::Valdi::CSSRuleIndex>(GetArenaForAllocation());
    direct_parent_rules_ = p;
  }
  return direct_parent_rules_;
}
inline ::Valdi::CSSRuleIndex* CSSRuleIndex::mutable_direct_parent_rules() {
  ::Valdi::CSSRuleIndex* _msg = _internal_mutable_direct_parent_rules();
  // @@protoc_insertion_point(field_mutable:Valdi.CSSRuleIndex.direct_parent_rules)
  return _msg;
}
inline void CSSRuleIndex::set_allocated_direct_parent_rules(::Valdi::CSSRuleIndex* direct_parent_rules) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  if (message_arena == nullptr) {
    delete direct_parent_rules_;
  }
  if (direct_parent_rules) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
        ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(direct_parent_rules);
    if (message_arena != submessage_arena) {
      direct_parent_rules = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, direct_parent_rules, submessage_arena);
    }
    
  } else {
    
  }
  direct_parent_rules_ = direct_parent_rules;
  // @@protoc_insertion_point(field_set_allocated:Valdi.CSSRuleIndex.direct_parent_rules)
}

// -------------------------------------------------------------------

// TsnConfig

// repeated string enabled_modules = 1;
inline int TsnConfig::_internal_enabled_modules_size() const {
  return enabled_modules_.size();
}
inline int TsnConfig::enabled_modules_size() const {
  return _internal_enabled_modules_size();
}
inline void TsnConfig::clear_enabled_modules() {
  enabled_modules_.Clear();
}
inline std::string* TsnConfig::add_enabled_modules() {
  std::string* _s = _internal_add_enabled_modules();
  // @@protoc_insertion_point(field_add_mutable:Valdi.TsnConfig.enabled_modules)
  return _s;
}
inline const std::string& TsnConfig::_internal_enabled_modules(int index) const {
  return enabled_modules_.Get(index);
}
inline const std::string& TsnConfig::enabled_modules(int index) const {
  // @@protoc_insertion_point(field_get:Valdi.TsnConfig.enabled_modules)
  return _internal_enabled_modules(index);
}
inline std::string* TsnConfig::mutable_enabled_modules(int index) {
  // @@protoc_insertion_point(field_mutable:Valdi.TsnConfig.enabled_modules)
  return enabled_modules_.Mutable(index);
}
inline void TsnConfig::set_enabled_modules(int index, const std::string& value) {
  enabled_modules_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set:Valdi.TsnConfig.enabled_modules)
}
inline void TsnConfig::set_enabled_modules(int index, std::string&& value) {
  enabled_modules_.Mutable(index)->assign(std::move(value));
  // @@protoc_insertion_point(field_set:Valdi.TsnConfig.enabled_modules)
}
inline void TsnConfig::set_enabled_modules(int index, const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  enabled_modules_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:Valdi.TsnConfig.enabled_modules)
}
inline void TsnConfig::set_enabled_modules(int index, const char* value, size_t size) {
  enabled_modules_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:Valdi.TsnConfig.enabled_modules)
}
inline std::string* TsnConfig::_internal_add_enabled_modules() {
  return enabled_modules_.Add();
}
inline void TsnConfig::add_enabled_modules(const std::string& value) {
  enabled_modules_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:Valdi.TsnConfig.enabled_modules)
}
inline void TsnConfig::add_enabled_modules(std::string&& value) {
  enabled_modules_.Add(std::move(value));
  // @@protoc_insertion_point(field_add:Valdi.TsnConfig.enabled_modules)
}
inline void TsnConfig::add_enabled_modules(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  enabled_modules_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:Valdi.TsnConfig.enabled_modules)
}
inline void TsnConfig::add_enabled_modules(const char* value, size_t size) {
  enabled_modules_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:Valdi.TsnConfig.enabled_modules)
}
inline const ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>&
TsnConfig::enabled_modules() const {
  // @@protoc_insertion_point(field_list:Valdi.TsnConfig.enabled_modules)
  return enabled_modules_;
}
inline ::PROTOBUF_NAMESPACE_ID::RepeatedPtrField<std::string>*
TsnConfig::mutable_enabled_modules() {
  // @@protoc_insertion_point(field_mutable_list:Valdi.TsnConfig.enabled_modules)
  return &enabled_modules_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace Valdi

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::Valdi::NodeAttribute_Type> : ::std::true_type {};
template <> struct is_proto_enum< ::Valdi::CSSRuleIndex_AttributeRule_Type> : ::std::true_type {};

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_valdi_2eproto
