// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: valdi.proto

#include "valdi.pb.h"

#include <algorithm>

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/wire_format_lite.h>
#include <google/protobuf/io/zero_copy_stream_impl_lite.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>

PROTOBUF_PRAGMA_INIT_SEG

namespace _pb = ::PROTOBUF_NAMESPACE_ID;
namespace _pbi = _pb::internal;

namespace Valdi {
PROTOBUF_CONSTEXPR NodeAttribute::NodeAttribute(
    ::_pbi::ConstantInitialized)
  : name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , str_value_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , int_value_(int64_t{0})
  , double_value_(0)
  , type_(0)
{}
struct NodeAttributeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NodeAttributeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NodeAttributeDefaultTypeInternal() {}
  union {
    NodeAttribute _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NodeAttributeDefaultTypeInternal _NodeAttribute_default_instance_;
PROTOBUF_CONSTEXPR DownloadableModuleArtifact::DownloadableModuleArtifact(
    ::_pbi::ConstantInitialized)
  : url_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , sha256digest_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct DownloadableModuleArtifactDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DownloadableModuleArtifactDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DownloadableModuleArtifactDefaultTypeInternal() {}
  union {
    DownloadableModuleArtifact _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DownloadableModuleArtifactDefaultTypeInternal _DownloadableModuleArtifact_default_instance_;
PROTOBUF_CONSTEXPR DownloadableModuleAssets::DownloadableModuleAssets(
    ::_pbi::ConstantInitialized)
  : artifact_(nullptr)
  , device_density_(0){}
struct DownloadableModuleAssetsDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DownloadableModuleAssetsDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DownloadableModuleAssetsDefaultTypeInternal() {}
  union {
    DownloadableModuleAssets _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DownloadableModuleAssetsDefaultTypeInternal _DownloadableModuleAssets_default_instance_;
PROTOBUF_CONSTEXPR DownloadableModuleManifest::DownloadableModuleManifest(
    ::_pbi::ConstantInitialized)
  : assets_()
  , dependencies_()
  , name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , artifact_(nullptr)
  , has_local_assets_(false){}
struct DownloadableModuleManifestDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DownloadableModuleManifestDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DownloadableModuleManifestDefaultTypeInternal() {}
  union {
    DownloadableModuleManifest _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DownloadableModuleManifestDefaultTypeInternal _DownloadableModuleManifest_default_instance_;
PROTOBUF_CONSTEXPR DaemonAwakeMessage::DaemonAwakeMessage(
    ::_pbi::ConstantInitialized)
  : service_addresses_()
  , device_ids_()
  , usernames_()
  , process_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , service_port_(0){}
struct DaemonAwakeMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DaemonAwakeMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DaemonAwakeMessageDefaultTypeInternal() {}
  union {
    DaemonAwakeMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DaemonAwakeMessageDefaultTypeInternal _DaemonAwakeMessage_default_instance_;
PROTOBUF_CONSTEXPR ClientAwakeMessage::ClientAwakeMessage(
    ::_pbi::ConstantInitialized)
  : device_id_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , username_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{}){}
struct ClientAwakeMessageDefaultTypeInternal {
  PROTOBUF_CONSTEXPR ClientAwakeMessageDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~ClientAwakeMessageDefaultTypeInternal() {}
  union {
    ClientAwakeMessage _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 ClientAwakeMessageDefaultTypeInternal _ClientAwakeMessage_default_instance_;
PROTOBUF_CONSTEXPR DaemonServiceDiscoveryPayload::DaemonServiceDiscoveryPayload(
    ::_pbi::ConstantInitialized)
  : _oneof_case_{}{}
struct DaemonServiceDiscoveryPayloadDefaultTypeInternal {
  PROTOBUF_CONSTEXPR DaemonServiceDiscoveryPayloadDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~DaemonServiceDiscoveryPayloadDefaultTypeInternal() {}
  union {
    DaemonServiceDiscoveryPayload _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 DaemonServiceDiscoveryPayloadDefaultTypeInternal _DaemonServiceDiscoveryPayload_default_instance_;
PROTOBUF_CONSTEXPR StyleNode::StyleNode(
    ::_pbi::ConstantInitialized)
  : styles_()
  , ruleindex_(nullptr){}
struct StyleNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StyleNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StyleNodeDefaultTypeInternal() {}
  union {
    StyleNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StyleNodeDefaultTypeInternal _StyleNode_default_instance_;
PROTOBUF_CONSTEXPR StyleDeclaration::StyleDeclaration(
    ::_pbi::ConstantInitialized)
  : attribute_(nullptr)
  , priority_(0)
  , order_(0)
  , id_(0){}
struct StyleDeclarationDefaultTypeInternal {
  PROTOBUF_CONSTEXPR StyleDeclarationDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~StyleDeclarationDefaultTypeInternal() {}
  union {
    StyleDeclaration _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 StyleDeclarationDefaultTypeInternal _StyleDeclaration_default_instance_;
PROTOBUF_CONSTEXPR NamedStyleNode::NamedStyleNode(
    ::_pbi::ConstantInitialized)
  : name_(&::_pbi::fixed_address_empty_string, ::_pbi::ConstantInitialized{})
  , node_(nullptr){}
struct NamedStyleNodeDefaultTypeInternal {
  PROTOBUF_CONSTEXPR NamedStyleNodeDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~NamedStyleNodeDefaultTypeInternal() {}
  union {
    NamedStyleNode _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 NamedStyleNodeDefaultTypeInternal _NamedStyleNode_default_instance_;
PROTOBUF_CONSTEXPR CSSRuleIndex_AttributeRule::CSSRuleIndex_AttributeRule(
    ::_pbi::ConstantInitialized)
  : attribute_(nullptr)
  , node_(nullptr)
  , type_(0)
{}
struct CSSRuleIndex_AttributeRuleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSSRuleIndex_AttributeRuleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSSRuleIndex_AttributeRuleDefaultTypeInternal() {}
  union {
    CSSRuleIndex_AttributeRule _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSSRuleIndex_AttributeRuleDefaultTypeInternal _CSSRuleIndex_AttributeRule_default_instance_;
PROTOBUF_CONSTEXPR CSSRuleIndex_NthChildRule::CSSRuleIndex_NthChildRule(
    ::_pbi::ConstantInitialized)
  : node_(nullptr)
  , n_(0)
  , offset_(0){}
struct CSSRuleIndex_NthChildRuleDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSSRuleIndex_NthChildRuleDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSSRuleIndex_NthChildRuleDefaultTypeInternal() {}
  union {
    CSSRuleIndex_NthChildRule _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSSRuleIndex_NthChildRuleDefaultTypeInternal _CSSRuleIndex_NthChildRule_default_instance_;
PROTOBUF_CONSTEXPR CSSRuleIndex::CSSRuleIndex(
    ::_pbi::ConstantInitialized)
  : id_rules_()
  , class_rules_()
  , tag_rules_()
  , attribute_rules_()
  , nth_child_rules_()
  , first_child_rule_(nullptr)
  , last_child_rule_(nullptr)
  , ancestor_rules_(nullptr)
  , direct_parent_rules_(nullptr){}
struct CSSRuleIndexDefaultTypeInternal {
  PROTOBUF_CONSTEXPR CSSRuleIndexDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~CSSRuleIndexDefaultTypeInternal() {}
  union {
    CSSRuleIndex _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 CSSRuleIndexDefaultTypeInternal _CSSRuleIndex_default_instance_;
PROTOBUF_CONSTEXPR TsnConfig::TsnConfig(
    ::_pbi::ConstantInitialized)
  : enabled_modules_(){}
struct TsnConfigDefaultTypeInternal {
  PROTOBUF_CONSTEXPR TsnConfigDefaultTypeInternal()
      : _instance(::_pbi::ConstantInitialized{}) {}
  ~TsnConfigDefaultTypeInternal() {}
  union {
    TsnConfig _instance;
  };
};
PROTOBUF_ATTRIBUTE_NO_DESTROY PROTOBUF_CONSTINIT PROTOBUF_ATTRIBUTE_INIT_PRIORITY1 TsnConfigDefaultTypeInternal _TsnConfig_default_instance_;
}  // namespace Valdi
namespace Valdi {
bool NodeAttribute_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> NodeAttribute_Type_strings[3] = {};

static const char NodeAttribute_Type_names[] =
  "NODE_ATTRIBUTE_TYPE_DOUBLE"
  "NODE_ATTRIBUTE_TYPE_INT"
  "NODE_ATTRIBUTE_TYPE_STRING";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry NodeAttribute_Type_entries[] = {
  { {NodeAttribute_Type_names + 0, 26}, 2 },
  { {NodeAttribute_Type_names + 26, 23}, 1 },
  { {NodeAttribute_Type_names + 49, 26}, 0 },
};

static const int NodeAttribute_Type_entries_by_number[] = {
  2, // 0 -> NODE_ATTRIBUTE_TYPE_STRING
  1, // 1 -> NODE_ATTRIBUTE_TYPE_INT
  0, // 2 -> NODE_ATTRIBUTE_TYPE_DOUBLE
};

const std::string& NodeAttribute_Type_Name(
    NodeAttribute_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          NodeAttribute_Type_entries,
          NodeAttribute_Type_entries_by_number,
          3, NodeAttribute_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      NodeAttribute_Type_entries,
      NodeAttribute_Type_entries_by_number,
      3, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     NodeAttribute_Type_strings[idx].get();
}
bool NodeAttribute_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, NodeAttribute_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      NodeAttribute_Type_entries, 3, name, &int_value);
  if (success) {
    *value = static_cast<NodeAttribute_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr NodeAttribute_Type NodeAttribute::NODE_ATTRIBUTE_TYPE_STRING;
constexpr NodeAttribute_Type NodeAttribute::NODE_ATTRIBUTE_TYPE_INT;
constexpr NodeAttribute_Type NodeAttribute::NODE_ATTRIBUTE_TYPE_DOUBLE;
constexpr NodeAttribute_Type NodeAttribute::Type_MIN;
constexpr NodeAttribute_Type NodeAttribute::Type_MAX;
constexpr int NodeAttribute::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
bool CSSRuleIndex_AttributeRule_Type_IsValid(int value) {
  switch (value) {
    case 0:
    case 1:
    case 2:
    case 3:
    case 4:
    case 5:
    case 6:
      return true;
    default:
      return false;
  }
}

static ::PROTOBUF_NAMESPACE_ID::internal::ExplicitlyConstructed<std::string> CSSRuleIndex_AttributeRule_Type_strings[7] = {};

static const char CSSRuleIndex_AttributeRule_Type_names[] =
  "CONTAINS_SUBSTRING"
  "CONTAINS_WORD"
  "ENDS_WITH_SUBSTRING"
  "EQUALS"
  "HAS_ATTRIBUTE"
  "STARTS_WITH_SUBSTRING"
  "STARTS_WITH_WORD";

static const ::PROTOBUF_NAMESPACE_ID::internal::EnumEntry CSSRuleIndex_AttributeRule_Type_entries[] = {
  { {CSSRuleIndex_AttributeRule_Type_names + 0, 18}, 5 },
  { {CSSRuleIndex_AttributeRule_Type_names + 18, 13}, 1 },
  { {CSSRuleIndex_AttributeRule_Type_names + 31, 19}, 4 },
  { {CSSRuleIndex_AttributeRule_Type_names + 50, 6}, 0 },
  { {CSSRuleIndex_AttributeRule_Type_names + 56, 13}, 6 },
  { {CSSRuleIndex_AttributeRule_Type_names + 69, 21}, 3 },
  { {CSSRuleIndex_AttributeRule_Type_names + 90, 16}, 2 },
};

static const int CSSRuleIndex_AttributeRule_Type_entries_by_number[] = {
  3, // 0 -> EQUALS
  1, // 1 -> CONTAINS_WORD
  6, // 2 -> STARTS_WITH_WORD
  5, // 3 -> STARTS_WITH_SUBSTRING
  2, // 4 -> ENDS_WITH_SUBSTRING
  0, // 5 -> CONTAINS_SUBSTRING
  4, // 6 -> HAS_ATTRIBUTE
};

const std::string& CSSRuleIndex_AttributeRule_Type_Name(
    CSSRuleIndex_AttributeRule_Type value) {
  static const bool dummy =
      ::PROTOBUF_NAMESPACE_ID::internal::InitializeEnumStrings(
          CSSRuleIndex_AttributeRule_Type_entries,
          CSSRuleIndex_AttributeRule_Type_entries_by_number,
          7, CSSRuleIndex_AttributeRule_Type_strings);
  (void) dummy;
  int idx = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumName(
      CSSRuleIndex_AttributeRule_Type_entries,
      CSSRuleIndex_AttributeRule_Type_entries_by_number,
      7, value);
  return idx == -1 ? ::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString() :
                     CSSRuleIndex_AttributeRule_Type_strings[idx].get();
}
bool CSSRuleIndex_AttributeRule_Type_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, CSSRuleIndex_AttributeRule_Type* value) {
  int int_value;
  bool success = ::PROTOBUF_NAMESPACE_ID::internal::LookUpEnumValue(
      CSSRuleIndex_AttributeRule_Type_entries, 7, name, &int_value);
  if (success) {
    *value = static_cast<CSSRuleIndex_AttributeRule_Type>(int_value);
  }
  return success;
}
#if (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))
constexpr CSSRuleIndex_AttributeRule_Type CSSRuleIndex_AttributeRule::EQUALS;
constexpr CSSRuleIndex_AttributeRule_Type CSSRuleIndex_AttributeRule::CONTAINS_WORD;
constexpr CSSRuleIndex_AttributeRule_Type CSSRuleIndex_AttributeRule::STARTS_WITH_WORD;
constexpr CSSRuleIndex_AttributeRule_Type CSSRuleIndex_AttributeRule::STARTS_WITH_SUBSTRING;
constexpr CSSRuleIndex_AttributeRule_Type CSSRuleIndex_AttributeRule::ENDS_WITH_SUBSTRING;
constexpr CSSRuleIndex_AttributeRule_Type CSSRuleIndex_AttributeRule::CONTAINS_SUBSTRING;
constexpr CSSRuleIndex_AttributeRule_Type CSSRuleIndex_AttributeRule::HAS_ATTRIBUTE;
constexpr CSSRuleIndex_AttributeRule_Type CSSRuleIndex_AttributeRule::Type_MIN;
constexpr CSSRuleIndex_AttributeRule_Type CSSRuleIndex_AttributeRule::Type_MAX;
constexpr int CSSRuleIndex_AttributeRule::Type_ARRAYSIZE;
#endif  // (__cplusplus < 201703) && (!defined(_MSC_VER) || (_MSC_VER >= 1900 && _MSC_VER < 1912))

// ===================================================================

class NodeAttribute::_Internal {
 public:
};

NodeAttribute::NodeAttribute(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:Valdi.NodeAttribute)
}
NodeAttribute::NodeAttribute(const NodeAttribute& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  str_value_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    str_value_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_str_value().empty()) {
    str_value_.Set(from._internal_str_value(), 
      GetArenaForAllocation());
  }
  ::memcpy(&int_value_, &from.int_value_,
    static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&int_value_)) + sizeof(type_));
  // @@protoc_insertion_point(copy_constructor:Valdi.NodeAttribute)
}

inline void NodeAttribute::SharedCtor() {
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
str_value_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  str_value_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&int_value_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&int_value_)) + sizeof(type_));
}

NodeAttribute::~NodeAttribute() {
  // @@protoc_insertion_point(destructor:Valdi.NodeAttribute)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NodeAttribute::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.Destroy();
  str_value_.Destroy();
}

void NodeAttribute::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NodeAttribute::Clear() {
// @@protoc_insertion_point(message_clear_start:Valdi.NodeAttribute)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmpty();
  str_value_.ClearToEmpty();
  ::memset(&int_value_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&type_) -
      reinterpret_cast<char*>(&int_value_)) + sizeof(type_));
  _internal_metadata_.Clear<std::string>();
}

const char* NodeAttribute::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Valdi.NodeAttribute.Type type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::Valdi::NodeAttribute_Type>(val));
        } else
          goto handle_unusual;
        continue;
      // string name = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string str_value = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_str_value();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // int64 int_value = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          int_value_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double double_value = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 41)) {
          double_value_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NodeAttribute::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Valdi.NodeAttribute)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Valdi.NodeAttribute.Type type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // string name = 2;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Valdi.NodeAttribute.name");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_name(), target);
  }

  // string str_value = 3;
  if (!this->_internal_str_value().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_str_value().data(), static_cast<int>(this->_internal_str_value().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Valdi.NodeAttribute.str_value");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_str_value(), target);
  }

  // int64 int_value = 4;
  if (this->_internal_int_value() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt64ToArray(4, this->_internal_int_value(), target);
  }

  // double double_value = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_double_value = this->_internal_double_value();
  uint64_t raw_double_value;
  memcpy(&raw_double_value, &tmp_double_value, sizeof(tmp_double_value));
  if (raw_double_value != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(5, this->_internal_double_value(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Valdi.NodeAttribute)
  return target;
}

size_t NodeAttribute::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Valdi.NodeAttribute)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 2;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // string str_value = 3;
  if (!this->_internal_str_value().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_str_value());
  }

  // int64 int_value = 4;
  if (this->_internal_int_value() != 0) {
    total_size += ::_pbi::WireFormatLite::Int64SizePlusOne(this->_internal_int_value());
  }

  // double double_value = 5;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_double_value = this->_internal_double_value();
  uint64_t raw_double_value;
  memcpy(&raw_double_value, &tmp_double_value, sizeof(tmp_double_value));
  if (raw_double_value != 0) {
    total_size += 1 + 8;
  }

  // .Valdi.NodeAttribute.Type type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NodeAttribute::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const NodeAttribute*>(
      &from));
}

void NodeAttribute::MergeFrom(const NodeAttribute& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Valdi.NodeAttribute)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (!from._internal_str_value().empty()) {
    _internal_set_str_value(from._internal_str_value());
  }
  if (from._internal_int_value() != 0) {
    _internal_set_int_value(from._internal_int_value());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_double_value = from._internal_double_value();
  uint64_t raw_double_value;
  memcpy(&raw_double_value, &tmp_double_value, sizeof(tmp_double_value));
  if (raw_double_value != 0) {
    _internal_set_double_value(from._internal_double_value());
  }
  if (from._internal_type() != 0) {
    _internal_set_type(from._internal_type());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NodeAttribute::CopyFrom(const NodeAttribute& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Valdi.NodeAttribute)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NodeAttribute::IsInitialized() const {
  return true;
}

void NodeAttribute::InternalSwap(NodeAttribute* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &str_value_, lhs_arena,
      &other->str_value_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(NodeAttribute, type_)
      + sizeof(NodeAttribute::type_)
      - PROTOBUF_FIELD_OFFSET(NodeAttribute, int_value_)>(
          reinterpret_cast<char*>(&int_value_),
          reinterpret_cast<char*>(&other->int_value_));
}

std::string NodeAttribute::GetTypeName() const {
  return "Valdi.NodeAttribute";
}


// ===================================================================

class DownloadableModuleArtifact::_Internal {
 public:
};

DownloadableModuleArtifact::DownloadableModuleArtifact(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:Valdi.DownloadableModuleArtifact)
}
DownloadableModuleArtifact::DownloadableModuleArtifact(const DownloadableModuleArtifact& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  url_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    url_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_url().empty()) {
    url_.Set(from._internal_url(), 
      GetArenaForAllocation());
  }
  sha256digest_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    sha256digest_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_sha256digest().empty()) {
    sha256digest_.Set(from._internal_sha256digest(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:Valdi.DownloadableModuleArtifact)
}

inline void DownloadableModuleArtifact::SharedCtor() {
url_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  url_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
sha256digest_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  sha256digest_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

DownloadableModuleArtifact::~DownloadableModuleArtifact() {
  // @@protoc_insertion_point(destructor:Valdi.DownloadableModuleArtifact)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DownloadableModuleArtifact::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  url_.Destroy();
  sha256digest_.Destroy();
}

void DownloadableModuleArtifact::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DownloadableModuleArtifact::Clear() {
// @@protoc_insertion_point(message_clear_start:Valdi.DownloadableModuleArtifact)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  url_.ClearToEmpty();
  sha256digest_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* DownloadableModuleArtifact::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string url = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_url();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // bytes sha256Digest = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_sha256digest();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DownloadableModuleArtifact::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Valdi.DownloadableModuleArtifact)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string url = 1;
  if (!this->_internal_url().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_url().data(), static_cast<int>(this->_internal_url().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Valdi.DownloadableModuleArtifact.url");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_url(), target);
  }

  // bytes sha256Digest = 2;
  if (!this->_internal_sha256digest().empty()) {
    target = stream->WriteBytesMaybeAliased(
        2, this->_internal_sha256digest(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Valdi.DownloadableModuleArtifact)
  return target;
}

size_t DownloadableModuleArtifact::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Valdi.DownloadableModuleArtifact)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string url = 1;
  if (!this->_internal_url().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_url());
  }

  // bytes sha256Digest = 2;
  if (!this->_internal_sha256digest().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::BytesSize(
        this->_internal_sha256digest());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DownloadableModuleArtifact::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DownloadableModuleArtifact*>(
      &from));
}

void DownloadableModuleArtifact::MergeFrom(const DownloadableModuleArtifact& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Valdi.DownloadableModuleArtifact)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_url().empty()) {
    _internal_set_url(from._internal_url());
  }
  if (!from._internal_sha256digest().empty()) {
    _internal_set_sha256digest(from._internal_sha256digest());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DownloadableModuleArtifact::CopyFrom(const DownloadableModuleArtifact& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Valdi.DownloadableModuleArtifact)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DownloadableModuleArtifact::IsInitialized() const {
  return true;
}

void DownloadableModuleArtifact::InternalSwap(DownloadableModuleArtifact* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &url_, lhs_arena,
      &other->url_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &sha256digest_, lhs_arena,
      &other->sha256digest_, rhs_arena
  );
}

std::string DownloadableModuleArtifact::GetTypeName() const {
  return "Valdi.DownloadableModuleArtifact";
}


// ===================================================================

class DownloadableModuleAssets::_Internal {
 public:
  static const ::Valdi::DownloadableModuleArtifact& artifact(const DownloadableModuleAssets* msg);
};

const ::Valdi::DownloadableModuleArtifact&
DownloadableModuleAssets::_Internal::artifact(const DownloadableModuleAssets* msg) {
  return *msg->artifact_;
}
DownloadableModuleAssets::DownloadableModuleAssets(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:Valdi.DownloadableModuleAssets)
}
DownloadableModuleAssets::DownloadableModuleAssets(const DownloadableModuleAssets& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_artifact()) {
    artifact_ = new ::Valdi::DownloadableModuleArtifact(*from.artifact_);
  } else {
    artifact_ = nullptr;
  }
  device_density_ = from.device_density_;
  // @@protoc_insertion_point(copy_constructor:Valdi.DownloadableModuleAssets)
}

inline void DownloadableModuleAssets::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&artifact_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&device_density_) -
    reinterpret_cast<char*>(&artifact_)) + sizeof(device_density_));
}

DownloadableModuleAssets::~DownloadableModuleAssets() {
  // @@protoc_insertion_point(destructor:Valdi.DownloadableModuleAssets)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DownloadableModuleAssets::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete artifact_;
}

void DownloadableModuleAssets::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DownloadableModuleAssets::Clear() {
// @@protoc_insertion_point(message_clear_start:Valdi.DownloadableModuleAssets)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && artifact_ != nullptr) {
    delete artifact_;
  }
  artifact_ = nullptr;
  device_density_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* DownloadableModuleAssets::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Valdi.DownloadableModuleArtifact artifact = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_artifact(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // double device_density = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 25)) {
          device_density_ = ::PROTOBUF_NAMESPACE_ID::internal::UnalignedLoad<double>(ptr);
          ptr += sizeof(double);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DownloadableModuleAssets::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Valdi.DownloadableModuleAssets)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Valdi.DownloadableModuleArtifact artifact = 1;
  if (this->_internal_has_artifact()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::artifact(this),
        _Internal::artifact(this).GetCachedSize(), target, stream);
  }

  // double device_density = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_device_density = this->_internal_device_density();
  uint64_t raw_device_density;
  memcpy(&raw_device_density, &tmp_device_density, sizeof(tmp_device_density));
  if (raw_device_density != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteDoubleToArray(3, this->_internal_device_density(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Valdi.DownloadableModuleAssets)
  return target;
}

size_t DownloadableModuleAssets::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Valdi.DownloadableModuleAssets)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Valdi.DownloadableModuleArtifact artifact = 1;
  if (this->_internal_has_artifact()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *artifact_);
  }

  // double device_density = 3;
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_device_density = this->_internal_device_density();
  uint64_t raw_device_density;
  memcpy(&raw_device_density, &tmp_device_density, sizeof(tmp_device_density));
  if (raw_device_density != 0) {
    total_size += 1 + 8;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DownloadableModuleAssets::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DownloadableModuleAssets*>(
      &from));
}

void DownloadableModuleAssets::MergeFrom(const DownloadableModuleAssets& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Valdi.DownloadableModuleAssets)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_artifact()) {
    _internal_mutable_artifact()->::Valdi::DownloadableModuleArtifact::MergeFrom(from._internal_artifact());
  }
  static_assert(sizeof(uint64_t) == sizeof(double), "Code assumes uint64_t and double are the same size.");
  double tmp_device_density = from._internal_device_density();
  uint64_t raw_device_density;
  memcpy(&raw_device_density, &tmp_device_density, sizeof(tmp_device_density));
  if (raw_device_density != 0) {
    _internal_set_device_density(from._internal_device_density());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DownloadableModuleAssets::CopyFrom(const DownloadableModuleAssets& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Valdi.DownloadableModuleAssets)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DownloadableModuleAssets::IsInitialized() const {
  return true;
}

void DownloadableModuleAssets::InternalSwap(DownloadableModuleAssets* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DownloadableModuleAssets, device_density_)
      + sizeof(DownloadableModuleAssets::device_density_)
      - PROTOBUF_FIELD_OFFSET(DownloadableModuleAssets, artifact_)>(
          reinterpret_cast<char*>(&artifact_),
          reinterpret_cast<char*>(&other->artifact_));
}

std::string DownloadableModuleAssets::GetTypeName() const {
  return "Valdi.DownloadableModuleAssets";
}


// ===================================================================

class DownloadableModuleManifest::_Internal {
 public:
  static const ::Valdi::DownloadableModuleArtifact& artifact(const DownloadableModuleManifest* msg);
};

const ::Valdi::DownloadableModuleArtifact&
DownloadableModuleManifest::_Internal::artifact(const DownloadableModuleManifest* msg) {
  return *msg->artifact_;
}
DownloadableModuleManifest::DownloadableModuleManifest(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  assets_(arena),
  dependencies_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:Valdi.DownloadableModuleManifest)
}
DownloadableModuleManifest::DownloadableModuleManifest(const DownloadableModuleManifest& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      assets_(from.assets_),
      dependencies_(from.dependencies_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_artifact()) {
    artifact_ = new ::Valdi::DownloadableModuleArtifact(*from.artifact_);
  } else {
    artifact_ = nullptr;
  }
  has_local_assets_ = from.has_local_assets_;
  // @@protoc_insertion_point(copy_constructor:Valdi.DownloadableModuleManifest)
}

inline void DownloadableModuleManifest::SharedCtor() {
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&artifact_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&has_local_assets_) -
    reinterpret_cast<char*>(&artifact_)) + sizeof(has_local_assets_));
}

DownloadableModuleManifest::~DownloadableModuleManifest() {
  // @@protoc_insertion_point(destructor:Valdi.DownloadableModuleManifest)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DownloadableModuleManifest::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.Destroy();
  if (this != internal_default_instance()) delete artifact_;
}

void DownloadableModuleManifest::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DownloadableModuleManifest::Clear() {
// @@protoc_insertion_point(message_clear_start:Valdi.DownloadableModuleManifest)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  assets_.Clear();
  dependencies_.Clear();
  name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && artifact_ != nullptr) {
    delete artifact_;
  }
  artifact_ = nullptr;
  has_local_assets_ = false;
  _internal_metadata_.Clear<std::string>();
}

const char* DownloadableModuleManifest::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // .Valdi.DownloadableModuleArtifact artifact = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_artifact(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .Valdi.DownloadableModuleAssets assets = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_assets(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string dependencies = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_dependencies();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, nullptr));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // bool has_local_assets = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 40)) {
          has_local_assets_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DownloadableModuleManifest::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Valdi.DownloadableModuleManifest)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Valdi.DownloadableModuleManifest.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .Valdi.DownloadableModuleArtifact artifact = 2;
  if (this->_internal_has_artifact()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::artifact(this),
        _Internal::artifact(this).GetCachedSize(), target, stream);
  }

  // repeated .Valdi.DownloadableModuleAssets assets = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_assets_size()); i < n; i++) {
    const auto& repfield = this->_internal_assets(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated string dependencies = 4;
  for (int i = 0, n = this->_internal_dependencies_size(); i < n; i++) {
    const auto& s = this->_internal_dependencies(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Valdi.DownloadableModuleManifest.dependencies");
    target = stream->WriteString(4, s, target);
  }

  // bool has_local_assets = 5;
  if (this->_internal_has_local_assets() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteBoolToArray(5, this->_internal_has_local_assets(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Valdi.DownloadableModuleManifest)
  return target;
}

size_t DownloadableModuleManifest::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Valdi.DownloadableModuleManifest)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Valdi.DownloadableModuleAssets assets = 3;
  total_size += 1UL * this->_internal_assets_size();
  for (const auto& msg : this->assets_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated string dependencies = 4;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(dependencies_.size());
  for (int i = 0, n = dependencies_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      dependencies_.Get(i));
  }

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .Valdi.DownloadableModuleArtifact artifact = 2;
  if (this->_internal_has_artifact()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *artifact_);
  }

  // bool has_local_assets = 5;
  if (this->_internal_has_local_assets() != 0) {
    total_size += 1 + 1;
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DownloadableModuleManifest::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DownloadableModuleManifest*>(
      &from));
}

void DownloadableModuleManifest::MergeFrom(const DownloadableModuleManifest& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Valdi.DownloadableModuleManifest)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  assets_.MergeFrom(from.assets_);
  dependencies_.MergeFrom(from.dependencies_);
  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (from._internal_has_artifact()) {
    _internal_mutable_artifact()->::Valdi::DownloadableModuleArtifact::MergeFrom(from._internal_artifact());
  }
  if (from._internal_has_local_assets() != 0) {
    _internal_set_has_local_assets(from._internal_has_local_assets());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DownloadableModuleManifest::CopyFrom(const DownloadableModuleManifest& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Valdi.DownloadableModuleManifest)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DownloadableModuleManifest::IsInitialized() const {
  return true;
}

void DownloadableModuleManifest::InternalSwap(DownloadableModuleManifest* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  assets_.InternalSwap(&other->assets_);
  dependencies_.InternalSwap(&other->dependencies_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(DownloadableModuleManifest, has_local_assets_)
      + sizeof(DownloadableModuleManifest::has_local_assets_)
      - PROTOBUF_FIELD_OFFSET(DownloadableModuleManifest, artifact_)>(
          reinterpret_cast<char*>(&artifact_),
          reinterpret_cast<char*>(&other->artifact_));
}

std::string DownloadableModuleManifest::GetTypeName() const {
  return "Valdi.DownloadableModuleManifest";
}


// ===================================================================

class DaemonAwakeMessage::_Internal {
 public:
};

DaemonAwakeMessage::DaemonAwakeMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  service_addresses_(arena),
  device_ids_(arena),
  usernames_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:Valdi.DaemonAwakeMessage)
}
DaemonAwakeMessage::DaemonAwakeMessage(const DaemonAwakeMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      service_addresses_(from.service_addresses_),
      device_ids_(from.device_ids_),
      usernames_(from.usernames_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  process_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    process_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_process_id().empty()) {
    process_id_.Set(from._internal_process_id(), 
      GetArenaForAllocation());
  }
  service_port_ = from.service_port_;
  // @@protoc_insertion_point(copy_constructor:Valdi.DaemonAwakeMessage)
}

inline void DaemonAwakeMessage::SharedCtor() {
process_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  process_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
service_port_ = 0;
}

DaemonAwakeMessage::~DaemonAwakeMessage() {
  // @@protoc_insertion_point(destructor:Valdi.DaemonAwakeMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DaemonAwakeMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  process_id_.Destroy();
}

void DaemonAwakeMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DaemonAwakeMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:Valdi.DaemonAwakeMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  service_addresses_.Clear();
  device_ids_.Clear();
  usernames_.Clear();
  process_id_.ClearToEmpty();
  service_port_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* DaemonAwakeMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string service_addresses = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_service_addresses();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, nullptr));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // int32 service_port = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          service_port_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // string process_id = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          auto str = _internal_mutable_process_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string device_ids = 16;
      case 16:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 130)) {
          ptr -= 2;
          do {
            ptr += 2;
            auto str = _internal_add_device_ids();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, nullptr));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<130>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated string usernames = 17;
      case 17:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 138)) {
          ptr -= 2;
          do {
            ptr += 2;
            auto str = _internal_add_usernames();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, nullptr));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<138>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DaemonAwakeMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Valdi.DaemonAwakeMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string service_addresses = 1;
  for (int i = 0, n = this->_internal_service_addresses_size(); i < n; i++) {
    const auto& s = this->_internal_service_addresses(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Valdi.DaemonAwakeMessage.service_addresses");
    target = stream->WriteString(1, s, target);
  }

  // int32 service_port = 2;
  if (this->_internal_service_port() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_service_port(), target);
  }

  // string process_id = 3;
  if (!this->_internal_process_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_process_id().data(), static_cast<int>(this->_internal_process_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Valdi.DaemonAwakeMessage.process_id");
    target = stream->WriteStringMaybeAliased(
        3, this->_internal_process_id(), target);
  }

  // repeated string device_ids = 16;
  for (int i = 0, n = this->_internal_device_ids_size(); i < n; i++) {
    const auto& s = this->_internal_device_ids(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Valdi.DaemonAwakeMessage.device_ids");
    target = stream->WriteString(16, s, target);
  }

  // repeated string usernames = 17;
  for (int i = 0, n = this->_internal_usernames_size(); i < n; i++) {
    const auto& s = this->_internal_usernames(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Valdi.DaemonAwakeMessage.usernames");
    target = stream->WriteString(17, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Valdi.DaemonAwakeMessage)
  return target;
}

size_t DaemonAwakeMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Valdi.DaemonAwakeMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string service_addresses = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(service_addresses_.size());
  for (int i = 0, n = service_addresses_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      service_addresses_.Get(i));
  }

  // repeated string device_ids = 16;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(device_ids_.size());
  for (int i = 0, n = device_ids_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      device_ids_.Get(i));
  }

  // repeated string usernames = 17;
  total_size += 2 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(usernames_.size());
  for (int i = 0, n = usernames_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      usernames_.Get(i));
  }

  // string process_id = 3;
  if (!this->_internal_process_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_process_id());
  }

  // int32 service_port = 2;
  if (this->_internal_service_port() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_service_port());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DaemonAwakeMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DaemonAwakeMessage*>(
      &from));
}

void DaemonAwakeMessage::MergeFrom(const DaemonAwakeMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Valdi.DaemonAwakeMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  service_addresses_.MergeFrom(from.service_addresses_);
  device_ids_.MergeFrom(from.device_ids_);
  usernames_.MergeFrom(from.usernames_);
  if (!from._internal_process_id().empty()) {
    _internal_set_process_id(from._internal_process_id());
  }
  if (from._internal_service_port() != 0) {
    _internal_set_service_port(from._internal_service_port());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DaemonAwakeMessage::CopyFrom(const DaemonAwakeMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Valdi.DaemonAwakeMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DaemonAwakeMessage::IsInitialized() const {
  return true;
}

void DaemonAwakeMessage::InternalSwap(DaemonAwakeMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  service_addresses_.InternalSwap(&other->service_addresses_);
  device_ids_.InternalSwap(&other->device_ids_);
  usernames_.InternalSwap(&other->usernames_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &process_id_, lhs_arena,
      &other->process_id_, rhs_arena
  );
  swap(service_port_, other->service_port_);
}

std::string DaemonAwakeMessage::GetTypeName() const {
  return "Valdi.DaemonAwakeMessage";
}


// ===================================================================

class ClientAwakeMessage::_Internal {
 public:
};

ClientAwakeMessage::ClientAwakeMessage(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:Valdi.ClientAwakeMessage)
}
ClientAwakeMessage::ClientAwakeMessage(const ClientAwakeMessage& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  device_id_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    device_id_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_device_id().empty()) {
    device_id_.Set(from._internal_device_id(), 
      GetArenaForAllocation());
  }
  username_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    username_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_username().empty()) {
    username_.Set(from._internal_username(), 
      GetArenaForAllocation());
  }
  // @@protoc_insertion_point(copy_constructor:Valdi.ClientAwakeMessage)
}

inline void ClientAwakeMessage::SharedCtor() {
device_id_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  device_id_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
username_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  username_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
}

ClientAwakeMessage::~ClientAwakeMessage() {
  // @@protoc_insertion_point(destructor:Valdi.ClientAwakeMessage)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void ClientAwakeMessage::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  device_id_.Destroy();
  username_.Destroy();
}

void ClientAwakeMessage::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void ClientAwakeMessage::Clear() {
// @@protoc_insertion_point(message_clear_start:Valdi.ClientAwakeMessage)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  device_id_.ClearToEmpty();
  username_.ClearToEmpty();
  _internal_metadata_.Clear<std::string>();
}

const char* ClientAwakeMessage::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string device_id = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_device_id();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // string username = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          auto str = _internal_mutable_username();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* ClientAwakeMessage::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Valdi.ClientAwakeMessage)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string device_id = 1;
  if (!this->_internal_device_id().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_device_id().data(), static_cast<int>(this->_internal_device_id().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Valdi.ClientAwakeMessage.device_id");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_device_id(), target);
  }

  // string username = 2;
  if (!this->_internal_username().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_username().data(), static_cast<int>(this->_internal_username().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Valdi.ClientAwakeMessage.username");
    target = stream->WriteStringMaybeAliased(
        2, this->_internal_username(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Valdi.ClientAwakeMessage)
  return target;
}

size_t ClientAwakeMessage::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Valdi.ClientAwakeMessage)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string device_id = 1;
  if (!this->_internal_device_id().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_device_id());
  }

  // string username = 2;
  if (!this->_internal_username().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_username());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void ClientAwakeMessage::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const ClientAwakeMessage*>(
      &from));
}

void ClientAwakeMessage::MergeFrom(const ClientAwakeMessage& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Valdi.ClientAwakeMessage)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_device_id().empty()) {
    _internal_set_device_id(from._internal_device_id());
  }
  if (!from._internal_username().empty()) {
    _internal_set_username(from._internal_username());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void ClientAwakeMessage::CopyFrom(const ClientAwakeMessage& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Valdi.ClientAwakeMessage)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool ClientAwakeMessage::IsInitialized() const {
  return true;
}

void ClientAwakeMessage::InternalSwap(ClientAwakeMessage* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &device_id_, lhs_arena,
      &other->device_id_, rhs_arena
  );
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &username_, lhs_arena,
      &other->username_, rhs_arena
  );
}

std::string ClientAwakeMessage::GetTypeName() const {
  return "Valdi.ClientAwakeMessage";
}


// ===================================================================

class DaemonServiceDiscoveryPayload::_Internal {
 public:
  static const ::Valdi::DaemonAwakeMessage& daemon_awake_message(const DaemonServiceDiscoveryPayload* msg);
  static const ::Valdi::ClientAwakeMessage& client_awake_message(const DaemonServiceDiscoveryPayload* msg);
};

const ::Valdi::DaemonAwakeMessage&
DaemonServiceDiscoveryPayload::_Internal::daemon_awake_message(const DaemonServiceDiscoveryPayload* msg) {
  return *msg->message_.daemon_awake_message_;
}
const ::Valdi::ClientAwakeMessage&
DaemonServiceDiscoveryPayload::_Internal::client_awake_message(const DaemonServiceDiscoveryPayload* msg) {
  return *msg->message_.client_awake_message_;
}
void DaemonServiceDiscoveryPayload::set_allocated_daemon_awake_message(::Valdi::DaemonAwakeMessage* daemon_awake_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (daemon_awake_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(daemon_awake_message);
    if (message_arena != submessage_arena) {
      daemon_awake_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, daemon_awake_message, submessage_arena);
    }
    set_has_daemon_awake_message();
    message_.daemon_awake_message_ = daemon_awake_message;
  }
  // @@protoc_insertion_point(field_set_allocated:Valdi.DaemonServiceDiscoveryPayload.daemon_awake_message)
}
void DaemonServiceDiscoveryPayload::set_allocated_client_awake_message(::Valdi::ClientAwakeMessage* client_awake_message) {
  ::PROTOBUF_NAMESPACE_ID::Arena* message_arena = GetArenaForAllocation();
  clear_message();
  if (client_awake_message) {
    ::PROTOBUF_NAMESPACE_ID::Arena* submessage_arena =
      ::PROTOBUF_NAMESPACE_ID::Arena::InternalGetOwningArena(client_awake_message);
    if (message_arena != submessage_arena) {
      client_awake_message = ::PROTOBUF_NAMESPACE_ID::internal::GetOwnedMessage(
          message_arena, client_awake_message, submessage_arena);
    }
    set_has_client_awake_message();
    message_.client_awake_message_ = client_awake_message;
  }
  // @@protoc_insertion_point(field_set_allocated:Valdi.DaemonServiceDiscoveryPayload.client_awake_message)
}
DaemonServiceDiscoveryPayload::DaemonServiceDiscoveryPayload(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:Valdi.DaemonServiceDiscoveryPayload)
}
DaemonServiceDiscoveryPayload::DaemonServiceDiscoveryPayload(const DaemonServiceDiscoveryPayload& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  clear_has_message();
  switch (from.message_case()) {
    case kDaemonAwakeMessage: {
      _internal_mutable_daemon_awake_message()->::Valdi::DaemonAwakeMessage::MergeFrom(from._internal_daemon_awake_message());
      break;
    }
    case kClientAwakeMessage: {
      _internal_mutable_client_awake_message()->::Valdi::ClientAwakeMessage::MergeFrom(from._internal_client_awake_message());
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  // @@protoc_insertion_point(copy_constructor:Valdi.DaemonServiceDiscoveryPayload)
}

inline void DaemonServiceDiscoveryPayload::SharedCtor() {
clear_has_message();
}

DaemonServiceDiscoveryPayload::~DaemonServiceDiscoveryPayload() {
  // @@protoc_insertion_point(destructor:Valdi.DaemonServiceDiscoveryPayload)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void DaemonServiceDiscoveryPayload::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (has_message()) {
    clear_message();
  }
}

void DaemonServiceDiscoveryPayload::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void DaemonServiceDiscoveryPayload::clear_message() {
// @@protoc_insertion_point(one_of_clear_start:Valdi.DaemonServiceDiscoveryPayload)
  switch (message_case()) {
    case kDaemonAwakeMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete message_.daemon_awake_message_;
      }
      break;
    }
    case kClientAwakeMessage: {
      if (GetArenaForAllocation() == nullptr) {
        delete message_.client_awake_message_;
      }
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  _oneof_case_[0] = MESSAGE_NOT_SET;
}


void DaemonServiceDiscoveryPayload::Clear() {
// @@protoc_insertion_point(message_clear_start:Valdi.DaemonServiceDiscoveryPayload)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  clear_message();
  _internal_metadata_.Clear<std::string>();
}

const char* DaemonServiceDiscoveryPayload::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Valdi.DaemonAwakeMessage daemon_awake_message = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_daemon_awake_message(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Valdi.ClientAwakeMessage client_awake_message = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_client_awake_message(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* DaemonServiceDiscoveryPayload::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Valdi.DaemonServiceDiscoveryPayload)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Valdi.DaemonAwakeMessage daemon_awake_message = 1;
  if (_internal_has_daemon_awake_message()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::daemon_awake_message(this),
        _Internal::daemon_awake_message(this).GetCachedSize(), target, stream);
  }

  // .Valdi.ClientAwakeMessage client_awake_message = 2;
  if (_internal_has_client_awake_message()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::client_awake_message(this),
        _Internal::client_awake_message(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Valdi.DaemonServiceDiscoveryPayload)
  return target;
}

size_t DaemonServiceDiscoveryPayload::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Valdi.DaemonServiceDiscoveryPayload)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  switch (message_case()) {
    // .Valdi.DaemonAwakeMessage daemon_awake_message = 1;
    case kDaemonAwakeMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *message_.daemon_awake_message_);
      break;
    }
    // .Valdi.ClientAwakeMessage client_awake_message = 2;
    case kClientAwakeMessage: {
      total_size += 1 +
        ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
          *message_.client_awake_message_);
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void DaemonServiceDiscoveryPayload::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const DaemonServiceDiscoveryPayload*>(
      &from));
}

void DaemonServiceDiscoveryPayload::MergeFrom(const DaemonServiceDiscoveryPayload& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Valdi.DaemonServiceDiscoveryPayload)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  switch (from.message_case()) {
    case kDaemonAwakeMessage: {
      _internal_mutable_daemon_awake_message()->::Valdi::DaemonAwakeMessage::MergeFrom(from._internal_daemon_awake_message());
      break;
    }
    case kClientAwakeMessage: {
      _internal_mutable_client_awake_message()->::Valdi::ClientAwakeMessage::MergeFrom(from._internal_client_awake_message());
      break;
    }
    case MESSAGE_NOT_SET: {
      break;
    }
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void DaemonServiceDiscoveryPayload::CopyFrom(const DaemonServiceDiscoveryPayload& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Valdi.DaemonServiceDiscoveryPayload)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool DaemonServiceDiscoveryPayload::IsInitialized() const {
  return true;
}

void DaemonServiceDiscoveryPayload::InternalSwap(DaemonServiceDiscoveryPayload* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  swap(message_, other->message_);
  swap(_oneof_case_[0], other->_oneof_case_[0]);
}

std::string DaemonServiceDiscoveryPayload::GetTypeName() const {
  return "Valdi.DaemonServiceDiscoveryPayload";
}


// ===================================================================

class StyleNode::_Internal {
 public:
  static const ::Valdi::CSSRuleIndex& ruleindex(const StyleNode* msg);
};

const ::Valdi::CSSRuleIndex&
StyleNode::_Internal::ruleindex(const StyleNode* msg) {
  return *msg->ruleindex_;
}
StyleNode::StyleNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  styles_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:Valdi.StyleNode)
}
StyleNode::StyleNode(const StyleNode& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      styles_(from.styles_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_ruleindex()) {
    ruleindex_ = new ::Valdi::CSSRuleIndex(*from.ruleindex_);
  } else {
    ruleindex_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:Valdi.StyleNode)
}

inline void StyleNode::SharedCtor() {
ruleindex_ = nullptr;
}

StyleNode::~StyleNode() {
  // @@protoc_insertion_point(destructor:Valdi.StyleNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StyleNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete ruleindex_;
}

void StyleNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StyleNode::Clear() {
// @@protoc_insertion_point(message_clear_start:Valdi.StyleNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  styles_.Clear();
  if (GetArenaForAllocation() == nullptr && ruleindex_ != nullptr) {
    delete ruleindex_;
  }
  ruleindex_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* StyleNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .Valdi.StyleDeclaration styles = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_styles(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .Valdi.CSSRuleIndex ruleIndex = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_ruleindex(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StyleNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Valdi.StyleNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .Valdi.StyleDeclaration styles = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_styles_size()); i < n; i++) {
    const auto& repfield = this->_internal_styles(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .Valdi.CSSRuleIndex ruleIndex = 2;
  if (this->_internal_has_ruleindex()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::ruleindex(this),
        _Internal::ruleindex(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Valdi.StyleNode)
  return target;
}

size_t StyleNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Valdi.StyleNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Valdi.StyleDeclaration styles = 1;
  total_size += 1UL * this->_internal_styles_size();
  for (const auto& msg : this->styles_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .Valdi.CSSRuleIndex ruleIndex = 2;
  if (this->_internal_has_ruleindex()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *ruleindex_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StyleNode::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const StyleNode*>(
      &from));
}

void StyleNode::MergeFrom(const StyleNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Valdi.StyleNode)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  styles_.MergeFrom(from.styles_);
  if (from._internal_has_ruleindex()) {
    _internal_mutable_ruleindex()->::Valdi::CSSRuleIndex::MergeFrom(from._internal_ruleindex());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StyleNode::CopyFrom(const StyleNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Valdi.StyleNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StyleNode::IsInitialized() const {
  return true;
}

void StyleNode::InternalSwap(StyleNode* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  styles_.InternalSwap(&other->styles_);
  swap(ruleindex_, other->ruleindex_);
}

std::string StyleNode::GetTypeName() const {
  return "Valdi.StyleNode";
}


// ===================================================================

class StyleDeclaration::_Internal {
 public:
  static const ::Valdi::NodeAttribute& attribute(const StyleDeclaration* msg);
};

const ::Valdi::NodeAttribute&
StyleDeclaration::_Internal::attribute(const StyleDeclaration* msg) {
  return *msg->attribute_;
}
StyleDeclaration::StyleDeclaration(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:Valdi.StyleDeclaration)
}
StyleDeclaration::StyleDeclaration(const StyleDeclaration& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_attribute()) {
    attribute_ = new ::Valdi::NodeAttribute(*from.attribute_);
  } else {
    attribute_ = nullptr;
  }
  ::memcpy(&priority_, &from.priority_,
    static_cast<size_t>(reinterpret_cast<char*>(&id_) -
    reinterpret_cast<char*>(&priority_)) + sizeof(id_));
  // @@protoc_insertion_point(copy_constructor:Valdi.StyleDeclaration)
}

inline void StyleDeclaration::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&attribute_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&id_) -
    reinterpret_cast<char*>(&attribute_)) + sizeof(id_));
}

StyleDeclaration::~StyleDeclaration() {
  // @@protoc_insertion_point(destructor:Valdi.StyleDeclaration)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void StyleDeclaration::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete attribute_;
}

void StyleDeclaration::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void StyleDeclaration::Clear() {
// @@protoc_insertion_point(message_clear_start:Valdi.StyleDeclaration)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && attribute_ != nullptr) {
    delete attribute_;
  }
  attribute_ = nullptr;
  ::memset(&priority_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&id_) -
      reinterpret_cast<char*>(&priority_)) + sizeof(id_));
  _internal_metadata_.Clear<std::string>();
}

const char* StyleDeclaration::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Valdi.NodeAttribute attribute = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr = ctx->ParseMessage(_internal_mutable_attribute(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 priority = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          priority_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 order = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 24)) {
          order_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 id = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 32)) {
          id_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* StyleDeclaration::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Valdi.StyleDeclaration)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Valdi.NodeAttribute attribute = 1;
  if (this->_internal_has_attribute()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(1, _Internal::attribute(this),
        _Internal::attribute(this).GetCachedSize(), target, stream);
  }

  // int32 priority = 2;
  if (this->_internal_priority() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_priority(), target);
  }

  // int32 order = 3;
  if (this->_internal_order() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(3, this->_internal_order(), target);
  }

  // int32 id = 4;
  if (this->_internal_id() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(4, this->_internal_id(), target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Valdi.StyleDeclaration)
  return target;
}

size_t StyleDeclaration::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Valdi.StyleDeclaration)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Valdi.NodeAttribute attribute = 1;
  if (this->_internal_has_attribute()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *attribute_);
  }

  // int32 priority = 2;
  if (this->_internal_priority() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_priority());
  }

  // int32 order = 3;
  if (this->_internal_order() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_order());
  }

  // int32 id = 4;
  if (this->_internal_id() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_id());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void StyleDeclaration::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const StyleDeclaration*>(
      &from));
}

void StyleDeclaration::MergeFrom(const StyleDeclaration& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Valdi.StyleDeclaration)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_attribute()) {
    _internal_mutable_attribute()->::Valdi::NodeAttribute::MergeFrom(from._internal_attribute());
  }
  if (from._internal_priority() != 0) {
    _internal_set_priority(from._internal_priority());
  }
  if (from._internal_order() != 0) {
    _internal_set_order(from._internal_order());
  }
  if (from._internal_id() != 0) {
    _internal_set_id(from._internal_id());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void StyleDeclaration::CopyFrom(const StyleDeclaration& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Valdi.StyleDeclaration)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool StyleDeclaration::IsInitialized() const {
  return true;
}

void StyleDeclaration::InternalSwap(StyleDeclaration* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(StyleDeclaration, id_)
      + sizeof(StyleDeclaration::id_)
      - PROTOBUF_FIELD_OFFSET(StyleDeclaration, attribute_)>(
          reinterpret_cast<char*>(&attribute_),
          reinterpret_cast<char*>(&other->attribute_));
}

std::string StyleDeclaration::GetTypeName() const {
  return "Valdi.StyleDeclaration";
}


// ===================================================================

class NamedStyleNode::_Internal {
 public:
  static const ::Valdi::StyleNode& node(const NamedStyleNode* msg);
};

const ::Valdi::StyleNode&
NamedStyleNode::_Internal::node(const NamedStyleNode* msg) {
  return *msg->node_;
}
NamedStyleNode::NamedStyleNode(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:Valdi.NamedStyleNode)
}
NamedStyleNode::NamedStyleNode(const NamedStyleNode& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  name_.InitDefault();
  #ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
    name_.Set("", GetArenaForAllocation());
  #endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
  if (!from._internal_name().empty()) {
    name_.Set(from._internal_name(), 
      GetArenaForAllocation());
  }
  if (from._internal_has_node()) {
    node_ = new ::Valdi::StyleNode(*from.node_);
  } else {
    node_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:Valdi.NamedStyleNode)
}

inline void NamedStyleNode::SharedCtor() {
name_.InitDefault();
#ifdef PROTOBUF_FORCE_COPY_DEFAULT_STRING
  name_.Set("", GetArenaForAllocation());
#endif // PROTOBUF_FORCE_COPY_DEFAULT_STRING
node_ = nullptr;
}

NamedStyleNode::~NamedStyleNode() {
  // @@protoc_insertion_point(destructor:Valdi.NamedStyleNode)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void NamedStyleNode::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  name_.Destroy();
  if (this != internal_default_instance()) delete node_;
}

void NamedStyleNode::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void NamedStyleNode::Clear() {
// @@protoc_insertion_point(message_clear_start:Valdi.NamedStyleNode)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  name_.ClearToEmpty();
  if (GetArenaForAllocation() == nullptr && node_ != nullptr) {
    delete node_;
  }
  node_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* NamedStyleNode::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // string name = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          auto str = _internal_mutable_name();
          ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
          CHK_(ptr);
          CHK_(::_pbi::VerifyUTF8(str, nullptr));
        } else
          goto handle_unusual;
        continue;
      // .Valdi.StyleNode node = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* NamedStyleNode::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Valdi.NamedStyleNode)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      this->_internal_name().data(), static_cast<int>(this->_internal_name().length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Valdi.NamedStyleNode.name");
    target = stream->WriteStringMaybeAliased(
        1, this->_internal_name(), target);
  }

  // .Valdi.StyleNode node = 2;
  if (this->_internal_has_node()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::node(this),
        _Internal::node(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Valdi.NamedStyleNode)
  return target;
}

size_t NamedStyleNode::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Valdi.NamedStyleNode)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // string name = 1;
  if (!this->_internal_name().empty()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
        this->_internal_name());
  }

  // .Valdi.StyleNode node = 2;
  if (this->_internal_has_node()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *node_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void NamedStyleNode::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const NamedStyleNode*>(
      &from));
}

void NamedStyleNode::MergeFrom(const NamedStyleNode& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Valdi.NamedStyleNode)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (!from._internal_name().empty()) {
    _internal_set_name(from._internal_name());
  }
  if (from._internal_has_node()) {
    _internal_mutable_node()->::Valdi::StyleNode::MergeFrom(from._internal_node());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void NamedStyleNode::CopyFrom(const NamedStyleNode& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Valdi.NamedStyleNode)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool NamedStyleNode::IsInitialized() const {
  return true;
}

void NamedStyleNode::InternalSwap(NamedStyleNode* other) {
  using std::swap;
  auto* lhs_arena = GetArenaForAllocation();
  auto* rhs_arena = other->GetArenaForAllocation();
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::ArenaStringPtr::InternalSwap(
      &name_, lhs_arena,
      &other->name_, rhs_arena
  );
  swap(node_, other->node_);
}

std::string NamedStyleNode::GetTypeName() const {
  return "Valdi.NamedStyleNode";
}


// ===================================================================

class CSSRuleIndex_AttributeRule::_Internal {
 public:
  static const ::Valdi::NodeAttribute& attribute(const CSSRuleIndex_AttributeRule* msg);
  static const ::Valdi::StyleNode& node(const CSSRuleIndex_AttributeRule* msg);
};

const ::Valdi::NodeAttribute&
CSSRuleIndex_AttributeRule::_Internal::attribute(const CSSRuleIndex_AttributeRule* msg) {
  return *msg->attribute_;
}
const ::Valdi::StyleNode&
CSSRuleIndex_AttributeRule::_Internal::node(const CSSRuleIndex_AttributeRule* msg) {
  return *msg->node_;
}
CSSRuleIndex_AttributeRule::CSSRuleIndex_AttributeRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:Valdi.CSSRuleIndex.AttributeRule)
}
CSSRuleIndex_AttributeRule::CSSRuleIndex_AttributeRule(const CSSRuleIndex_AttributeRule& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_attribute()) {
    attribute_ = new ::Valdi::NodeAttribute(*from.attribute_);
  } else {
    attribute_ = nullptr;
  }
  if (from._internal_has_node()) {
    node_ = new ::Valdi::StyleNode(*from.node_);
  } else {
    node_ = nullptr;
  }
  type_ = from.type_;
  // @@protoc_insertion_point(copy_constructor:Valdi.CSSRuleIndex.AttributeRule)
}

inline void CSSRuleIndex_AttributeRule::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&attribute_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&type_) -
    reinterpret_cast<char*>(&attribute_)) + sizeof(type_));
}

CSSRuleIndex_AttributeRule::~CSSRuleIndex_AttributeRule() {
  // @@protoc_insertion_point(destructor:Valdi.CSSRuleIndex.AttributeRule)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSSRuleIndex_AttributeRule::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete attribute_;
  if (this != internal_default_instance()) delete node_;
}

void CSSRuleIndex_AttributeRule::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CSSRuleIndex_AttributeRule::Clear() {
// @@protoc_insertion_point(message_clear_start:Valdi.CSSRuleIndex.AttributeRule)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && attribute_ != nullptr) {
    delete attribute_;
  }
  attribute_ = nullptr;
  if (GetArenaForAllocation() == nullptr && node_ != nullptr) {
    delete node_;
  }
  node_ = nullptr;
  type_ = 0;
  _internal_metadata_.Clear<std::string>();
}

const char* CSSRuleIndex_AttributeRule::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // .Valdi.CSSRuleIndex.AttributeRule.Type type = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          uint64_t val = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint64(&ptr);
          CHK_(ptr);
          _internal_set_type(static_cast<::Valdi::CSSRuleIndex_AttributeRule_Type>(val));
        } else
          goto handle_unusual;
        continue;
      // .Valdi.NodeAttribute attribute = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr = ctx->ParseMessage(_internal_mutable_attribute(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Valdi.StyleNode node = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSSRuleIndex_AttributeRule::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Valdi.CSSRuleIndex.AttributeRule)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // .Valdi.CSSRuleIndex.AttributeRule.Type type = 1;
  if (this->_internal_type() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteEnumToArray(
      1, this->_internal_type(), target);
  }

  // .Valdi.NodeAttribute attribute = 2;
  if (this->_internal_has_attribute()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(2, _Internal::attribute(this),
        _Internal::attribute(this).GetCachedSize(), target, stream);
  }

  // .Valdi.StyleNode node = 3;
  if (this->_internal_has_node()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::node(this),
        _Internal::node(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Valdi.CSSRuleIndex.AttributeRule)
  return target;
}

size_t CSSRuleIndex_AttributeRule::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Valdi.CSSRuleIndex.AttributeRule)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Valdi.NodeAttribute attribute = 2;
  if (this->_internal_has_attribute()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *attribute_);
  }

  // .Valdi.StyleNode node = 3;
  if (this->_internal_has_node()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *node_);
  }

  // .Valdi.CSSRuleIndex.AttributeRule.Type type = 1;
  if (this->_internal_type() != 0) {
    total_size += 1 +
      ::_pbi::WireFormatLite::EnumSize(this->_internal_type());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CSSRuleIndex_AttributeRule::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CSSRuleIndex_AttributeRule*>(
      &from));
}

void CSSRuleIndex_AttributeRule::MergeFrom(const CSSRuleIndex_AttributeRule& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Valdi.CSSRuleIndex.AttributeRule)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_attribute()) {
    _internal_mutable_attribute()->::Valdi::NodeAttribute::MergeFrom(from._internal_attribute());
  }
  if (from._internal_has_node()) {
    _internal_mutable_node()->::Valdi::StyleNode::MergeFrom(from._internal_node());
  }
  if (from._internal_type() != 0) {
    _internal_set_type(from._internal_type());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CSSRuleIndex_AttributeRule::CopyFrom(const CSSRuleIndex_AttributeRule& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Valdi.CSSRuleIndex.AttributeRule)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSSRuleIndex_AttributeRule::IsInitialized() const {
  return true;
}

void CSSRuleIndex_AttributeRule::InternalSwap(CSSRuleIndex_AttributeRule* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSSRuleIndex_AttributeRule, type_)
      + sizeof(CSSRuleIndex_AttributeRule::type_)
      - PROTOBUF_FIELD_OFFSET(CSSRuleIndex_AttributeRule, attribute_)>(
          reinterpret_cast<char*>(&attribute_),
          reinterpret_cast<char*>(&other->attribute_));
}

std::string CSSRuleIndex_AttributeRule::GetTypeName() const {
  return "Valdi.CSSRuleIndex.AttributeRule";
}


// ===================================================================

class CSSRuleIndex_NthChildRule::_Internal {
 public:
  static const ::Valdi::StyleNode& node(const CSSRuleIndex_NthChildRule* msg);
};

const ::Valdi::StyleNode&
CSSRuleIndex_NthChildRule::_Internal::node(const CSSRuleIndex_NthChildRule* msg) {
  return *msg->node_;
}
CSSRuleIndex_NthChildRule::CSSRuleIndex_NthChildRule(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:Valdi.CSSRuleIndex.NthChildRule)
}
CSSRuleIndex_NthChildRule::CSSRuleIndex_NthChildRule(const CSSRuleIndex_NthChildRule& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite() {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_node()) {
    node_ = new ::Valdi::StyleNode(*from.node_);
  } else {
    node_ = nullptr;
  }
  ::memcpy(&n_, &from.n_,
    static_cast<size_t>(reinterpret_cast<char*>(&offset_) -
    reinterpret_cast<char*>(&n_)) + sizeof(offset_));
  // @@protoc_insertion_point(copy_constructor:Valdi.CSSRuleIndex.NthChildRule)
}

inline void CSSRuleIndex_NthChildRule::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&node_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&offset_) -
    reinterpret_cast<char*>(&node_)) + sizeof(offset_));
}

CSSRuleIndex_NthChildRule::~CSSRuleIndex_NthChildRule() {
  // @@protoc_insertion_point(destructor:Valdi.CSSRuleIndex.NthChildRule)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSSRuleIndex_NthChildRule::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete node_;
}

void CSSRuleIndex_NthChildRule::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CSSRuleIndex_NthChildRule::Clear() {
// @@protoc_insertion_point(message_clear_start:Valdi.CSSRuleIndex.NthChildRule)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  if (GetArenaForAllocation() == nullptr && node_ != nullptr) {
    delete node_;
  }
  node_ = nullptr;
  ::memset(&n_, 0, static_cast<size_t>(
      reinterpret_cast<char*>(&offset_) -
      reinterpret_cast<char*>(&n_)) + sizeof(offset_));
  _internal_metadata_.Clear<std::string>();
}

const char* CSSRuleIndex_NthChildRule::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // int32 n = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 8)) {
          n_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // int32 offset = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 16)) {
          offset_ = ::PROTOBUF_NAMESPACE_ID::internal::ReadVarint32(&ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Valdi.StyleNode node = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr = ctx->ParseMessage(_internal_mutable_node(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSSRuleIndex_NthChildRule::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Valdi.CSSRuleIndex.NthChildRule)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // int32 n = 1;
  if (this->_internal_n() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(1, this->_internal_n(), target);
  }

  // int32 offset = 2;
  if (this->_internal_offset() != 0) {
    target = stream->EnsureSpace(target);
    target = ::_pbi::WireFormatLite::WriteInt32ToArray(2, this->_internal_offset(), target);
  }

  // .Valdi.StyleNode node = 3;
  if (this->_internal_has_node()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(3, _Internal::node(this),
        _Internal::node(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Valdi.CSSRuleIndex.NthChildRule)
  return target;
}

size_t CSSRuleIndex_NthChildRule::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Valdi.CSSRuleIndex.NthChildRule)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // .Valdi.StyleNode node = 3;
  if (this->_internal_has_node()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *node_);
  }

  // int32 n = 1;
  if (this->_internal_n() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_n());
  }

  // int32 offset = 2;
  if (this->_internal_offset() != 0) {
    total_size += ::_pbi::WireFormatLite::Int32SizePlusOne(this->_internal_offset());
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CSSRuleIndex_NthChildRule::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CSSRuleIndex_NthChildRule*>(
      &from));
}

void CSSRuleIndex_NthChildRule::MergeFrom(const CSSRuleIndex_NthChildRule& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Valdi.CSSRuleIndex.NthChildRule)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  if (from._internal_has_node()) {
    _internal_mutable_node()->::Valdi::StyleNode::MergeFrom(from._internal_node());
  }
  if (from._internal_n() != 0) {
    _internal_set_n(from._internal_n());
  }
  if (from._internal_offset() != 0) {
    _internal_set_offset(from._internal_offset());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CSSRuleIndex_NthChildRule::CopyFrom(const CSSRuleIndex_NthChildRule& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Valdi.CSSRuleIndex.NthChildRule)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSSRuleIndex_NthChildRule::IsInitialized() const {
  return true;
}

void CSSRuleIndex_NthChildRule::InternalSwap(CSSRuleIndex_NthChildRule* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSSRuleIndex_NthChildRule, offset_)
      + sizeof(CSSRuleIndex_NthChildRule::offset_)
      - PROTOBUF_FIELD_OFFSET(CSSRuleIndex_NthChildRule, node_)>(
          reinterpret_cast<char*>(&node_),
          reinterpret_cast<char*>(&other->node_));
}

std::string CSSRuleIndex_NthChildRule::GetTypeName() const {
  return "Valdi.CSSRuleIndex.NthChildRule";
}


// ===================================================================

class CSSRuleIndex::_Internal {
 public:
  static const ::Valdi::StyleNode& first_child_rule(const CSSRuleIndex* msg);
  static const ::Valdi::StyleNode& last_child_rule(const CSSRuleIndex* msg);
  static const ::Valdi::CSSRuleIndex& ancestor_rules(const CSSRuleIndex* msg);
  static const ::Valdi::CSSRuleIndex& direct_parent_rules(const CSSRuleIndex* msg);
};

const ::Valdi::StyleNode&
CSSRuleIndex::_Internal::first_child_rule(const CSSRuleIndex* msg) {
  return *msg->first_child_rule_;
}
const ::Valdi::StyleNode&
CSSRuleIndex::_Internal::last_child_rule(const CSSRuleIndex* msg) {
  return *msg->last_child_rule_;
}
const ::Valdi::CSSRuleIndex&
CSSRuleIndex::_Internal::ancestor_rules(const CSSRuleIndex* msg) {
  return *msg->ancestor_rules_;
}
const ::Valdi::CSSRuleIndex&
CSSRuleIndex::_Internal::direct_parent_rules(const CSSRuleIndex* msg) {
  return *msg->direct_parent_rules_;
}
CSSRuleIndex::CSSRuleIndex(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  id_rules_(arena),
  class_rules_(arena),
  tag_rules_(arena),
  attribute_rules_(arena),
  nth_child_rules_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:Valdi.CSSRuleIndex)
}
CSSRuleIndex::CSSRuleIndex(const CSSRuleIndex& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      id_rules_(from.id_rules_),
      class_rules_(from.class_rules_),
      tag_rules_(from.tag_rules_),
      attribute_rules_(from.attribute_rules_),
      nth_child_rules_(from.nth_child_rules_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  if (from._internal_has_first_child_rule()) {
    first_child_rule_ = new ::Valdi::StyleNode(*from.first_child_rule_);
  } else {
    first_child_rule_ = nullptr;
  }
  if (from._internal_has_last_child_rule()) {
    last_child_rule_ = new ::Valdi::StyleNode(*from.last_child_rule_);
  } else {
    last_child_rule_ = nullptr;
  }
  if (from._internal_has_ancestor_rules()) {
    ancestor_rules_ = new ::Valdi::CSSRuleIndex(*from.ancestor_rules_);
  } else {
    ancestor_rules_ = nullptr;
  }
  if (from._internal_has_direct_parent_rules()) {
    direct_parent_rules_ = new ::Valdi::CSSRuleIndex(*from.direct_parent_rules_);
  } else {
    direct_parent_rules_ = nullptr;
  }
  // @@protoc_insertion_point(copy_constructor:Valdi.CSSRuleIndex)
}

inline void CSSRuleIndex::SharedCtor() {
::memset(reinterpret_cast<char*>(this) + static_cast<size_t>(
    reinterpret_cast<char*>(&first_child_rule_) - reinterpret_cast<char*>(this)),
    0, static_cast<size_t>(reinterpret_cast<char*>(&direct_parent_rules_) -
    reinterpret_cast<char*>(&first_child_rule_)) + sizeof(direct_parent_rules_));
}

CSSRuleIndex::~CSSRuleIndex() {
  // @@protoc_insertion_point(destructor:Valdi.CSSRuleIndex)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void CSSRuleIndex::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
  if (this != internal_default_instance()) delete first_child_rule_;
  if (this != internal_default_instance()) delete last_child_rule_;
  if (this != internal_default_instance()) delete ancestor_rules_;
  if (this != internal_default_instance()) delete direct_parent_rules_;
}

void CSSRuleIndex::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void CSSRuleIndex::Clear() {
// @@protoc_insertion_point(message_clear_start:Valdi.CSSRuleIndex)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  id_rules_.Clear();
  class_rules_.Clear();
  tag_rules_.Clear();
  attribute_rules_.Clear();
  nth_child_rules_.Clear();
  if (GetArenaForAllocation() == nullptr && first_child_rule_ != nullptr) {
    delete first_child_rule_;
  }
  first_child_rule_ = nullptr;
  if (GetArenaForAllocation() == nullptr && last_child_rule_ != nullptr) {
    delete last_child_rule_;
  }
  last_child_rule_ = nullptr;
  if (GetArenaForAllocation() == nullptr && ancestor_rules_ != nullptr) {
    delete ancestor_rules_;
  }
  ancestor_rules_ = nullptr;
  if (GetArenaForAllocation() == nullptr && direct_parent_rules_ != nullptr) {
    delete direct_parent_rules_;
  }
  direct_parent_rules_ = nullptr;
  _internal_metadata_.Clear<std::string>();
}

const char* CSSRuleIndex::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated .Valdi.NamedStyleNode id_rules = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_id_rules(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .Valdi.NamedStyleNode class_rules = 2;
      case 2:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 18)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_class_rules(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<18>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .Valdi.NamedStyleNode tag_rules = 3;
      case 3:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 26)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_tag_rules(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<26>(ptr));
        } else
          goto handle_unusual;
        continue;
      // repeated .Valdi.CSSRuleIndex.AttributeRule attribute_rules = 4;
      case 4:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 34)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_attribute_rules(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<34>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .Valdi.StyleNode first_child_rule = 5;
      case 5:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 42)) {
          ptr = ctx->ParseMessage(_internal_mutable_first_child_rule(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Valdi.StyleNode last_child_rule = 6;
      case 6:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 50)) {
          ptr = ctx->ParseMessage(_internal_mutable_last_child_rule(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // repeated .Valdi.CSSRuleIndex.NthChildRule nth_child_rules = 7;
      case 7:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 58)) {
          ptr -= 1;
          do {
            ptr += 1;
            ptr = ctx->ParseMessage(_internal_add_nth_child_rules(), ptr);
            CHK_(ptr);
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<58>(ptr));
        } else
          goto handle_unusual;
        continue;
      // .Valdi.CSSRuleIndex ancestor_rules = 8;
      case 8:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 66)) {
          ptr = ctx->ParseMessage(_internal_mutable_ancestor_rules(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      // .Valdi.CSSRuleIndex direct_parent_rules = 9;
      case 9:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 74)) {
          ptr = ctx->ParseMessage(_internal_mutable_direct_parent_rules(), ptr);
          CHK_(ptr);
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* CSSRuleIndex::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Valdi.CSSRuleIndex)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated .Valdi.NamedStyleNode id_rules = 1;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_id_rules_size()); i < n; i++) {
    const auto& repfield = this->_internal_id_rules(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(1, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .Valdi.NamedStyleNode class_rules = 2;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_class_rules_size()); i < n; i++) {
    const auto& repfield = this->_internal_class_rules(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(2, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .Valdi.NamedStyleNode tag_rules = 3;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_tag_rules_size()); i < n; i++) {
    const auto& repfield = this->_internal_tag_rules(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(3, repfield, repfield.GetCachedSize(), target, stream);
  }

  // repeated .Valdi.CSSRuleIndex.AttributeRule attribute_rules = 4;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_attribute_rules_size()); i < n; i++) {
    const auto& repfield = this->_internal_attribute_rules(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(4, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .Valdi.StyleNode first_child_rule = 5;
  if (this->_internal_has_first_child_rule()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(5, _Internal::first_child_rule(this),
        _Internal::first_child_rule(this).GetCachedSize(), target, stream);
  }

  // .Valdi.StyleNode last_child_rule = 6;
  if (this->_internal_has_last_child_rule()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(6, _Internal::last_child_rule(this),
        _Internal::last_child_rule(this).GetCachedSize(), target, stream);
  }

  // repeated .Valdi.CSSRuleIndex.NthChildRule nth_child_rules = 7;
  for (unsigned i = 0,
      n = static_cast<unsigned>(this->_internal_nth_child_rules_size()); i < n; i++) {
    const auto& repfield = this->_internal_nth_child_rules(i);
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
        InternalWriteMessage(7, repfield, repfield.GetCachedSize(), target, stream);
  }

  // .Valdi.CSSRuleIndex ancestor_rules = 8;
  if (this->_internal_has_ancestor_rules()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(8, _Internal::ancestor_rules(this),
        _Internal::ancestor_rules(this).GetCachedSize(), target, stream);
  }

  // .Valdi.CSSRuleIndex direct_parent_rules = 9;
  if (this->_internal_has_direct_parent_rules()) {
    target = ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::
      InternalWriteMessage(9, _Internal::direct_parent_rules(this),
        _Internal::direct_parent_rules(this).GetCachedSize(), target, stream);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Valdi.CSSRuleIndex)
  return target;
}

size_t CSSRuleIndex::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Valdi.CSSRuleIndex)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated .Valdi.NamedStyleNode id_rules = 1;
  total_size += 1UL * this->_internal_id_rules_size();
  for (const auto& msg : this->id_rules_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .Valdi.NamedStyleNode class_rules = 2;
  total_size += 1UL * this->_internal_class_rules_size();
  for (const auto& msg : this->class_rules_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .Valdi.NamedStyleNode tag_rules = 3;
  total_size += 1UL * this->_internal_tag_rules_size();
  for (const auto& msg : this->tag_rules_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .Valdi.CSSRuleIndex.AttributeRule attribute_rules = 4;
  total_size += 1UL * this->_internal_attribute_rules_size();
  for (const auto& msg : this->attribute_rules_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // repeated .Valdi.CSSRuleIndex.NthChildRule nth_child_rules = 7;
  total_size += 1UL * this->_internal_nth_child_rules_size();
  for (const auto& msg : this->nth_child_rules_) {
    total_size +=
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(msg);
  }

  // .Valdi.StyleNode first_child_rule = 5;
  if (this->_internal_has_first_child_rule()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *first_child_rule_);
  }

  // .Valdi.StyleNode last_child_rule = 6;
  if (this->_internal_has_last_child_rule()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *last_child_rule_);
  }

  // .Valdi.CSSRuleIndex ancestor_rules = 8;
  if (this->_internal_has_ancestor_rules()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *ancestor_rules_);
  }

  // .Valdi.CSSRuleIndex direct_parent_rules = 9;
  if (this->_internal_has_direct_parent_rules()) {
    total_size += 1 +
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::MessageSize(
        *direct_parent_rules_);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void CSSRuleIndex::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const CSSRuleIndex*>(
      &from));
}

void CSSRuleIndex::MergeFrom(const CSSRuleIndex& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Valdi.CSSRuleIndex)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  id_rules_.MergeFrom(from.id_rules_);
  class_rules_.MergeFrom(from.class_rules_);
  tag_rules_.MergeFrom(from.tag_rules_);
  attribute_rules_.MergeFrom(from.attribute_rules_);
  nth_child_rules_.MergeFrom(from.nth_child_rules_);
  if (from._internal_has_first_child_rule()) {
    _internal_mutable_first_child_rule()->::Valdi::StyleNode::MergeFrom(from._internal_first_child_rule());
  }
  if (from._internal_has_last_child_rule()) {
    _internal_mutable_last_child_rule()->::Valdi::StyleNode::MergeFrom(from._internal_last_child_rule());
  }
  if (from._internal_has_ancestor_rules()) {
    _internal_mutable_ancestor_rules()->::Valdi::CSSRuleIndex::MergeFrom(from._internal_ancestor_rules());
  }
  if (from._internal_has_direct_parent_rules()) {
    _internal_mutable_direct_parent_rules()->::Valdi::CSSRuleIndex::MergeFrom(from._internal_direct_parent_rules());
  }
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void CSSRuleIndex::CopyFrom(const CSSRuleIndex& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Valdi.CSSRuleIndex)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool CSSRuleIndex::IsInitialized() const {
  return true;
}

void CSSRuleIndex::InternalSwap(CSSRuleIndex* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  id_rules_.InternalSwap(&other->id_rules_);
  class_rules_.InternalSwap(&other->class_rules_);
  tag_rules_.InternalSwap(&other->tag_rules_);
  attribute_rules_.InternalSwap(&other->attribute_rules_);
  nth_child_rules_.InternalSwap(&other->nth_child_rules_);
  ::PROTOBUF_NAMESPACE_ID::internal::memswap<
      PROTOBUF_FIELD_OFFSET(CSSRuleIndex, direct_parent_rules_)
      + sizeof(CSSRuleIndex::direct_parent_rules_)
      - PROTOBUF_FIELD_OFFSET(CSSRuleIndex, first_child_rule_)>(
          reinterpret_cast<char*>(&first_child_rule_),
          reinterpret_cast<char*>(&other->first_child_rule_));
}

std::string CSSRuleIndex::GetTypeName() const {
  return "Valdi.CSSRuleIndex";
}


// ===================================================================

class TsnConfig::_Internal {
 public:
};

TsnConfig::TsnConfig(::PROTOBUF_NAMESPACE_ID::Arena* arena,
                         bool is_message_owned)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(arena, is_message_owned),
  enabled_modules_(arena) {
  SharedCtor();
  // @@protoc_insertion_point(arena_constructor:Valdi.TsnConfig)
}
TsnConfig::TsnConfig(const TsnConfig& from)
  : ::PROTOBUF_NAMESPACE_ID::MessageLite(),
      enabled_modules_(from.enabled_modules_) {
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
  // @@protoc_insertion_point(copy_constructor:Valdi.TsnConfig)
}

inline void TsnConfig::SharedCtor() {
}

TsnConfig::~TsnConfig() {
  // @@protoc_insertion_point(destructor:Valdi.TsnConfig)
  if (auto *arena = _internal_metadata_.DeleteReturnArena<std::string>()) {
  (void)arena;
    return;
  }
  SharedDtor();
}

inline void TsnConfig::SharedDtor() {
  GOOGLE_DCHECK(GetArenaForAllocation() == nullptr);
}

void TsnConfig::SetCachedSize(int size) const {
  _cached_size_.Set(size);
}

void TsnConfig::Clear() {
// @@protoc_insertion_point(message_clear_start:Valdi.TsnConfig)
  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  enabled_modules_.Clear();
  _internal_metadata_.Clear<std::string>();
}

const char* TsnConfig::_InternalParse(const char* ptr, ::_pbi::ParseContext* ctx) {
#define CHK_(x) if (PROTOBUF_PREDICT_FALSE(!(x))) goto failure
  while (!ctx->Done(&ptr)) {
    uint32_t tag;
    ptr = ::_pbi::ReadTag(ptr, &tag);
    switch (tag >> 3) {
      // repeated string enabled_modules = 1;
      case 1:
        if (PROTOBUF_PREDICT_TRUE(static_cast<uint8_t>(tag) == 10)) {
          ptr -= 1;
          do {
            ptr += 1;
            auto str = _internal_add_enabled_modules();
            ptr = ::_pbi::InlineGreedyStringParser(str, ptr, ctx);
            CHK_(ptr);
            CHK_(::_pbi::VerifyUTF8(str, nullptr));
            if (!ctx->DataAvailable(ptr)) break;
          } while (::PROTOBUF_NAMESPACE_ID::internal::ExpectTag<10>(ptr));
        } else
          goto handle_unusual;
        continue;
      default:
        goto handle_unusual;
    }  // switch
  handle_unusual:
    if ((tag == 0) || ((tag & 7) == 4)) {
      CHK_(ptr);
      ctx->SetLastTag(tag);
      goto message_done;
    }
    ptr = UnknownFieldParse(
        tag,
        _internal_metadata_.mutable_unknown_fields<std::string>(),
        ptr, ctx);
    CHK_(ptr != nullptr);
  }  // while
message_done:
  return ptr;
failure:
  ptr = nullptr;
  goto message_done;
#undef CHK_
}

uint8_t* TsnConfig::_InternalSerialize(
    uint8_t* target, ::PROTOBUF_NAMESPACE_ID::io::EpsCopyOutputStream* stream) const {
  // @@protoc_insertion_point(serialize_to_array_start:Valdi.TsnConfig)
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  // repeated string enabled_modules = 1;
  for (int i = 0, n = this->_internal_enabled_modules_size(); i < n; i++) {
    const auto& s = this->_internal_enabled_modules(i);
    ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::VerifyUtf8String(
      s.data(), static_cast<int>(s.length()),
      ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::SERIALIZE,
      "Valdi.TsnConfig.enabled_modules");
    target = stream->WriteString(1, s, target);
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    target = stream->WriteRaw(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).data(),
        static_cast<int>(_internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size()), target);
  }
  // @@protoc_insertion_point(serialize_to_array_end:Valdi.TsnConfig)
  return target;
}

size_t TsnConfig::ByteSizeLong() const {
// @@protoc_insertion_point(message_byte_size_start:Valdi.TsnConfig)
  size_t total_size = 0;

  uint32_t cached_has_bits = 0;
  // Prevent compiler warnings about cached_has_bits being unused
  (void) cached_has_bits;

  // repeated string enabled_modules = 1;
  total_size += 1 *
      ::PROTOBUF_NAMESPACE_ID::internal::FromIntSize(enabled_modules_.size());
  for (int i = 0, n = enabled_modules_.size(); i < n; i++) {
    total_size += ::PROTOBUF_NAMESPACE_ID::internal::WireFormatLite::StringSize(
      enabled_modules_.Get(i));
  }

  if (PROTOBUF_PREDICT_FALSE(_internal_metadata_.have_unknown_fields())) {
    total_size += _internal_metadata_.unknown_fields<std::string>(::PROTOBUF_NAMESPACE_ID::internal::GetEmptyString).size();
  }
  int cached_size = ::_pbi::ToCachedSize(total_size);
  SetCachedSize(cached_size);
  return total_size;
}

void TsnConfig::CheckTypeAndMergeFrom(
    const ::PROTOBUF_NAMESPACE_ID::MessageLite& from) {
  MergeFrom(*::_pbi::DownCast<const TsnConfig*>(
      &from));
}

void TsnConfig::MergeFrom(const TsnConfig& from) {
// @@protoc_insertion_point(class_specific_merge_from_start:Valdi.TsnConfig)
  GOOGLE_DCHECK_NE(&from, this);
  uint32_t cached_has_bits = 0;
  (void) cached_has_bits;

  enabled_modules_.MergeFrom(from.enabled_modules_);
  _internal_metadata_.MergeFrom<std::string>(from._internal_metadata_);
}

void TsnConfig::CopyFrom(const TsnConfig& from) {
// @@protoc_insertion_point(class_specific_copy_from_start:Valdi.TsnConfig)
  if (&from == this) return;
  Clear();
  MergeFrom(from);
}

bool TsnConfig::IsInitialized() const {
  return true;
}

void TsnConfig::InternalSwap(TsnConfig* other) {
  using std::swap;
  _internal_metadata_.InternalSwap(&other->_internal_metadata_);
  enabled_modules_.InternalSwap(&other->enabled_modules_);
}

std::string TsnConfig::GetTypeName() const {
  return "Valdi.TsnConfig";
}


// @@protoc_insertion_point(namespace_scope)
}  // namespace Valdi
PROTOBUF_NAMESPACE_OPEN
template<> PROTOBUF_NOINLINE ::Valdi::NodeAttribute*
Arena::CreateMaybeMessage< ::Valdi::NodeAttribute >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Valdi::NodeAttribute >(arena);
}
template<> PROTOBUF_NOINLINE ::Valdi::DownloadableModuleArtifact*
Arena::CreateMaybeMessage< ::Valdi::DownloadableModuleArtifact >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Valdi::DownloadableModuleArtifact >(arena);
}
template<> PROTOBUF_NOINLINE ::Valdi::DownloadableModuleAssets*
Arena::CreateMaybeMessage< ::Valdi::DownloadableModuleAssets >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Valdi::DownloadableModuleAssets >(arena);
}
template<> PROTOBUF_NOINLINE ::Valdi::DownloadableModuleManifest*
Arena::CreateMaybeMessage< ::Valdi::DownloadableModuleManifest >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Valdi::DownloadableModuleManifest >(arena);
}
template<> PROTOBUF_NOINLINE ::Valdi::DaemonAwakeMessage*
Arena::CreateMaybeMessage< ::Valdi::DaemonAwakeMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Valdi::DaemonAwakeMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::Valdi::ClientAwakeMessage*
Arena::CreateMaybeMessage< ::Valdi::ClientAwakeMessage >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Valdi::ClientAwakeMessage >(arena);
}
template<> PROTOBUF_NOINLINE ::Valdi::DaemonServiceDiscoveryPayload*
Arena::CreateMaybeMessage< ::Valdi::DaemonServiceDiscoveryPayload >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Valdi::DaemonServiceDiscoveryPayload >(arena);
}
template<> PROTOBUF_NOINLINE ::Valdi::StyleNode*
Arena::CreateMaybeMessage< ::Valdi::StyleNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Valdi::StyleNode >(arena);
}
template<> PROTOBUF_NOINLINE ::Valdi::StyleDeclaration*
Arena::CreateMaybeMessage< ::Valdi::StyleDeclaration >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Valdi::StyleDeclaration >(arena);
}
template<> PROTOBUF_NOINLINE ::Valdi::NamedStyleNode*
Arena::CreateMaybeMessage< ::Valdi::NamedStyleNode >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Valdi::NamedStyleNode >(arena);
}
template<> PROTOBUF_NOINLINE ::Valdi::CSSRuleIndex_AttributeRule*
Arena::CreateMaybeMessage< ::Valdi::CSSRuleIndex_AttributeRule >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Valdi::CSSRuleIndex_AttributeRule >(arena);
}
template<> PROTOBUF_NOINLINE ::Valdi::CSSRuleIndex_NthChildRule*
Arena::CreateMaybeMessage< ::Valdi::CSSRuleIndex_NthChildRule >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Valdi::CSSRuleIndex_NthChildRule >(arena);
}
template<> PROTOBUF_NOINLINE ::Valdi::CSSRuleIndex*
Arena::CreateMaybeMessage< ::Valdi::CSSRuleIndex >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Valdi::CSSRuleIndex >(arena);
}
template<> PROTOBUF_NOINLINE ::Valdi::TsnConfig*
Arena::CreateMaybeMessage< ::Valdi::TsnConfig >(Arena* arena) {
  return Arena::CreateMessageInternal< ::Valdi::TsnConfig >(arena);
}
PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)
#include <google/protobuf/port_undef.inc>
