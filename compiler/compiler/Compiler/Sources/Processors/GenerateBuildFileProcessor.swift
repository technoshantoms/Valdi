import Foundation

private struct AndroidBazelFile {
    let macroPath: String
    let macroName: String

    let snakeCaseName: String
    let snakeCaseDeps: [String]

    func generateContents() -> String {
        return """
        ### THIS IS A GENERATED FILE, DO NOT EDIT MANUALLY
        ###
        ### This file was generated by the Valdi compiler from the \(snakeCaseName) module.

        load("\(macroPath)", "\(macroName)")

        snake_case_name = "\(snakeCaseName)"

        snake_case_deps = [
            \(snakeCaseDeps.map { "\"\($0)\"" }.joined(separator: ",\n    "))\(snakeCaseDeps.count > 0 ? "," : "")
        ]

        \(macroName)(
            snake_case_name,
            snake_case_deps,
        )

        """
    }
}

private struct WebPackageFile {
    let npmName: String
    let version: String
    let publishConfig: String
    let main: String
    let dependencies: String

    func generateContents() -> String {
        // For realz, the only way to add comments to a JSON file is to make them
        // part of the object. This is a garbage format. <- LOL
        return """
        {
            "_warning": "THIS IS A GENERATED FILE, DO NOT EDIT MANUALLY",
            "_source": "This file was generated by the Valdi compiler from the \(npmName) module.",
            "name": "\(npmName)",
            "version": "\(version)",
            "description": "",
            "main": "\(main)",
            "scripts":
                { "test": "echo \\\"Error: no test specified\\\" && exit 1" },
            "author": "",
            "license": "ISC",
            "publishConfig": \(publishConfig),
            "dependencies": {
        \(dependencies)
            }
        }
        """
    }
}

final class GenerateBuildFileProcessor: CompilationProcessor {

    var description: String {
        return "Generating modularized BUILD files"
    }

    private let projectConfig: ValdiProjectConfig

    init(projectConfig: ValdiProjectConfig) {
        self.projectConfig = projectConfig
    }

    private func generateAndroidBuildFile(item: CompilationItem) -> CompilationItem? {
        guard let androidBuildConfig = projectConfig.androidBuildFileConfig else {
            return nil
        }
        let bundleInfo = item.bundleInfo
        guard let metadataURL = bundleInfo.androidDebugOutputDirectories?.metadataURL else {
            return nil
        }

        do {
            // we can improve the dependency graph of the resulting targets if we keep track of
            // internal deps separately from dependencies that have to be public
            // TODO: separate internal_deps from public_deps
            let allDependencies = bundleInfo.allDependencies
            let snakeCaseDeps = Set(allDependencies)
                .filter { !$0.isRoot }
                .map { $0.name }
                .sorted()

            let bazelFile = AndroidBazelFile(
                macroPath: androidBuildConfig.buildFileMacroPath,
                macroName: androidBuildConfig.buildFileMacroName,
                snakeCaseName: bundleInfo.name,
                snakeCaseDeps: snakeCaseDeps
            )
            let bazelFileContents = bazelFile.generateContents()
            let file = File.data(try bazelFileContents.utf8Data())
            let outputURL = metadataURL.appendingPathComponent(androidBuildConfig.buildFileName, isDirectory: false)
            let finalFile = FinalFile(outputURL: outputURL, file: file, platform: .android, kind: .unknown)
            return item.with(newKind: .finalFile(finalFile))
        } catch let error {
            return item.with(error: error)
        }
    }

    private func generateWebPackageFile(item: CompilationItem) -> CompilationItem? {
            guard let webBuildConfig = projectConfig.webBuildFileConfig else {
                return nil
            }
            let bundleInfo = item.bundleInfo
            guard let metadataURL = bundleInfo.webDebugOutputDirectories?.metadataURL else {
                return nil
            }

            var npmName = bundleInfo.name
            if !bundleInfo.webNpmScope.isEmpty {
                npmName = "@\(bundleInfo.webNpmScope)/\(npmName)"
            }
            let version = bundleInfo.webVersion
            let publishConfig = bundleInfo.webPublishConfig
            let main = bundleInfo.webMain

            let allDependencies = bundleInfo.allDependencies
            let rawDeps = Set(allDependencies)
                .filter { !$0.isRoot }
                .map { 
                    let scope = !$0.webNpmScope.isEmpty ? "@\($0.webNpmScope)/" : ""
                    return "\t\t\"\(scope)\($0.name)\" : \"\($0.webVersion)\""
                }
            
            let dependencies = rawDeps.joined(separator: ",\n")

            do {
                let packageFile = WebPackageFile(
                    npmName: npmName,
                    version: version,
                    publishConfig: publishConfig,
                    main: main,
                    dependencies: dependencies
                )
                let packageFileContents = packageFile.generateContents()
                let file = File.data(try packageFileContents.utf8Data())
                let outputURL = metadataURL.appendingPathComponent(webBuildConfig.buildFileName, isDirectory: false)
                let finalFile = FinalFile(outputURL: outputURL, file: file, platform: .ios, kind: .unknown)
                return item.with(newKind: .finalFile(finalFile))
            } catch let error {
                return item.with(error: error)
            }
        }

    func process(items: CompilationItems) throws -> CompilationItems {
        return items.select { (item) -> File? in
            guard case .moduleYaml(let file) = item.kind else { return nil }
            return file
        }.transformEachConcurrently { selectedItem -> [CompilationItem] in
            let android = generateAndroidBuildFile(item: selectedItem.item)
            let web = generateWebPackageFile(item: selectedItem.item)
            return [android, web].compactMap { $0 }
        }
    }

}
