// DO NOT EDIT.
// swift-format-ignore-file
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: valdi-daemon-registry.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that you are building against the same version of the API
// that was used to generate this file.
private struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Describes a Valdi daemon service and the devices it's targeting
struct ValdiDaemonRegistry_DaemonService {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var key: String = String()

  var serviceAddresses: [String] = []

  var servicePort: Int32 = 0

  var processID: String = String()

  var deviceIds: [String] = []

  var usernames: [String] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()
}

struct ValdiDaemonRegistry_ListServicesRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var filters: ValdiDaemonRegistry_ListServicesFilters {
    get {return _filters ?? ValdiDaemonRegistry_ListServicesFilters()}
    set {_filters = newValue}
  }
  /// Returns true if `filters` has been explicitly set.
  var hasFilters: Bool {return self._filters != nil}
  /// Clears the value of `filters`. Subsequent reads from it will return its default value.
  mutating func clearFilters() {self._filters = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _filters: ValdiDaemonRegistry_ListServicesFilters?
}

struct ValdiDaemonRegistry_ListServicesFilters {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var deviceID: String = String()

  var username: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()
}

struct ValdiDaemonRegistry_ListServicesResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var services: [ValdiDaemonRegistry_DaemonService] = []

  var unknownFields = SwiftProtobuf.UnknownStorage()
}

struct ValdiDaemonRegistry_RegisterServiceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var service: ValdiDaemonRegistry_DaemonService {
    get {return _service ?? ValdiDaemonRegistry_DaemonService()}
    set {_service = newValue}
  }
  /// Returns true if `service` has been explicitly set.
  var hasService: Bool {return self._service != nil}
  /// Clears the value of `service`. Subsequent reads from it will return its default value.
  mutating func clearService() {self._service = nil}

  var unknownFields = SwiftProtobuf.UnknownStorage()

  init() {}

  fileprivate var _service: ValdiDaemonRegistry_DaemonService?
}

struct ValdiDaemonRegistry_RegisterServiceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()
}

struct ValdiDaemonRegistry_UnregisterServiceRequest {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var serviceKey: String = String()

  var unknownFields = SwiftProtobuf.UnknownStorage()
}

struct ValdiDaemonRegistry_UnregisterServiceResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  var success: Bool = false

  var unknownFields = SwiftProtobuf.UnknownStorage()
}

#if swift(>=5.5) && canImport(_Concurrency)
extension ValdiDaemonRegistry_DaemonService: @unchecked Sendable {}
extension ValdiDaemonRegistry_ListServicesRequest: @unchecked Sendable {}
extension ValdiDaemonRegistry_ListServicesFilters: @unchecked Sendable {}
extension ValdiDaemonRegistry_ListServicesResponse: @unchecked Sendable {}
extension ValdiDaemonRegistry_RegisterServiceRequest: @unchecked Sendable {}
extension ValdiDaemonRegistry_RegisterServiceResponse: @unchecked Sendable {}
extension ValdiDaemonRegistry_UnregisterServiceRequest: @unchecked Sendable {}
extension ValdiDaemonRegistry_UnregisterServiceResponse: @unchecked Sendable {}
#endif  // swift(>=5.5) && canImport(_Concurrency)

// MARK: - Code below here is support for the SwiftProtobuf runtime.

private let _protobuf_package = "ValdiDaemonRegistry"

extension ValdiDaemonRegistry_DaemonService: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".DaemonService"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "key"),
    2: .standard(proto: "service_addresses"),
    3: .standard(proto: "service_port"),
    4: .standard(proto: "process_id"),
    5: .standard(proto: "device_ids"),
    6: .same(proto: "usernames")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.key) }()
      case 2: try { try decoder.decodeRepeatedStringField(value: &self.serviceAddresses) }()
      case 3: try { try decoder.decodeSingularInt32Field(value: &self.servicePort) }()
      case 4: try { try decoder.decodeSingularStringField(value: &self.processID) }()
      case 5: try { try decoder.decodeRepeatedStringField(value: &self.deviceIds) }()
      case 6: try { try decoder.decodeRepeatedStringField(value: &self.usernames) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.key.isEmpty {
      try visitor.visitSingularStringField(value: self.key, fieldNumber: 1)
    }
    if !self.serviceAddresses.isEmpty {
      try visitor.visitRepeatedStringField(value: self.serviceAddresses, fieldNumber: 2)
    }
    if self.servicePort != 0 {
      try visitor.visitSingularInt32Field(value: self.servicePort, fieldNumber: 3)
    }
    if !self.processID.isEmpty {
      try visitor.visitSingularStringField(value: self.processID, fieldNumber: 4)
    }
    if !self.deviceIds.isEmpty {
      try visitor.visitRepeatedStringField(value: self.deviceIds, fieldNumber: 5)
    }
    if !self.usernames.isEmpty {
      try visitor.visitRepeatedStringField(value: self.usernames, fieldNumber: 6)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ValdiDaemonRegistry_DaemonService, rhs: ValdiDaemonRegistry_DaemonService) -> Bool {
    if lhs.key != rhs.key {return false}
    if lhs.serviceAddresses != rhs.serviceAddresses {return false}
    if lhs.servicePort != rhs.servicePort {return false}
    if lhs.processID != rhs.processID {return false}
    if lhs.deviceIds != rhs.deviceIds {return false}
    if lhs.usernames != rhs.usernames {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ValdiDaemonRegistry_ListServicesRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListServicesRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "filters")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._filters) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._filters {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ValdiDaemonRegistry_ListServicesRequest, rhs: ValdiDaemonRegistry_ListServicesRequest) -> Bool {
    if lhs._filters != rhs._filters {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ValdiDaemonRegistry_ListServicesFilters: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListServicesFilters"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "device_id"),
    2: .same(proto: "username")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.deviceID) }()
      case 2: try { try decoder.decodeSingularStringField(value: &self.username) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.deviceID.isEmpty {
      try visitor.visitSingularStringField(value: self.deviceID, fieldNumber: 1)
    }
    if !self.username.isEmpty {
      try visitor.visitSingularStringField(value: self.username, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ValdiDaemonRegistry_ListServicesFilters, rhs: ValdiDaemonRegistry_ListServicesFilters) -> Bool {
    if lhs.deviceID != rhs.deviceID {return false}
    if lhs.username != rhs.username {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ValdiDaemonRegistry_ListServicesResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".ListServicesResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "services")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeRepeatedMessageField(value: &self.services) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.services.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.services, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ValdiDaemonRegistry_ListServicesResponse, rhs: ValdiDaemonRegistry_ListServicesResponse) -> Bool {
    if lhs.services != rhs.services {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ValdiDaemonRegistry_RegisterServiceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterServiceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "service")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularMessageField(value: &self._service) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    // The use of inline closures is to circumvent an issue where the compiler
    // allocates stack space for every if/case branch local when no optimizations
    // are enabled. https://github.com/apple/swift-protobuf/issues/1034 and
    // https://github.com/apple/swift-protobuf/issues/1182
    try { if let v = self._service {
      try visitor.visitSingularMessageField(value: v, fieldNumber: 1)
    } }()
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ValdiDaemonRegistry_RegisterServiceRequest, rhs: ValdiDaemonRegistry_RegisterServiceRequest) -> Bool {
    if lhs._service != rhs._service {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ValdiDaemonRegistry_RegisterServiceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".RegisterServiceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ValdiDaemonRegistry_RegisterServiceResponse, rhs: ValdiDaemonRegistry_RegisterServiceResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ValdiDaemonRegistry_UnregisterServiceRequest: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnregisterServiceRequest"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .standard(proto: "service_key")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularStringField(value: &self.serviceKey) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.serviceKey.isEmpty {
      try visitor.visitSingularStringField(value: self.serviceKey, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ValdiDaemonRegistry_UnregisterServiceRequest, rhs: ValdiDaemonRegistry_UnregisterServiceRequest) -> Bool {
    if lhs.serviceKey != rhs.serviceKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension ValdiDaemonRegistry_UnregisterServiceResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  static let protoMessageName: String = _protobuf_package + ".UnregisterServiceResponse"
  static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "success")
  ]

  mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      // The use of inline closures is to circumvent an issue where the compiler
      // allocates stack space for every case branch when no optimizations are
      // enabled. https://github.com/apple/swift-protobuf/issues/1034
      switch fieldNumber {
      case 1: try { try decoder.decodeSingularBoolField(value: &self.success) }()
      default: break
      }
    }
  }

  func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.success != false {
      try visitor.visitSingularBoolField(value: self.success, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  static func ==(lhs: ValdiDaemonRegistry_UnregisterServiceResponse, rhs: ValdiDaemonRegistry_UnregisterServiceResponse) -> Bool {
    if lhs.success != rhs.success {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
