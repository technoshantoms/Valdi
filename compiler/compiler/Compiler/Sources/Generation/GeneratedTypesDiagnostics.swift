//
//  GeneratedTypesDiagnostics.swift
//  Compiler
//
//  Created by saniul on 17/07/2019.
//

import Foundation

//////////
// This file defines set of easily-encodable structs describing the classes,
// interfaces, enums etc. generated by the compiler.
// These are then used to emit diagnostics JSON files
//////////

struct GeneratedTypesSummary: Encodable {
    let sourceFilePath: String
    let generatedTypes: [GeneratedTypeDescription]

    func toFile() -> File {
        let data = (try? toJSON(outputFormatting: [.prettyPrinted, .sortedKeys])) ?? Data()
        let file = File.data(data)
        return file
    }
}

enum GeneratedTypeDescription: Encodable {
    case `class`(GeneratedNativeClassDescription)
    case interface(GeneratedNativeInterfaceDescription)
    case `enum`(GeneratedEnumDescription)
    case function(GeneratedFunctionDescription)
    case viewClass(GeneratedViewClassDescription)

    enum CodingKeys: CodingKey {
        case `class`
        case interface
        case `enum`
        case function
        case viewClass
    }

    func encode(to encoder: Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
        case let .class(value):
            try container.encode(value, forKey: .class)
        case let .interface(value):
            try container.encode(value, forKey: .interface)
        case let .enum(value):
            try container.encode(value, forKey: .enum)
        case let .function(value):
            try container.encode(value, forKey: .function)
        case let .viewClass(value):
            try container.encode(value, forKey: .viewClass)
        }
    }

    func typeName(for platform: Platform) -> String? {
        switch platform {
        case .ios:
            return iosTypeName
        case .android:
            return androidTypeName
        case .web:
            return webTypeName
        case .cpp:
            return cppTypeName
        }
    }

    var iosTypeName: String? {
        switch self {
        case let .class(this):
            return this.iosTypeName
        case let .interface(this):
            return this.iosTypeName
        case let .enum(this):
            return this.iosTypeName
        case let .function(this):
            return this.containingIosTypeName
        case let .viewClass(this):
            return this.iosTypeName
        }
    }

    var androidTypeName: String? {
        switch self {
        case let .class(this):
            return this.androidTypeName
        case let .interface(this):
            return this.androidTypeName
        case let .enum(this):
            return this.androidTypeName
        case let .function(this):
            return this.containingAndroidTypeName
        case let .viewClass(this):
            return this.androidClassName
        }
    }

    var cppTypeName: String? {
        switch self {
        case let .class(this):
            return this.cppTypeName
        case let .interface(this):
            return this.cppTypeName
        case let .enum(this):
            return this.cppTypeName
        case .function:
            // TODO: not supported yet
            return nil
        case .viewClass:
            return nil
        }
    }

    var webTypeName: String? {
        // TODO: Implement this
        return nil
    }

    var valueToSortBy: String {
        switch self {
        case let .class(this):
            return this.iosTypeName ?? this.androidTypeName ?? ""
        case let .interface(this):
            return this.iosTypeName ?? this.androidTypeName ?? ""
        case let .enum(this):
            return this.iosTypeName ?? this.androidTypeName ?? ""
        case let .function(this):
            return this.functionName
        case let .viewClass(this):
            return this.iosTypeName ?? this.androidClassName ?? ""
        }
    }
}

struct GeneratedNativeClassDescription: Encodable {
    let iosTypeName: String?
    let androidTypeName: String?
    let cppTypeName: String?
    let properties: [PropertyDescription]

    init(model: ValdiModel) {
        iosTypeName = model.iosType?.name
        androidTypeName = model.androidClassName
        cppTypeName = model.cppType?.declaration.fullTypeName
        properties = model.properties.map(PropertyDescription.init)
    }
}

struct GeneratedNativeInterfaceDescription: Encodable {
    let iosTypeName: String?
    let androidTypeName: String?
    let cppTypeName: String?
    let properties: [PropertyDescription]

    init(model: ValdiModel) {
        iosTypeName = model.iosType?.name
        androidTypeName = model.androidClassName
        cppTypeName = model.cppType?.declaration.fullTypeName
        properties = model.properties.map(PropertyDescription.init)
    }
}

struct GeneratedEnumDescription: Encodable {
    let iosTypeName: String?
    let androidTypeName: String?
    let cppTypeName: String?

    let intCases: [EnumCase<Int>]?
    let stringCases: [EnumCase<String>]?

    static func from(exportedEnum: ExportedEnum) -> GeneratedEnumDescription {
        let intCases: [EnumCase<Int>]?
        let stringCases: [EnumCase<String>]?
        switch exportedEnum.cases {
        case let .enum(cases):
            intCases = cases
            stringCases = nil
        case let .stringEnum(cases):
            intCases = nil
            stringCases = cases
        }
        return GeneratedEnumDescription(iosTypeName: exportedEnum.iosType?.name,
                                        androidTypeName: exportedEnum.androidTypeName,
                                        cppTypeName: exportedEnum.cppType?.declaration.fullTypeName,
                                        intCases: intCases,
                                        stringCases: stringCases)
    }
}

struct GeneratedFunctionDescription: Encodable {
    let containingIosTypeName: String?
    let containingAndroidTypeName: String?
    let functionName: String
    let parameters: [PropertyDescription]
    let returnType: PropertyTypeDescription

    static func from(exportedFunction: ExportedFunction) -> GeneratedFunctionDescription {
        return GeneratedFunctionDescription(containingIosTypeName: exportedFunction.containingIosType?.name,
                                            containingAndroidTypeName: exportedFunction.containingAndroidTypeName,
                                            functionName: exportedFunction.functionName,
                                            parameters: exportedFunction.parameters.map(PropertyDescription.init),
                                            returnType: PropertyTypeDescription(propType: exportedFunction.returnType))
    }
}

struct GeneratedViewClassDescription: Encodable {
    let iosTypeName: String?
    let androidClassName: String?

    let iosViewModelClassName: String?
    let androidViewModelClassName: String?

    let iosComponentContextClassName: String?
    let androidComponentContextClassName: String?

    var accessors: [AccessorDescription]?
    var nativeActions: [String]?
    var emitActions: [String]?

    struct AccessorDescription: Encodable {
        let iosTypeName: String?
        let androidClassName: String?
        let name: String
    }
}

// class for indirection
class PropertyTypeDescription: Encodable {
    let typeStr: String

    private(set) var functionTypeMetadata: FunctionTypeMetadata?
    struct FunctionTypeMetadata: Encodable {
        let parameters: [PropertyDescription]
        let returnType: PropertyTypeDescription
    }

    private(set) var genericTypeMetadata: GenericTypeMetadata?
    struct GenericTypeMetadata: Encodable {
        let types: [PropertyTypeDescription]
    }

    private(set) var customTypeMetadata: CustomTypeMetadata?
    struct CustomTypeMetadata: Encodable {
        let iosTypeName: String?
        let androidClassName: String?
    }

    private(set) var typeParameterMetadata: TypeParameterMetadata?
    struct TypeParameterMetadata: Encodable {
        let typeParameterName: String
    }

    init(propType: ValdiModelPropertyType) {
        switch propType {
        case .string:
            typeStr = "string"
        case .double:
            typeStr = "double"
        case .bool:
            typeStr = "bool"
        case .long:
            typeStr = "long"
        case let .array(elementType):
            typeStr = "array"
            let description = PropertyTypeDescription(propType: elementType)
            genericTypeMetadata = GenericTypeMetadata(types: [description])
        case .bytes:
            typeStr = "bytes"
        case .map:
            typeStr = "map"
        case .any:
            typeStr = "any"
        case .void:
            typeStr = "void"
        case let .function(parameters, returnType, _, _):
            typeStr = "function"
            let parameters = parameters.map(PropertyDescription.init)
            let returnType = PropertyTypeDescription(propType: returnType)
            functionTypeMetadata = FunctionTypeMetadata(parameters: parameters, returnType: returnType)
        case let .object(nodeClassMapping):
            typeStr = "object"
            customTypeMetadata = CustomTypeMetadata(iosTypeName: nodeClassMapping.iosType?.name, androidClassName: nodeClassMapping.androidClassName)
        case let .genericTypeParameter(name):
            typeStr = "genericTypeParameter"
            typeParameterMetadata = .init(typeParameterName: name)
        case let .genericObject(nodeClassMapping, _):
            typeStr = "genericObject"
            customTypeMetadata = CustomTypeMetadata(iosTypeName: nodeClassMapping.iosType?.name, androidClassName: nodeClassMapping.androidClassName)
        case let .enum(nodeClassMapping):
            typeStr = "enum"
            customTypeMetadata = CustomTypeMetadata(iosTypeName: nodeClassMapping.iosType?.name, androidClassName: nodeClassMapping.androidClassName)
        case .promise(let typeArgument):
            typeStr = "promise"
            genericTypeMetadata = GenericTypeMetadata(types: [PropertyTypeDescription(propType: typeArgument)])
        case let .nullable(innerType):
            let innerDescription = PropertyTypeDescription(propType: innerType)
            typeStr = "\(innerDescription.typeStr)?"
        }
    }
}

struct PropertyDescription: Encodable {
    let name: String
    let isOptional: Bool

    let type: PropertyTypeDescription

    // not for interfaces
    let omitConstructor: OmitConstructorParams?

    init(prop: ValdiModelProperty) {
        name = prop.name
        isOptional = prop.type.isOptional
        type = PropertyTypeDescription(propType: prop.type.unwrappingOptional)
        omitConstructor = prop.omitConstructor
    }
}
