diff --git a/rules/android_local_test/BUILD b/rules/android_local_test/BUILD
new file mode 100644
index 00000000000..52f4637db46
--- /dev/null
+++ b/rules/android_local_test/BUILD
@@ -0,0 +1,28 @@
+# The android_library rule.
+
+load("@bazel_skylib//:bzl_library.bzl", "bzl_library")
+
+package(
+    default_applicable_licenses = ["//:license"],
+    default_visibility =
+        ["//:__subpackages__"],
+)
+
+licenses(["notice"])
+
+exports_files(["rule.bzl"])
+
+filegroup(
+    name = "all_files",
+    srcs = glob(["**"]),
+)
+
+bzl_library(
+    name = "bzl",
+    srcs = glob(["*.bzl"]),
+    deps = [
+        "//rules:common_bzl",
+        "//rules/flags:bzl",
+        "@bazel_skylib//rules:common_settings",
+    ],
+)
diff --git a/rules/android_local_test/android_local_test.bzl b/rules/android_local_test/android_local_test.bzl
new file mode 100644
index 00000000000..9b1fe39b8de
--- /dev/null
+++ b/rules/android_local_test/android_local_test.bzl
@@ -0,0 +1,27 @@
+# Copyright 2018 The Bazel Authors. All rights reserved.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#    http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+"""Bazel rule for Android local test."""
+
+load(":migration_tag_DONOTUSE.bzl", _add_migration_tag = "add_migration_tag")
+
+def android_local_test(**attrs):
+    """Bazel android_local_test rule.
+
+    https://docs.bazel.build/versions/master/be/android.html#android_local_test
+
+    Args:
+      **attrs: Rule attributes
+    """
+    native.android_local_test(**_add_migration_tag(attrs))
diff --git a/rules/android_local_test/attrs.bzl b/rules/android_local_test/attrs.bzl
new file mode 100644
index 00000000000..77d3e73de38
--- /dev/null
+++ b/rules/android_local_test/attrs.bzl
@@ -0,0 +1,224 @@
+# Copyright 2020 The Bazel Authors. All rights reserved.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#    http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+"""Attributes."""
+
+load(
+    "//rules:attrs.bzl",
+    _attrs = "attrs",
+)
+
+def make_attrs(additional_aspects = [], native_libs_transition = None):
+    return _attrs.add(
+        dict(
+            deps = attr.label_list(
+                allow_files = True,
+                allow_rules = [
+                    "aar_import",
+                    "android_library",
+                    "java_import",
+                    "java_library",
+                    "java_lite_proto_library",
+                ],
+                aspects = additional_aspects,
+                providers = [[CcInfo], [JavaInfo]],
+                doc = """
+                The list of libraries to be tested as well as additional libraries to be linked
+                in to the target.
+                All resources, assets and manifest files declared in Android rules in the transitive
+                closure of this attribute are made available in the test.
+
+                The list of allowed rules in `deps` are `aar_import`,
+                `android_library`, `java_import`, `java_library`,
+                and `java_lite_proto_library`.
+                """,
+                cfg = native_libs_transition,
+            ),
+            feature_flags = attr.label_keyed_string_dict(
+                doc = "This is a deprecated feature. Do not use it.",
+            ),
+            jvm_flags = attr.string_list(
+                doc = """
+                A list of flags to embed in the wrapper script generated for running this binary.
+                Subject to [$(location / execpath / rootpath)](https://docs.bazel.build/versions/main/be/make-variables.html#predefined_label_variables) and
+                ["Make variable"](https://docs.bazel.build/versions/main/be/make-variables.html) substitution, and
+                [Bourne shell tokenization](https://docs.bazel.build/versions/main/be/common-definitions.html#sh-tokenization).
+
+                The wrapper script for a Java binary includes a CLASSPATH definition
+                (to find all the dependent jars) and invokes the right Java interpreter.
+                The command line generated by the wrapper script includes the name of
+                the main class followed by a `"$@"` so you can pass along other
+                arguments after the classname.  However, arguments intended for parsing
+                by the JVM must be specified _before_ the classname on the command
+                line.  The contents of `jvm_flags` are added to the wrapper
+                script before the classname is listed.
+
+                Note that this attribute has _no effect_ on `*_deploy.jar`
+                outputs.
+                """,
+            ),
+            manifest_values = attr.string_dict(
+                doc = """
+                A dictionary of values to be overridden in the manifest. Any instance of ${name} in the
+                manifest will be replaced with the value corresponding to name in this dictionary.
+                `applicationId`, `versionCode`, `versionName`,
+                `minSdkVersion`, `targetSdkVersion` and
+                `maxSdkVersion` will also override the corresponding attributes
+                of the manifest and
+                uses-sdk tags. `packageName` will be ignored and will be set from either
+                `applicationId` if
+                specified or the package in the manifest.
+                It is not necessary to have a manifest on the rule in order to use manifest_values.
+                """,
+            ),
+            nocompress_extensions = attr.string_list(
+                doc = "A list of file extensions to leave uncompressed in the resource apk.",
+            ),
+            resources = attr.label_list(
+                allow_files = True,
+                doc = """
+                A list of data files to include in a Java jar.
+
+                If resources are specified, they will be bundled in the jar along with the usual
+                `.class` files produced by compilation. The location of the resources inside
+                of the jar file is determined by the project structure. Bazel first looks for Maven's
+                [standard directory layout](https://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html),
+                (a "src" directory followed by a "resources" directory grandchild). If that is not
+                found, Bazel then looks for the topmost directory named "java" or "javatests" (so, for
+                example, if a resource is at `&lt;workspace root&gt;/x/java/y/java/z`, the
+                path of the resource will be `y/java/z`. This heuristic cannot be overridden.
+
+                Resources may be source files or generated files.
+
+                """,
+            ),
+            runtime_deps = attr.label_list(
+                allow_files = True,
+                doc = """
+                Libraries to make available to the final binary or test at runtime only.
+                Like ordinary `deps`, these will appear on the runtime classpath, but unlike
+                them, not on the compile-time classpath. Dependencies needed only at runtime should be
+                listed here. Dependency-analysis tools should ignore targets that appear in both
+                `runtime_deps` and `deps`.
+                """,
+                # TODO(timpeut): verify we can require JavaInfo
+                # providers = [JavaInfo],
+                cfg = native_libs_transition,
+            ),
+            srcs = attr.label_list(
+                # TODO(timpeut): order independent
+                # TODO(timpeut): direct compile time input
+                allow_files = [".java", ".srcjar", ".properties", ".xmb"],
+                doc = """
+                The list of source files that are processed to create the target.
+                Required except in special case described below.
+
+                `srcs` files of type `.java` are compiled.
+                _For readability's sake_, it is not good to put the name of a
+                generated `.java` source file into the `srcs`.
+                Instead, put the depended-on rule name in the `srcs`, as
+                described below.
+
+                `srcs` files of type `.srcjar` are unpacked and
+                compiled. (This is useful if you need to generate a set of .java files with
+                a genrule or build extension.)
+
+                All other files are ignored, as long as
+                there is at least one file of a file type described above. Otherwise an
+                error is raised.
+
+                The `srcs` attribute is required and cannot be empty, unless
+                `runtime_deps` is specified.
+                """,
+            ),
+            stamp = _attrs.tristate.create(
+                default = _attrs.tristate.no,
+                doc = """
+                Whether to encode build information into the binary. Possible values:
+
+                - `stamp = 1`: Always stamp the build information into the binary, even in
+                  [`--nostamp`](https://docs.bazel.build/versions/main/user-manual.html#flag--stamp) builds. **This
+                  setting should be avoided**, since it potentially kills remote caching for the
+                  binary and any downstream actions that depend on it.
+
+                - `stamp = 0`: Always replace build information by constant values. This
+                  gives good build result caching.
+
+                - `stamp = -1`: Embedding of build information is controlled by the
+                  [`--[no]stamp`](https://docs.bazel.build/versions/main/user-manual.html#flag--stamp) flag.
+
+                Stamped binaries are _not_ rebuilt unless their dependencies change.
+                """,
+            ),
+            resource_configuration_filters = attr.string_list(
+                doc = "A list of resource configuration filters, such as 'en' " +
+                      "that will limit the resources in the apk to only the " +
+                      "ones in the 'en' configuration.",
+            ),
+            densities = attr.string_list(
+                doc = "Densities to filter for when building the apk. A " +
+                      "corresponding compatible-screens section will also be " +
+                      "added to the manifest if it does not already contain a " +
+                      "superset listing.",
+            ),
+            robolectric_properties_file = attr.string(
+                doc = "The classpath to robolectric-deps.properties file.",
+                default = "${JAVA_RUNFILES}/robolectric/bazel/robolectric-deps.properties",
+            ),
+            test_class = attr.string(
+                doc = """
+                The Java class to be loaded by the test runner.
+
+                This attribute specifies the name of a Java class to be run by
+                this test. It is rare to need to set this. If this argument is omitted, the Java class
+                whose name corresponds to the `name` of this
+                `android_local_test` rule will be used.
+                The test class needs to be annotated with `org.junit.runner.RunWith`.
+                """,
+            ),
+            _runfiles_root_prefix = attr.label(
+                doc = """
+                A directory prefix that ends with a slash.
+
+                This attribute is appended to ${JAVA_RUNFILES} when the root of path to the runfile
+                resources is not directly under ${JAVA_RUNFILES}.
+                """,
+                default = "//rules/flags:runfiles_root_prefix",
+            ),
+            _flags = attr.label(
+                default = "//rules/flags",
+            ),
+            _java_toolchain = attr.label(
+                default = Label("//tools/jdk:current_java_toolchain"),
+            ),
+            _current_java_runtime = attr.label(
+                default = Label("//tools/jdk:current_java_runtime"),
+                providers = [java_common.JavaRuntimeInfo],
+            ),
+            _implicit_classpath = attr.label_list(
+                default = [
+                    Label("//tools/android:android_jar"),
+                ],
+            ),
+            _enable_manifest_merging_dependency_priorities = attr.label(
+                doc = """When enabled respect the manifest priorities during manifest merging.""",
+                default = "//rules/flags:enable_manifest_merging_dependency_priorities",
+            ),
+        ),
+        _attrs.COMPILATION,
+        _attrs.DATA_CONTEXT,
+        _attrs.AUTOMATIC_EXEC_GROUPS_ENABLED,
+    )
+
+ATTRS = make_attrs()
diff --git a/rules/android_local_test/impl.bzl b/rules/android_local_test/impl.bzl
new file mode 100644
index 00000000000..3a6221fdd6a
--- /dev/null
+++ b/rules/android_local_test/impl.bzl
@@ -0,0 +1,567 @@
+# Copyright 2018 The Bazel Authors. All rights reserved.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#    http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+"""Bazel rule for Android local test."""
+
+load("//rules:acls.bzl", "acls")
+load("//rules:attrs.bzl", "attrs")
+load("//rules:common.bzl", "common")
+load("//rules:java.bzl", "java")
+load(
+    "//rules:processing_pipeline.bzl",
+    "ProviderInfo",
+    "processing_pipeline",
+)
+load("//rules:providers.bzl", "AndroidFilteredJdepsInfo")
+load("//rules:resources.bzl", "resources")
+load(
+    "//rules:utils.bzl",
+    "compilation_mode",
+    "get_android_sdk",
+    "get_android_toolchain",
+    "log",
+    "utils",
+)
+load("@bazel_skylib//rules:common_settings.bzl", "BuildSettingInfo")
+
+JACOCOCO_CLASS = "com.google.testing.coverage.JacocoCoverageRunner"
+TEST_RUNNER_CLASS = "com.google.testing.junit.runner.BazelTestRunner"
+
+# JVM processes for android_local_test targets are typically short lived. By
+# using TieredStopAtLevel=1, aggressive JIT compilations are avoided, which is
+# more optimal for android_local_test workloads.
+DEFAULT_JIT_FLAGS = ["-XX:+TieredCompilation", "-XX:TieredStopAtLevel=1"]
+
+# Many P99 and above android_local_test targets use a lot of memory so the default 1 GiB
+# JVM max heap size is not sufficient. Bump the max heap size to from 1 GiB -> 8 GiB. This performs
+# the best across all P% layers from profiling.
+DEFAULT_GC_FLAGS = ["-Xmx8g"]
+
+# disable class loading by default for faster classloading and consistent enviroment across
+# local and remote execution
+DEFAULT_VERIFY_FLAGS = ["-Xverify:none"]
+
+ANDROID_TOOLCHAIN_TYPE = Label("//toolchains/android:toolchain_type")
+
+def _validations_processor(ctx, **_unused_sub_ctxs):
+    _check_src_pkg(ctx, True)
+
+def _process_manifest(ctx, java_package, **_unused_sub_ctxs):
+    manifest_ctx = None
+    manifest_values = resources.process_manifest_values(
+        ctx,
+        ctx.attr.manifest_values,
+        acls.get_min_sdk_floor(str(ctx.label)),
+    )
+    if ctx.file.manifest == None:
+        # No manifest provided, generate one
+        manifest = ctx.actions.declare_file("_generated/" + ctx.label.name + "/AndroidManifest.xml")
+        resources.generate_dummy_manifest(
+            ctx,
+            out_manifest = manifest,
+            java_package = java_package,
+            min_sdk_version = int(manifest_values.get("minSdkVersion", 16)),  # minsdk supported by robolectric framework
+        )
+        manifest_ctx = struct(processed_manifest = manifest, processed_manifest_values = manifest_values)
+    else:
+        manifest_ctx = resources.bump_min_sdk(
+            ctx,
+            manifest = ctx.file.manifest,
+            manifest_values = ctx.attr.manifest_values,
+            floor = acls.get_min_sdk_floor(str(ctx.label)),
+            enforce_min_sdk_floor_tool = get_android_toolchain(ctx).enforce_min_sdk_floor_tool.files_to_run,
+        )
+
+    return ProviderInfo(
+        name = "manifest_ctx",
+        value = manifest_ctx,
+    )
+
+def _process_resources(ctx, java_package, manifest_ctx, **_unused_sub_ctxs):
+    resources_ctx = resources.package(
+        ctx,
+        deps = ctx.attr.deps,
+        manifest = manifest_ctx.processed_manifest,
+        manifest_values = manifest_ctx.processed_manifest_values,
+        resource_files = ctx.files.resource_files,
+        assets = ctx.files.assets,
+        assets_dir = ctx.attr.assets_dir,
+        resource_configs = ctx.attr.resource_configuration_filters,
+        densities = ctx.attr.densities,
+        nocompress_extensions = ctx.attr.nocompress_extensions,
+        compilation_mode = compilation_mode.get(ctx),
+        java_package = java_package,
+        shrink_resources = attrs.tristate.no,
+        aapt = get_android_toolchain(ctx).aapt2.files_to_run,
+        android_jar = get_android_sdk(ctx).android_jar,
+        busybox = get_android_toolchain(ctx).android_resources_busybox.files_to_run,
+        host_javabase = ctx.attr._host_javabase,
+        # TODO(b/140582167): Throwing on resource conflict need to be rolled
+        # out to android_local_test.
+        should_throw_on_conflict = False,
+    )
+
+    return ProviderInfo(
+        name = "resources_ctx",
+        value = resources_ctx,
+    )
+
+def _process_jvm(ctx, resources_ctx, **_unused_sub_ctxs):
+    deps = (
+        ctx.attr._implicit_classpath +
+        ctx.attr.deps +
+        [get_android_toolchain(ctx).testsupport]
+    )
+
+    if ctx.configuration.coverage_enabled:
+        deps.append(get_android_toolchain(ctx).jacocorunner)
+        java_start_class = JACOCOCO_CLASS
+        coverage_start_class = TEST_RUNNER_CLASS
+    else:
+        java_start_class = TEST_RUNNER_CLASS
+        coverage_start_class = None
+
+    java_info = java_common.add_constraints(
+        java.compile_android(
+            ctx,
+            ctx.outputs.jar,
+            ctx.actions.declare_file(ctx.label.name + "-src.jar"),
+            srcs = ctx.files.srcs,
+            resources = ctx.files.resources,
+            javac_opts = ctx.attr.javacopts,
+            r_java = resources_ctx.r_java,
+            deps = (
+                utils.collect_providers(JavaInfo, deps) +
+                [
+                    JavaInfo(
+                        output_jar = get_android_sdk(ctx).android_jar,
+                        compile_jar = get_android_sdk(ctx).android_jar,
+                        # The android_jar must not be compiled into the test, it
+                        # will bloat the Jar with no benefit.
+                        neverlink = True,
+                    ),
+                ]
+            ),
+            plugins = utils.collect_providers(JavaPluginInfo, ctx.attr.plugins),
+            java_toolchain = common.get_java_toolchain(ctx),
+        ),
+        constraints = ["android"],
+    )
+
+    # TODO(timpeut): some conformance tests require a filtered JavaInfo
+    # with no transitive_ deps.
+    providers = [java_info]
+    runfiles = []
+
+    # Create a filtered jdeps with no resources jar. See b/129011477 for more context.
+    if java_info.outputs.jdeps != None:
+        filtered_jdeps = ctx.actions.declare_file(ctx.label.name + ".filtered.jdeps")
+        filter_jdeps(ctx, java_info.outputs.jdeps, filtered_jdeps, utils.only(resources_ctx.r_java.compile_jars.to_list()))
+        providers.append(AndroidFilteredJdepsInfo(jdeps = filtered_jdeps))
+        runfiles.append(filtered_jdeps)
+
+    return ProviderInfo(
+        name = "jvm_ctx",
+        value = struct(
+            java_info = java_info,
+            providers = providers,
+            deps = deps,
+            java_start_class = java_start_class,
+            coverage_start_class = coverage_start_class,
+            android_properties_file = ctx.attr.robolectric_properties_file,
+            additional_jvm_flags = [],
+        ),
+        runfiles = ctx.runfiles(files = runfiles),
+    )
+
+def _process_proto(_ctx, **_unused_sub_ctxs):
+    return ProviderInfo(
+        name = "proto_ctx",
+        value = struct(
+            proto_extension_registry_dep = depset(),
+        ),
+    )
+
+def _process_deploy_jar(ctx, java_package, jvm_ctx, proto_ctx, resources_ctx, **_unused_sub_ctxs):
+    res_file_path = resources_ctx.validation_result.short_path
+    subs = {
+        "%android_merged_manifest%": resources_ctx.processed_manifest.short_path,
+        "%android_merged_resources%": "jar:file:" + res_file_path + "!/res",
+        "%android_merged_assets%": "jar:file:" + res_file_path + "!/assets",
+        # The native resources_ctx has the package field, whereas the starlark resources_ctx uses the java_package
+        "%android_custom_package%": getattr(resources_ctx, "package", java_package or ""),
+        "%android_resource_apk%": resources_ctx.resources_apk.short_path,
+    }
+    res_runfiles = [
+        resources_ctx.resources_apk,
+        resources_ctx.validation_result,
+        resources_ctx.processed_manifest,
+    ]
+
+    properties_file = _genfiles_artifact(ctx, "test_config.properties")
+    properties_jar = _genfiles_artifact(ctx, "properties.jar")
+    ctx.actions.expand_template(
+        template = utils.only(get_android_toolchain(ctx).robolectric_template.files.to_list()),
+        output = properties_file,
+        substitutions = subs,
+    )
+    _zip_file(ctx, properties_file, "com/android/tools", properties_jar)
+    properties_jar_dep = depset([properties_jar])
+
+    runtime_deps = depset(transitive = [
+        x.transitive_runtime_jars
+        for x in utils.collect_providers(JavaInfo, ctx.attr.runtime_deps)
+    ])
+    android_jar_dep = depset([get_android_sdk(ctx).android_jar])
+    out_jar_dep = depset([ctx.outputs.jar])
+    classpath = depset(
+        transitive = [
+            proto_ctx.proto_extension_registry_dep,
+            out_jar_dep,
+            resources_ctx.r_java.compile_jars,
+            properties_jar_dep,
+            runtime_deps,
+            android_jar_dep,
+            jvm_ctx.java_info.transitive_runtime_jars,
+        ],
+    )
+
+    java.singlejar(
+        ctx,
+        # TODO(timpeut): investigate whether we need to filter the stub classpath as well
+        [f for f in classpath.to_list() if f.short_path.endswith(".jar")],
+        ctx.outputs.deploy_jar,
+        mnemonic = "JavaDeployJar",
+        include_build_data = True,
+        java_toolchain = common.get_java_toolchain(ctx),
+    )
+    return ProviderInfo(
+        name = "deploy_jar_ctx",
+        value = struct(
+            classpath = classpath,
+        ),
+        runfiles = ctx.runfiles(files = res_runfiles, transitive_files = classpath),
+    )
+
+def _preprocess_stub(ctx, **_unused_sub_ctxs):
+    javabase = ctx.attr._current_java_runtime[java_common.JavaRuntimeInfo]
+    java_executable = str(javabase.java_executable_runfiles_path)
+    java_executable_files = javabase.files
+
+    # Absolute java_executable does not require any munging
+    if java_executable.startswith("/"):
+        java_executable = "JAVABIN=" + java_executable
+
+    prefix = ctx.attr._runfiles_root_prefix[BuildSettingInfo].value
+    if not java_executable.startswith(prefix):
+        java_executable = prefix + java_executable
+
+    java_executable = "JAVABIN=${JAVABIN:-${JAVA_RUNFILES}/" + java_executable + "}"
+
+    substitutes = {
+        "%javabin%": java_executable,
+        "%load_lib%": "",
+        "%set_ASAN_OPTIONS%": "",
+    }
+    runfiles = [java_executable_files]
+
+    return ProviderInfo(
+        name = "stub_preprocess_ctx",
+        value = struct(
+            substitutes = substitutes,
+            runfiles = runfiles,
+        ),
+    )
+
+def _process_stub(ctx, deploy_jar_ctx, jvm_ctx, stub_preprocess_ctx, **_unused_sub_ctxs):
+    runfiles = []
+
+    merged_instr = None
+    if ctx.configuration.coverage_enabled:
+        merged_instr = ctx.actions.declare_file(ctx.label.name + "_merged_instr.jar")
+        java.singlejar(
+            ctx,
+            [f for f in deploy_jar_ctx.classpath.to_list() if f.short_path.endswith(".jar")],
+            merged_instr,
+            mnemonic = "JavaDeployJar",
+            include_build_data = True,
+            java_toolchain = common.get_java_toolchain(ctx),
+        )
+        runfiles.append(merged_instr)
+
+    stub = ctx.actions.declare_file(ctx.label.name)
+    classpath_file = ctx.actions.declare_file(ctx.label.name + "_classpath")
+    runfiles.append(classpath_file)
+    test_class = _get_test_class(ctx)
+    if not test_class:
+        # fatal error
+        log.error("test_class could not be derived for " + str(ctx.label) +
+                  ". Explicitly set test_class or move this source file to " +
+                  "a java source root.")
+
+    _create_stub(
+        ctx,
+        stub_preprocess_ctx.substitutes,
+        stub,
+        classpath_file,
+        deploy_jar_ctx.classpath,
+        _get_jvm_flags(ctx, test_class, jvm_ctx.android_properties_file, jvm_ctx.additional_jvm_flags),
+        jvm_ctx.java_start_class,
+        jvm_ctx.coverage_start_class,
+        merged_instr,
+    )
+    return ProviderInfo(
+        name = "stub_ctx",
+        value = struct(
+            stub = stub,
+        ),
+        runfiles = ctx.runfiles(
+            files = runfiles,
+            transitive_files = depset(
+                transitive = stub_preprocess_ctx.runfiles,
+            ),
+        ),
+    )
+
+PROCESSORS = dict(
+    ValidationsProcessor = _validations_processor,
+    ManifestProcessor = _process_manifest,
+    ResourceProcessor = _process_resources,
+    JvmProcessor = _process_jvm,
+    ProtoProcessor = _process_proto,
+    DeployJarProcessor = _process_deploy_jar,
+    StubPreProcessor = _preprocess_stub,
+    StubProcessor = _process_stub,
+)
+
+def finalize(
+        ctx,
+        jvm_ctx,
+        proto_ctx,
+        providers,
+        runfiles,
+        stub_ctx,
+        validation_outputs,
+        **_unused_sub_ctxs):
+    """Creates the final providers for the rule.
+
+    Args:
+      ctx: The context.
+      jvm_ctx: ProviderInfo. The jvm ctx.
+      proto_ctx: ProviderInfo. The proto ctx.
+      providers: sequence of providers. The providers to propagate.
+      runfiles: Runfiles. The runfiles collected during processing.
+      stub_ctx: ProviderInfo. The stub ctx.
+      validation_outputs: sequence of Files. The validation outputs.
+      **_unused_sub_ctxs: Unused ProviderInfo.
+
+    Returns:
+      A struct with Android and Java legacy providers and a list of providers.
+    """
+    runfiles = runfiles.merge(ctx.runfiles(collect_data = True))
+    runfiles = runfiles.merge(utils.get_runfiles(ctx, jvm_ctx.deps + ctx.attr.data + ctx.attr.runtime_deps))
+
+    providers.extend([
+        DefaultInfo(
+            files = depset(
+                [ctx.outputs.jar, stub_ctx.stub],
+                transitive = [proto_ctx.proto_extension_registry_dep],
+                order = "preorder",
+            ),
+            executable = stub_ctx.stub,
+            runfiles = runfiles,
+        ),
+        OutputGroupInfo(
+            _validation = depset(validation_outputs),
+        ),
+        coverage_common.instrumented_files_info(
+            ctx = ctx,
+            source_attributes = ["srcs"],
+            dependency_attributes = ["deps", "runtime_deps", "data"],
+        ),
+    ])
+    return providers
+
+_PROCESSING_PIPELINE = processing_pipeline.make_processing_pipeline(
+    processors = PROCESSORS,
+    finalize = finalize,
+)
+
+def impl(ctx):
+    java_package = java.resolve_package_from_label(ctx.label, ctx.attr.custom_package)
+    return processing_pipeline.run(ctx, java_package, _PROCESSING_PIPELINE)
+
+def _check_src_pkg(ctx, warn = True):
+    pkg = ctx.label.package
+    for attr in ctx.attr.srcs:
+        if attr.label.package != pkg:
+            msg = "Do not import %s directly. Either move the file to this package or depend on an appropriate rule there." % attr.label
+            if warn:
+                log.warn(msg)
+            else:
+                log.error(msg)
+
+def _genfiles_artifact(ctx, name):
+    return ctx.actions.declare_file(
+        "/".join([ctx.genfiles_dir.path, ctx.label.name, name]),
+    )
+
+def _get_test_class(ctx):
+    # Use the specified test_class if set
+    if ctx.attr.test_class != "":
+        return ctx.attr.test_class
+
+    # Use a heuristic based on the rule name and the "srcs" list
+    # to determine the primary Java class.
+    expected = "/" + ctx.label.name + ".java"
+    for f in ctx.attr.srcs:
+        path = f.label.package + "/" + f.label.name
+        if path.endswith(expected):
+            return java.resolve_package(path[:-5])
+
+    # Last resort: Use the name and package name of the target.
+    return java.resolve_package(ctx.label.package + "/" + ctx.label.name)
+
+def _create_stub(
+        ctx,
+        substitutes,
+        stub_file,
+        classpath_file,
+        runfiles,
+        jvm_flags,
+        java_start_class,
+        coverage_start_class,
+        merged_instr):
+    subs = {
+        "%needs_runfiles%": "1",
+        "%runfiles_manifest_only%": "",
+        # To avoid cracking open the depset, classpath is read from a separate
+        # file created in its own action. Needed as expand_template does not
+        # support ctx.actions.args().
+        "%classpath%": "$(eval echo $(<%s))" % (classpath_file.short_path),
+        "%java_start_class%": java_start_class,
+        "%jvm_flags%": " ".join(jvm_flags),
+        "%workspace_prefix%": ctx.workspace_name + "/",
+    }
+
+    if coverage_start_class:
+        prefix = ctx.attr._runfiles_root_prefix[BuildSettingInfo].value
+        subs["%set_jacoco_metadata%"] = (
+            "export JACOCO_METADATA_JAR=${JAVA_RUNFILES}/" + prefix +
+            merged_instr.short_path
+        )
+        subs["%set_jacoco_main_class%"] = (
+            "export JACOCO_MAIN_CLASS=" + coverage_start_class
+        )
+        subs["%set_jacoco_java_runfiles_root%"] = (
+            "export JACOCO_JAVA_RUNFILES_ROOT=${JAVA_RUNFILES}/" + prefix
+        )
+    else:
+        subs["%set_jacoco_metadata%"] = ""
+        subs["%set_jacoco_main_class%"] = ""
+        subs["%set_jacoco_java_runfiles_root%"] = ""
+
+    subs.update(substitutes)
+
+    ctx.actions.expand_template(
+        template = utils.only(get_android_toolchain(ctx).java_stub.files.to_list()),
+        output = stub_file,
+        substitutions = subs,
+        is_executable = True,
+    )
+
+    args = ctx.actions.args()
+    args.add_joined(
+        runfiles,
+        join_with = ":",
+        map_each = _get_classpath,
+    )
+    args.set_param_file_format("multiline")
+    ctx.actions.write(
+        output = classpath_file,
+        content = args,
+    )
+    return stub_file
+
+def _get_classpath(s):
+    return "${J3}" + s.short_path
+
+def _get_jvm_flags(ctx, main_class, robolectric_properties_path, additional_jvm_flags):
+    return [
+        "-ea",
+        "-Dbazel.test_suite=" + main_class,
+        "-Drobolectric.offline=true",
+        "-Drobolectric-deps.properties=" + robolectric_properties_path,
+        "-Duse_framework_manifest_parser=true",
+        "-Drobolectric.logging=stdout",
+        "-Drobolectric.logging.enabled=true",
+        "-Dorg.robolectric.packagesToNotAcquire=com.google.testing.junit.runner.util",
+    ] + DEFAULT_JIT_FLAGS + DEFAULT_GC_FLAGS + DEFAULT_VERIFY_FLAGS + additional_jvm_flags + [
+        ctx.expand_make_variables(
+            "jvm_flags",
+            ctx.expand_location(flag, ctx.attr.data),
+            {},
+        )
+        for flag in ctx.attr.jvm_flags
+    ]
+
+def _zip_file(ctx, f, dir_name, out_zip):
+    cmd = """
+base=$(pwd)
+tmp_dir=$(mktemp -d)
+
+cd $tmp_dir
+mkdir -p {dir_name}
+cp $base/{f} {dir_name}
+$base/{zip_tool} -jt -X -q $base/{out_zip} {dir_name}/$(basename {f})
+""".format(
+        zip_tool = get_android_toolchain(ctx).zip_tool.files_to_run.executable.path,
+        f = f.path,
+        dir_name = dir_name,
+        out_zip = out_zip.path,
+    )
+    ctx.actions.run_shell(
+        command = cmd,
+        inputs = [f],
+        tools = get_android_toolchain(ctx).zip_tool.files,
+        outputs = [out_zip],
+        mnemonic = "AddToZip",
+        toolchain = ANDROID_TOOLCHAIN_TYPE,
+    )
+
+def filter_jdeps(ctx, in_jdeps, out_jdeps, filter_suffix):
+    """Runs the JdepsFilter tool.
+
+    Args:
+      ctx: The context.
+      in_jdeps: File. The input jdeps file.
+      out_jdeps: File. The filtered jdeps output.
+      filter_suffix: File. The jdeps suffix to filter.
+    """
+    args = ctx.actions.args()
+    args.add("--in")
+    args.add(in_jdeps.path)
+    args.add("--target")
+    args.add(filter_suffix)
+    args.add("--out")
+    args.add(out_jdeps.path)
+    ctx.actions.run(
+        inputs = [in_jdeps],
+        outputs = [out_jdeps],
+        executable = get_android_toolchain(ctx).jdeps_tool.files_to_run,
+        arguments = [args],
+        mnemonic = "JdepsFilter",
+        progress_message = "Filtering jdeps",
+        toolchain = ANDROID_TOOLCHAIN_TYPE,
+    )
diff --git a/rules/android_local_test/resources.bzl b/rules/android_local_test/resources.bzl
new file mode 100644
index 00000000000..1f2442e30a6
--- /dev/null
+++ b/rules/android_local_test/resources.bzl
@@ -0,0 +1,73 @@
+# Copyright 2020 The Bazel Authors. All rights reserved.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#    http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+"""Implementation."""
+
+load("//rules:acls.bzl", "acls")
+load(
+    "//rules:processing_pipeline.bzl",
+    "ProviderInfo",
+    "processing_pipeline",
+)
+load("//rules:resources.bzl", _resources = "resources")
+load("//rules:utils.bzl", "compilation_mode", "get_android_toolchain", "utils")
+load("//rules:attrs.bzl", _attrs = "attrs")
+
+def _process_manifest(ctx, **unused_ctxs):
+    manifest_ctx = _resources.bump_min_sdk(
+        ctx,
+        manifest = ctx.file.manifest,
+        floor = acls.get_min_sdk_floor(str(ctx.label)) if _is_test_binary(ctx) else 0,
+        enforce_min_sdk_floor_tool = get_android_toolchain(ctx).enforce_min_sdk_floor_tool.files_to_run,
+    )
+
+    return ProviderInfo(
+        name = "manifest_ctx",
+        value = manifest_ctx,
+    )
+
+def _process_resources_for_android_local_test(ctx, manifest_ctx, java_package, **unused_ctx):
+    packaged_resources_ctx = _resources.package(
+        ctx,
+        manifest = manifest_ctx.processed_manifest,
+        manifest_values = utils.expand_make_vars(ctx, ctx.attr.manifest_values),
+        java_package = java_package,
+        use_legacy_manifest_merger = False,
+        should_throw_on_conflict = not acls.in_allow_resource_conflicts(str(ctx.label)),
+        deps = ctx.attr.deps + ctx.attr.associates,
+        aapt = get_android_toolchain(ctx).aapt2.files_to_run,
+        android_jar = ctx.attr._android_sdk[AndroidSdkInfo].android_jar,
+        busybox = get_android_toolchain(ctx).android_resources_busybox.files_to_run,
+        host_javabase = ctx.attr._host_javabase,
+    )
+    return ProviderInfo(
+        name = "packaged_resources_ctx",
+        value = packaged_resources_ctx,
+    )
+
+def _is_test_binary(ctx):
+    """Whether this android_binary target is a test binary.
+
+    Args:
+      ctx: The context.
+
+    Returns:
+      Boolean indicating whether the target is a test target.
+    """
+    return ctx.attr.testonly or ctx.attr.instruments or str(ctx.label).find("/javatests/") >= 0
+
+PROCESSORS = dict(
+    ManifestProcessor = _process_manifest,
+    ResourceProcessor = _process_resources_for_android_local_test,
+)
diff --git a/rules/android_local_test/rule.bzl b/rules/android_local_test/rule.bzl
new file mode 100644
index 00000000000..a045d49ddfe
--- /dev/null
+++ b/rules/android_local_test/rule.bzl
@@ -0,0 +1,52 @@
+# Copyright 2018 The Bazel Authors. All rights reserved.
+#
+# Licensed under the Apache License, Version 2.0 (the "License");
+# you may not use this file except in compliance with the License.
+# You may obtain a copy of the License at
+#
+#    http://www.apache.org/licenses/LICENSE-2.0
+#
+# Unless required by applicable law or agreed to in writing, software
+# distributed under the License is distributed on an "AS IS" BASIS,
+# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+# See the License for the specific language governing permissions and
+# limitations under the License.
+
+"""Bazel rule for Android local test."""
+
+load(":attrs.bzl", "ATTRS")
+load(":impl.bzl", "impl")
+
+def make_rule(
+        attrs = ATTRS,
+        implementation = impl):
+    """Makes the rule.
+
+    Args:
+      attrs: A dict. The attributes for the rule.
+      implementation: A function. The rule's implementation method.
+
+    Returns:
+      A rule.
+    """
+    return rule(
+        attrs = attrs,
+        implementation = implementation,
+        cfg = config_common.config_feature_flag_transition("feature_flags"),
+        fragments = [
+            "android",
+            "java",
+        ],
+        test = True,
+        outputs = dict(
+            deploy_jar = "%{name}_deploy.jar",
+            jar = "%{name}.jar",
+        ),
+        toolchains = [
+            "//toolchains/android:toolchain_type",
+            "//toolchains/android_sdk:toolchain_type",
+            "@bazel_tools//tools/jdk:toolchain_type",
+        ],
+    )
+
+android_local_test = make_rule()
